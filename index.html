<!DOCTYPE html>
<html lang="it">
<head>
    <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Configuratore Barca 3D</title>
  <style>
    html, body {
      height: 100%;
    }

    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background-color: #05070a;
      background:
        radial-gradient(circle at top, rgba(20, 80, 140, 0.45), rgba(2, 6, 12, 0.9) 60%),
        url('sfondo.jpg?v=2') center/cover no-repeat;
      color: #fff;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 85vh;
    }

    #header {
      width: 60vw;
      margin-top: 27px;
      text-align: center;
    }

    #header h1 {
      margin: 0 0 6px 0;
      font-size: 28px;
      letter-spacing: 2px;
    }

    #header h2 {
      margin: 0 0 8px 0;
      font-size: 16px;
      font-weight: 600;
      text-transform: uppercase;
    }

    #viewer {
      width: 60vw;
      height: 80vh;
      border: 5px solid rgba(255,255,255,0.5);
      border-radius: 12px;
      background: rgba(0,0,0,0.35);
      box-shadow: 0 12px 30px rgba(0,0,0,0.35);
      overflow: visible;
      position: relative;
    }

    @media (max-width: 900px) {
      body {
        justify-content: flex-start;
        padding-top: 10px;
      }

      #header {
        width: min(92vw, 560px);
      }

      #header h1 {
        font-size: 22px;
      }

      #header h2 {
        font-size: 12px;
      }

      #viewer {
        width: 96vw;
        height: 85vh;
        border-width: 3px;
      }

      #viewer-ui h1 {
        font-size: 26px;
      }

      #viewer-ui h2 {
        font-size: 12px;
      }

      #price-tag {
  margin-top: 27px;
  font-size: 20px;
  letter-spacing: 0.5px;
  color: #7CFF00;;
  background: transparent;
  border: none;
  padding: 0;
}

      .step-header {
        top: 6px;
        height: 32px;
        gap: 10px;
      }

      #step-title {
        font-size: 12px;
        letter-spacing: 0.6px;
      }

      .nav-btn {
        width: 36px;
        height: 36px;
      }

      .nav-btn::after {
        border-top-width: 6px;
        border-bottom-width: 6px;
        border-left-width: 10px;
      }

      .reset-btn::after { content: none !important; }

      #step-finitura button,
      #step-colori button {
        min-width: 96px;
        padding: 10px 12px;
        font-size: 13px;
      }

      #step-colori select {
        min-width: 120px;
        font-size: 12px;
      }

      #step-accessori {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px 10px;
        text-align: left;
        padding-top: 0;
      }
      #step-accessori label {
        margin-left: 0 !important;
        padding: 6px 6px;
        font-size: 11px;
      }

      #step-accessori input {
        transform: scale(1.15);
      }
    }

    #loading {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      background: rgba(0, 0, 0, 0.55);
      z-index: 8;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: 600;
      font-size: 12px;
      color: #7CFF00;
      pointer-events: none;
      overflow: hidden;
    }

    #loading-bar {
      width: min(320px, 70%);
      height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.15);
      overflow: hidden;
      box-shadow: inset 0 0 8px rgba(0,0,0,0.6);
    }

    #loading-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #7CFF00, #3DFF8C);
      transition: width 0.2s ease;
    }
    #loading-intro-wrap {
      position: absolute;
      inset: 0;
      z-index: 0;
      width: 100%;
      height: 100%;
      border: none;
      border-radius: 0;
      overflow: hidden;
      background: #000;
      box-shadow: none;
    }
    #loading-intro-video {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #loading-text,
    #loading-bar {
      position: relative;
      z-index: 2;
    }

    #interact-hint {
      position: absolute;
      left: 0;
      top: 0;
      transform: translate(-50%, -50%);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 7;
      pointer-events: auto;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      cursor: pointer;
    }
    #interact-hint .dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #00FFFF;
      box-shadow: 0 0 0 0 rgba(0,255,255,0.75);
      animation: hintPulse 1.4s infinite;
    }
    @keyframes hintPulse {
      0% { box-shadow: 0 0 0 0 rgba(0,255,255,0.75); }
      75% { box-shadow: 0 0 0 12px rgba(0,255,255,0); }
      100% { box-shadow: 0 0 0 0 rgba(0,255,255,0); }
    }
    #interact-hints {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 7;
    }
    .interact-action-dot {
      position: absolute;
      width: 12px;
      height: 12px;
      min-width: 0;
      min-height: 0;
      padding: 0;
      margin: 0;
      box-sizing: border-box;
      appearance: none;
      -webkit-appearance: none;
      outline: none;
      line-height: 0;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      border: none;
      background: #00FFFF;
      box-shadow: 0 0 0 0 rgba(0,255,255,0.75);
      animation: hintPulse 1.4s infinite;
      cursor: pointer;
      pointer-events: auto;
    }
    .interact-action-dot.is-disabled {
      opacity: 0.28;
      cursor: default;
      pointer-events: none;
      animation: none;
      box-shadow: none;
    }
    .panca-arrow-btn {
      position: absolute;
      min-width: 62px;
      height: 24px;
      min-height: 0;
      padding: 0 8px;
      margin: 0;
      box-sizing: border-box;
      appearance: none;
      -webkit-appearance: none;
      border-radius: 999px;
      transform: translate(-50%, -50%);
      border: 1px solid rgba(0,255,255,0.85);
      background: rgba(0,0,0,0.6);
      color: #00FFFF;
      font-size: 11px;
      font-weight: 600;
      line-height: 1;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      cursor: pointer;
      pointer-events: auto;
    }
    .panca-arrow-btn.is-disabled {
      opacity: 0.3;
      cursor: default;
      pointer-events: none;
      overflow: hidden;
    }

    #viewer-ui {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      pointer-events: none;
      overflow: visible;
    }

    #viewer-ui .top,
    #viewer-ui .bottom {
      pointer-events: auto;
      position: relative;
      z-index: 6;
      pointer-events: auto;
padding: 10px 14px;
      text-align: center;
      background: linear-gradient(
        to bottom,
        rgba(0,0,0,0.55),
        rgba(0,0,0,0)
      );
    }

    
    #viewer-ui .top *,
    #viewer-ui .bottom * {
      pointer-events: auto;
    }
#viewer-ui .bottom {
      background: linear-gradient(
        to top,
        rgba(0,0,0,0.55),
        rgba(0,0,0,0)
      );
      position: relative;
      padding-top: 42px;
    }

    
    #viewer-ui .top *,
    #viewer-ui .bottom * {
      pointer-events: auto;
    }
#viewer-ui h1 {
      margin: 0;
      font-size: 34px;
      letter-spacing: 2px;
      color: #7CFF00;
    }

    #viewer-ui h2 {
      margin: 0 0 6px 0;
      font-size: 14px;
      font-weight: 600;
      text-transform: uppercase;
      text-align: center;
      color: #7CFF00;
    }

    #price-tag {
  margin-top: 27px;
  font-size: 20px;
  letter-spacing: 0.5px;
  color: #7CFF00;;
  background: transparent;
  border: none;
  padding: 0;
}

    .color-row {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
    }

    .color-group {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .color-label {
      font-weight: 600;
      font-size: 12px;
      text-transform: uppercase;
      opacity: 0.85;
      margin-right: 4px;
    }
    .info-pill {
      width: 16px;
      height: 16px;
      min-width: 16px;
      min-height: 16px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.85);
      background: rgba(0,0,0,0.55);
      color: #fff;
      font-size: 11px;
      line-height: 1;
      font-weight: 700;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      padding: 0;
    }
    #info-panel {
      position: absolute;
      left: 50%;
      top: 54%;
      transform: translate(-50%, -50%);
      width: min(420px, calc(100% - 28px));
      background: rgba(8,16,8,0.92);
      border: 1px solid rgba(124,255,0,0.45);
      border-radius: 10px;
      padding: 12px 14px 10px;
      z-index: 9;
      display: none;
      pointer-events: auto;
      box-shadow: 0 8px 24px rgba(0,0,0,0.45);
    }
    #info-panel.is-open { display: block; }
    .info-panel-head { display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:6px; }
    #info-title { margin:0; font-size:13px; color:#7CFF00; text-transform:uppercase; letter-spacing:0.4px; }
    #info-close { border:1px solid rgba(255,255,255,0.35); background:rgba(0,0,0,0.45); color:#fff; font-size:11px; padding:4px 8px; border-radius:6px; cursor:pointer; text-transform:uppercase; }
    #info-body { margin:0; color:rgba(255,255,255,0.9); font-size:12px; line-height:1.45; white-space:pre-wrap; }

    .nav-btn {
      position: relative;
      width: 28px;
      height: 28px;
      padding: 0;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.35);
      background: rgba(0,0,0,0.55);
      display: flex;
      align-items: center;
      justify-content: center;
transition: background 0.2s ease, transform 0.2s ease;
    }

    .nav-btn::after {
      content: '';
      width: 0;
      height: 0;
      border-top: 5px solid transparent;
      border-bottom: 5px solid transparent;
      border-left: 8px solid #7CFF00;
    }

    .nav-btn:hover {
      background: rgba(0,0,0,0.7);
    }

    .nav-btn:focus-visible {
      outline: 2px solid #7CFF00;
      outline-offset: 3px;
    }

    .back-btn {
      transform: none;
      transform-origin: center;
    }

    .reset-btn::after { content: none !important; }

    .nav-btn.is-disabled {
      opacity: 0.35;
      pointer-events: none;
      overflow: hidden;
    }

    .nav-btn.is-hidden {
      visibility: hidden;
      pointer-events: none;
      overflow: hidden;
    }

    .ghost-btn {
      visibility: hidden;
      pointer-events: none;
      overflow: hidden;
    }

    .step-header {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      padding: 0 6px;
      height: 26px;
    }

    #step-title {
      font-size: 14px;
      font-weight: 600;
      text-transform: uppercase;
      color: #7CFF00;
      letter-spacing: 1px;
      text-align: center;
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .step { margin: 0 0 6px 0; }
    .hidden { display: none; }
    .is-hidden { display: none; }

    button {
      margin: 4px;
      padding: 8px 14px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      background: #333;
      color: #fff;
}

    #step-colori button {
      padding: 6px 10px;
      font-size: 12px;
      margin: 3px;
    }


    #step-colori .info-pill,
    #step-title-wrap .info-pill {
      width: 16px !important;
      height: 16px !important;
      min-width: 16px !important;
      min-height: 16px !important;
      padding: 0 !important;
      margin: 0 !important;
      border-radius: 50% !important;
      font-size: 11px !important;
      line-height: 1 !important;
      display: inline-flex !important;
      align-items: center !important;
      justify-content: center !important;
      box-sizing: border-box !important;
    }

    #step-finitura select,
    #step-colori select {
      min-width: 140px;
      padding: 6px 8px;
      font-size: 12px;
      min-height: 34px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.35);
      background: rgba(0,0,0,0.6);
      color: #fff;
    }

    #step-colori option {
      background: #111;
      color: #fff;
    }

        #step-finitura button {
      padding: 6px 8px;
      font-size: 12px;
      min-width: 140px;
    }

    #step-accessori {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px 18px;
      text-align: left;
      padding-top: 0;
    }

    #step-accessori label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 7px 8px;
      font-size: 12px;
      line-height: 14px;
      position: relative;
    }

    #step-accessori input {
      transform: scale(1.1);
    }

    #step-colori {
      padding-top: 0;
    }

    #step-accessori {
      padding-top: 0;
    }

      button:hover { background:#555; }
      button.active { background:#1e90ff; }
    .choice-row {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  align-items: center;
  justify-content: center;
}

.choice-btn,
.choice-option {
  margin: 0;
  padding: 8px 12px;
  border-radius: 6px;
  border: 1px solid rgba(255,255,255,0.35);
  background: rgba(0,0,0,0.55);
  color: #fff;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.4px;
}


.choice-btn.trigger { text-transform: none; }
.choice-dropdown {
  position: relative;
  display: inline-flex;
}

.choice-menu {
  position: absolute;
  top: 100%;
  left: 0;
  margin-top: 6px;
  padding: 6px 8px;
  display: none;
  flex-direction: column;
  gap: 0;
  min-width: 180px;
  background: rgba(0,0,0,0.75);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 8px;
  z-index: 8;
}

.choice-dropdown:hover .choice-menu,
.choice-dropdown:focus-within .choice-menu {
  display: flex;
}

.choice-sub {
  position: relative;
  display: inline-flex;
}

.choice-submenu {
  position: absolute;
  left: 100%;
  bottom: 0;
  margin-left: 6px;
  padding: 6px 8px;
  display: none;
  flex-direction: column;
  gap: 0;
  min-width: 180px;
  background: rgba(0,0,0,0.75);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 8px;
  z-index: 9;
}

.choice-sub:hover .choice-submenu,
.choice-sub:focus-within .choice-submenu {
  display: flex;
}

.choice-option {
  width: 100%;
  text-align: left;
  padding: 6px 6px;
  font-size: 11px;
  text-transform: none;
  background: transparent;
  border: none;
  color: #fff;
}

.choice-option:hover {
  background: rgba(255,255,255,0.08);
}

.choice-option.is-selected {
  color: #7CFF00;
}

#step-colori .color-choice-dropdown {
  position: relative;
  display: inline-flex;
  min-width: 124px;
  max-width: none;
}
#step-colori .color-choice-dropdown .choice-btn.trigger {
  min-width: 124px;
  width: 100%;
  justify-content: space-between;
  align-items: center;
  padding: 5px 6px;
  font-size: 10px;
  white-space: normal;
  overflow: visible;
  text-overflow: clip;
  line-height: 1.15;
}
#step-colori .color-choice-dropdown .choice-btn.trigger::after {
  content: '\25BE';
  margin-left: 8px;
  font-size: 10px;
  color: #7CFF00;
}
#step-colori .color-choice-dropdown .choice-menu {
  display: none;
  min-width: 260px;
  width: max-content;
  max-width: min(92vw, 560px);
  top: auto;
  bottom: calc(100% + 6px);
  max-height: min(52vh, 360px);
  overflow-y: auto;
  overflow-x: hidden;
  z-index: 30;
  background: rgba(6, 12, 18, 0.98);
  border: 1px solid rgba(255,255,255,0.28);
  box-shadow: 0 10px 24px rgba(0,0,0,0.55);
  backdrop-filter: none;
}
#step-colori .color-choice-dropdown.open-up .choice-menu {
  top: auto;
  bottom: calc(100% + 6px);
}
#step-colori .color-choice-dropdown.is-open .choice-menu {
  display: flex;
}
#step-colori .choice-menu > .choice-option {
  background: rgba(12, 18, 26, 0.98);
}
#step-colori .color-choice-dropdown.is-open {
  z-index: 120;
}
#step-colori .choice-sub {
  display: block;
  width: 100%;
}
#step-colori .choice-submenu {
  position: static;
  left: auto;
  bottom: auto;
  margin: 4px 0 0 0;
  min-width: 112px;
  width: max-content;
  border-radius: 6px;
  z-index: 121;
  overflow-x: hidden;
  background: rgba(6, 12, 18, 0.98);
  border: 1px solid rgba(255,255,255,0.2);
}
#step-colori .choice-submenu .choice-option {
  padding: 3px 4px;
  font-size: 9px;
  white-space: normal;
  line-height: 1.2;
  background: rgba(12, 18, 26, 0.98);
}
#step-colori .choice-sub.is-open .choice-submenu {
  display: flex;
}
#step-colori .choice-sub:hover .choice-submenu,
#step-colori .choice-sub:focus-within .choice-submenu {
  display: none;
}
#step-colori .choice-sub.is-open:hover .choice-submenu,
#step-colori .choice-sub.is-open:focus-within .choice-submenu {
  display: flex;
}
.color-swatch-grid {
  display: grid;
  grid-template-columns: repeat(8, 28px);
  gap: 2px;
  min-width: max-content;
}
.texture-swatch-grid {
  display: grid;
  grid-template-columns: repeat(8, 28px);
  gap: 4px;
  min-width: max-content;
}
.color-swatch-option {
  border: 1px solid rgba(255,255,255,0.65);
  background: transparent;
  color: #fff;
  border-radius: 2px;
  margin: 0 !important;
  padding: 0;
  font-size: 0;
  display: block;
  width: 28px;
  height: 28px;
  min-width: 28px;
  min-height: 28px;
  max-width: 28px;
  max-height: 28px;
  box-sizing: border-box;
  align-items: center;
  justify-content: center;
  cursor: pointer;
}
.color-swatch-option .swatch {
  display: none;
}
.color-swatch-option.is-selected {
  outline: 1px solid #7CFF00;
  outline-offset: 1px;
}
.texture-swatch-option {
  border: 1px solid rgba(255,255,255,0.65);
  background-color: #101820;
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  color: transparent;
  border-radius: 4px;
  margin: 0 !important;
  padding: 0;
  font-size: 0;
  display: block;
  width: 28px;
  height: 28px;
  min-width: 28px;
  min-height: 28px;
  max-width: 28px;
  max-height: 28px;
  box-sizing: border-box;
  cursor: pointer;
}
.texture-swatch-option.is-selected {
  outline: 1px solid #7CFF00;
  outline-offset: 1px;
}

#viewer-ui label,
      #viewer-ui input,
      #viewer-ui select,
      #viewer-ui button {
cursor: pointer;
      }
  
    /* Extra UI */
    .controls-overlay {
      display: none;
      position: absolute;
      inset: 0;
      align-items: flex-start;
      justify-content: center;
      text-align: center;
      padding: calc(18% + 20px) 18px 0;
      font-size: 22px;
      line-height: 1.5;
      letter-spacing: 0.3px;
      font-weight: 700;
      color: #7CFF00;
      background: rgba(0,0,0,0.25);
      z-index: 4;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .controls-overlay.is-hidden {
      opacity: 0;
    }
#screenshot-btn {
      position: absolute;
      top: 12px;
      left: 12px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.35);
      padding: 8px 12px;
      font-size: 12px;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      color: #7CFF00;
    }
    #rx-btn {
      position: absolute;
      top: 52px;
      left: 12px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.35);
      padding: 8px 12px;
      font-size: 12px;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      color: #FFFF00;
      display: none;
    }
    #rx-btn.is-active {
      color: #00d4ff;
      border-color: rgba(0,212,255,0.65);
    }
    #live-summary {
      position: absolute;
      top: 96px;
      left: 12px;
      width: min(340px, calc(100vw - 24px));
      padding: 8px 10px;
      border: none;
      background: transparent;
      color: #d9f7ff;
      font-size: 11px;
      line-height: 1.35;
      text-align: left;
      border-radius: 8px;
      z-index: 7;
      pointer-events: none;
      box-sizing: border-box;
    }
    #live-summary .live-summary-title {
      margin: 0 0 4px 0;
      color: #7CFF00;
      font-size: 10px;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    #live-summary ul {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 3px;
    }
    #live-summary li {
      margin: 0;
      padding: 0;
      color: rgba(255,255,255,0.9);
      word-break: break-word;
    }
    #live-summary b {
      color: #9fe8ff;
      font-weight: 700;
    }

    .lang-switch {
      position: absolute;
      top: 27px;
      right: 112px;
      display: inline-flex;
      gap: 8px;
      z-index: 7;
      align-items: center;
    }
    .currency-switch {
      position: absolute;
      top: 27px;
      left: 112px;
      display: inline-flex;
      gap: 8px;
      z-index: 7;
      align-items: center;
    }
    .lang-btn {
      background: transparent;
      border: none;
      color: #ffffff;
      padding: 0;
      margin: 0;
      font-size: 12px;
      letter-spacing: 0.4px;
      text-transform: uppercase;
      line-height: 1;
      min-width: 0;
      cursor: pointer;
    }
    .currency-btn {
      background: transparent;
      border: none;
      color: #ffffff;
      padding: 0;
      margin: 0;
      font-size: 12px;
      letter-spacing: 0.4px;
      text-transform: uppercase;
      line-height: 1;
      min-width: 0;
      cursor: pointer;
    }
    .lang-btn.is-active {
      color: #00d4ff;
      text-decoration: underline;
      text-underline-offset: 2px;
    }
    .currency-btn.is-active {
      color: #00d4ff;
      text-decoration: underline;
      text-underline-offset: 2px;
    }
    #audio-toggle {
      position: absolute;
      top: 12px;
      right: 12px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.35);
      padding: 8px 12px;
      font-size: 12px;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      color: #7CFF00;
    }
    #audio-toggle.is-muted {
      color: #ff6b6b;
      border-color: rgba(255,107,107,0.65);
    }

    #order-btn {
      position: absolute;
      top: 12px;
      right: 12px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.35);
      padding: 8px 12px;
      font-size: 12px;
      letter-spacing: 0.6px;
      text-transform: uppercase;
      color: #7CFF00;
    }

    #order-modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.7);
      z-index: 20;
    }
    #order-modal.is-open { display: flex; }
    .order-dialog {
      width: min(92vw, 720px);
      max-height: 88vh;
      overflow: auto;
      background: rgba(8,12,18,0.95);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 12px;
      padding: 16px 18px;
      color: #fff;
      box-shadow: 0 20px 40px rgba(0,0,0,0.45);
    }
    .order-header { display:flex; align-items:center; justify-content:space-between; margin-bottom:10px; }
    .order-header h3 { margin:0; font-size:18px; letter-spacing:1px; text-transform:uppercase; color:#7CFF00; }
    .order-close { background:transparent; border:1px solid rgba(255,255,255,0.35); color:#fff; padding:4px 8px; font-size:12px; }
    .order-grid { display:grid; grid-template-columns:1fr 1fr; gap:10px 12px; margin-bottom:12px; }
    .order-grid label { display:flex; flex-direction:column; gap:4px; font-size:12px; color: rgba(255,255,255,0.8); }
    .order-grid input,
    .order-grid textarea { background: rgba(0,0,0,0.45); border:1px solid rgba(255,255,255,0.2); color:#fff; border-radius:6px; padding:8px 10px; font-size:12px; }
    .order-grid textarea { min-height:70px; resize:vertical; grid-column:1 / -1; }
    .order-summary { display:grid; grid-template-columns:1fr auto; gap:8px 14px; align-items:start; margin-bottom:12px; font-size:12px; }
    .order-summary .label { color: rgba(255,255,255,0.6); }
    .order-qr { justify-self:end; background:#fff; padding:6px; border-radius:6px; }
    .order-actions { display:flex; gap:8px; justify-content:space-between; }
    .order-confirm { color:#ff3b3b !important; border-color:#ff3b3b !important; }
    .order-actions button { background: rgba(0,0,0,0.55); border:1px solid rgba(255,255,255,0.35); color:#7CFF00; padding:8px 12px; font-size:12px; letter-spacing:0.6px; text-transform:uppercase; }

    @media (max-width: 900px) {
      .controls-overlay { font-size: 17px; }
      #audio-toggle { top: 8px; right: 8px; padding: 6px 8px; font-size: 11px; }
      .lang-switch { top: 55px; right: 15px; gap: 4px; flex-direction: column; align-items: flex-end; }
      .currency-switch { top: 55px; left: 15px; right: auto; gap: 4px; flex-direction: column; align-items: flex-start; }
      .lang-btn { font-size: 10px; }
      .currency-btn { font-size: 10px; }
#order-btn { top: 8px; right: 8px; padding: 6px 8px; font-size: 11px; }
      #screenshot-btn { top: 8px; left: 8px; padding: 6px 8px; font-size: 11px; }
      #rx-btn { top: 88px; right: 8px; left: auto; padding: 6px 8px; font-size: 11px; }
    }
  
    .home-link {
      width: 60vw;
      max-width: 980px;
      margin: 10px auto 0;
      text-align: center;
    }
    .home-link a {
      display: inline-block;
      color: #00FFFF;
      text-decoration: none;
      font-weight: 700;
      font-size: 12px;
      letter-spacing: 0.4px;
      text-transform: uppercase;
    }
    .home-link a:hover { text-decoration: underline; }

    @media (max-width: 900px) {
      .home-link { width: 96vw; }
      .home-link a { font-size: 11px; }
    }
    
  
    /* Accessori layout overrides */
    .hidden { display: none !important; }
#step-accessori label.is-locked {
  color: #ff3b3b;
}
#viewer-ui .reset-btn {
  background: rgba(0,0,0,0.55) !important;
  border: 1px solid rgba(255,255,255,0.35) !important;
  padding: 8px 12px !important;
  font-size: 12px !important;
  letter-spacing: 0.6px !important;
  text-transform: uppercase !important;
  color: #7CFF00 !important;
  border-radius: 6px !important;
  height: auto !important;
  width: auto !important;
}
#viewer-ui .reset-btn .reset-label {
  color: #ff3b3b;
  font-size: 12px;
  letter-spacing: 0.6px; 
  text-transform: uppercase;
}
    

    
    #step-accessori:not(.hidden) {
      display: flex !important;
      flex-wrap: nowrap;
      gap: 12px;
      justify-content: center;
      text-align: left;
    }
    @media (max-width: 900px) {
      #step-accessori:not(.hidden) { flex-wrap: wrap; gap: 8px 12px; }
    }

    /* Step header alignment */
    #viewer-ui .bottom { position: relative !important; }
    #viewer-ui .bottom { overflow-x: hidden !important; }
    body.step-colori #viewer-ui .bottom {
      overflow: visible !important;
    }
    body.step-accessori #viewer-ui .bottom,
    #viewer.step-accessori #viewer-ui .bottom {
      overflow: visible !important;
    }
    body.step-colori #viewer,
    body.step-colori #viewer-ui,
    body.step-colori #viewer-ui .bottom,
    body.step-colori #step-colori,
    body.step-colori #step-colori .color-row,
    body.step-colori #step-colori .color-group,
    #viewer.step-colori,
    #viewer.step-colori #viewer-ui,
    #viewer.step-colori #viewer-ui .bottom,
    #viewer.step-colori #step-colori,
    #viewer.step-colori #step-colori .color-row,
    #viewer.step-colori #step-colori .color-group {
      overflow: visible !important;
    }
    body.step-accessori #viewer,
    body.step-accessori #viewer-ui,
    body.step-accessori #viewer-ui .bottom,
    body.step-accessori #step-accessori,
    #viewer.step-accessori,
    #viewer.step-accessori #viewer-ui,
    #viewer.step-accessori #viewer-ui .bottom,
    #viewer.step-accessori #step-accessori {
      overflow: visible !important;
    }
    body.step-colori .step-header,
    #viewer.step-colori .step-header {
      z-index: 200 !important;
      pointer-events: auto !important;
    }
    body.step-colori #step-colori,
    #viewer.step-colori #step-colori {
      position: relative !important;
      z-index: auto !important;
    }
    body.step-colori #step-colori .color-choice-dropdown.is-open,
    #viewer.step-colori #step-colori .color-choice-dropdown.is-open {
      z-index: 5000 !important;
    }
    body.step-colori #step-colori .color-choice-dropdown .choice-menu,
    #viewer.step-colori #step-colori .color-choice-dropdown .choice-menu {
      z-index: 5001 !important;
    }
    body.step-colori #step-colori .choice-submenu,
    #viewer.step-colori #step-colori .choice-submenu {
      z-index: 5002 !important;
    }
    body.step-accessori #viewer-ui .back-btn,
    body.step-accessori #viewer-ui .next-btn,
    #viewer.step-accessori #viewer-ui .back-btn,
    #viewer.step-accessori #viewer-ui .next-btn {
      display: inline-flex !important;
      visibility: visible !important;
      opacity: 1 !important;
      pointer-events: auto !important;
      z-index: 600 !important;
    }
    .step-header {
      position: absolute !important;
      top: 8px !important;
      left: 50% !important;
      transform: translateX(-50%) !important;
      width: auto !important;
      justify-content: center !important;
      gap: 10px !important;
    }
    #step-title { text-align: center !important; min-width: 0 !important; width: max-content !important; display: inline-block !important; }
    #step-title-wrap { position: relative !important; display: inline-block !important; }
    #step-title-wrap .info-pill {
      position: absolute !important;
      right: calc(100% + 8px) !important;
      top: 50% !important;
      transform: translateY(-50%) !important;
      margin: 0 !important;
    }
    #step-title-wrap .reset-btn { position: absolute !important; left: calc(100% + 10px) !important; top: calc(50% - 5px) !important; transform: translateY(-50%) !important; }
    .step-header .ghost-btn { display: none !important; }

    #viewer-ui .back-btn,
    #viewer-ui .next-btn {
      position: absolute !important;
      top: calc(50% - 300px) !important;
      width: 86px !important;
      height: 42px !important;
      border-radius: 999px !important;
      font-size: 12px !important;
      text-transform: uppercase !important;
      letter-spacing: 0.5px !important;
      background: rgba(0,0,0,0.45) !important;
    }
    #viewer-ui .back-btn::after,
    #viewer-ui .next-btn::after { display: none !important; content: none !important; }
    #viewer-ui .back-btn {
      left: -480px !important;
      color: #ff3b3b !important;
      border: 2px solid #ff3b3b !important;
      transform: translateY(-50%) !important;
    }
    #viewer-ui .next-btn {
      right: -480px !important;
      color: #7CFF00 !important;
      border: 2px solid #7CFF00 !important;
      transform: translateY(-50%) !important;
    }
    #viewer-ui .nav-label { font-weight: 700; }

    /* Mobile optimization overrides */
    @media (max-width: 900px) {
      #viewer { height: 85vh; }

      #viewer-ui .bottom {
        max-height: calc(38vh - 10px);
        overflow-y: auto;
        overflow-x: visible;
        -webkit-overflow-scrolling: touch;
        padding-bottom: 10px;
      }
      body.step-colori #viewer-ui .bottom {
        max-height: none !important;
        overflow: visible !important;
        -webkit-overflow-scrolling: auto !important;
      }

      .color-row {
        flex-direction: column;
        align-items: stretch;
        gap: 6px;
      }

      .color-group { width: 100%; justify-content: space-between; }

      #group-antiskid {
        justify-content: flex-start !important;
      }
      #group-antiskid .color-label {
        order: 1;
        min-width: 0;
        margin-right: 4px;
      }
      #group-antiskid .info-pill {
        order: 2;
        margin: 0 0 0 4px !important;
      }
      #group-antiskid #antiskid-select {
        order: 3;
        margin-left: auto;
      }

      .color-label { min-width: 70px; }

      #step-finitura select,
      #step-colori select {
        width: 100%;
        min-width: 0;
      }
      #step-colori select {
        display: none !important;
      }
      #step-colori .color-choice-dropdown {
        display: inline-flex !important;
      }
      #step-colori .color-choice-dropdown .choice-btn.trigger {
        min-width: 0;
      }
      #step-colori .color-choice-dropdown .choice-menu {
        top: calc(100% + 6px) !important;
        bottom: auto !important;
        left: auto !important;
        right: 0 !important;
        max-height: min(40vh, 260px);
        z-index: 9000 !important;
        min-width: 0 !important;
        width: min(128px, calc(96vw - 26px)) !important;
        max-width: calc(96vw - 26px) !important;
        box-sizing: border-box !important;
        overflow-x: hidden !important;
        background: #060c12 !important;
      }
      #step-colori .color-choice-dropdown.is-open .choice-menu {
        position: fixed !important;
        left: 50% !important;
        top: 80% !important;
        right: auto !important;
        bottom: auto !important;
        transform: translate(-50%, -50%) !important;
        width: min(320px, calc(100vw - 24px)) !important;
        max-width: calc(100vw - 24px) !important;
        max-height: min(70vh, 520px) !important;
        overflow-y: auto !important;
        overflow-x: hidden !important;
        z-index: 9505 !important;
        border: 1px solid rgba(255,255,255,0.28) !important;
        box-shadow: 0 14px 34px rgba(0,0,0,0.65) !important;
      }
      #step-colori .color-choice-dropdown.is-open {
        z-index: 9504 !important;
      }
      body.step-colori.color-menu-open #step-colori .color-choice-dropdown.is-open,
      #viewer.step-colori.color-menu-open #step-colori .color-choice-dropdown.is-open {
        z-index: 9504 !important;
      }
      #step-colori .choice-submenu {
        display: none;
        z-index: 9002 !important;
        min-width: 0 !important;
        width: 100% !important;
        max-width: 100% !important;
        box-sizing: border-box !important;
        background: #060c12 !important;
      }
      #step-colori .color-swatch-grid {
        display: grid !important;
        min-width: 0 !important;
        width: auto !important;
        grid-template-columns: repeat(8, 28px) !important;
        gap: 2px !important;
        justify-content: start !important;
      }
      #step-colori .color-swatch-option {
        width: 28px !important;
        height: 28px !important;
        min-width: 28px !important;
        min-height: 28px !important;
        max-width: 28px !important;
        max-height: 28px !important;
        box-sizing: border-box !important;
        margin: 0 !important;
        padding: 0 !important;
      }
      #step-colori .color-swatch-option .swatch {
        display: none !important;
      }
      #step-colori .texture-swatch-grid {
        display: grid !important;
        min-width: 0 !important;
        width: auto !important;
        grid-template-columns: repeat(8, 28px) !important;
        gap: 4px !important;
        justify-content: start !important;
      }
      #step-colori .texture-swatch-option {
        width: 28px !important;
        height: 28px !important;
        min-width: 28px !important;
        min-height: 28px !important;
        max-width: 28px !important;
        max-height: 28px !important;
        box-sizing: border-box !important;
        margin: 0 !important;
        padding: 0 !important;
      }
      #step-colori .choice-submenu {
        padding: 6px !important;
      }
      #step-colori .choice-sub.is-open .choice-submenu {
        display: flex !important;
      }

      #step-accessori { grid-template-columns: repeat(2, minmax(0, 1fr)); }

      #step-finitura,
      #step-colori,
      #step-accessori {
        transform: translateY(-5px) !important;
      }

      #viewer-ui h1 { transform: translateY(10%); }
      #price-tag { transform: translateY(10%); }

      .step-header {
        position: sticky !important;
        top: -20px !important;
        left: auto !important;
        transform: none !important;
        width: 100% !important;
        justify-content: space-between !important;
        gap: 8px !important;
        padding: 0 12px !important;
        box-sizing: border-box !important;
        z-index: 7 !important;
      }

      #step-title-wrap {
        flex: 1 1 auto !important;
        text-align: center !important;
        display: flex !important;
        flex-direction: column !important;
        align-items: center !important;
        transform: translateY(-30px) !important;
      }
      #step-title-wrap .info-pill {
        position: static !important;
        order: -1 !important;
        transform: none !important;
        margin: 0 0 8px 0 !important;
        align-self: center !important;
      }

      #step-title-wrap .reset-btn {
        position: static !important;
        transform: none !important;
        margin: 6px 0 0 0 !important;
        display: inline-flex !important;
        background: transparent !important;
        border: none !important;
        padding: 0 !important;
      }

      #step-title-wrap .reset-btn .reset-label {
        color: #ff3b3b !important;
        text-decoration: underline !important;
        font-weight: 700 !important;
      }

      #viewer-ui .back-btn,
      #viewer-ui .next-btn {
        position: absolute !important;
        top: -20px !important;
        left: auto !important;
        right: auto !important;
        pointer-events: auto !important;
        z-index: 10 !important;
        width: 64px !important;
        height: 34px !important;
        font-size: 11px !important;
        letter-spacing: 0.3px !important;
      }
      #viewer-ui .back-btn { left: 12px !important; }
      #viewer-ui .next-btn { right: 12px !important; }

      #info-panel {
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: calc(100vw - 24px);
        max-width: min(420px, calc(100vw - 24px));
        max-height: 62vh;
        overflow: auto;
        box-sizing: border-box;
        z-index: 30;
      }
    }

    @media (max-width: 640px) {
      #viewer { height: 85vh; }
      #step-accessori { grid-template-columns: 1fr; }
      #live-summary {
        top: 96px;
        left: 10px;
        width: min(320px, calc(100vw - 20px));
        font-size: 10px;
      }
    }
</style>
</head>
<body>

<div id="viewer">
  <div id="loading">
    <div id="loading-text">Caricamento modello 0%</div>
    <div id="loading-bar">
      <div id="loading-fill"></div>
    </div>
    <div id="loading-intro-wrap" aria-hidden="true">
      <video id="loading-intro-video" autoplay muted loop playsinline preload="auto">
        <source src="video/intro.mp4" type="video/mp4" />
      </video>
    </div>
  </div>
  <div id="interact-hint" aria-hidden="true" title="Interazione"><span class="dot"></span></div>
  <div id="interact-hints" aria-hidden="true"></div>
  <div id="viewer-ui">
    <div class="top">
      <h1>FISHER 40</h1>
      <div id="price-tag">&euro; 6.000</div>
      <div id="lang-switch" class="lang-switch" aria-label="Language selector"><button id="lang-it" class="lang-btn is-active" type="button">IT</button><button id="lang-en" class="lang-btn" type="button">EN</button></div>
      <div id="currency-switch" class="currency-switch" aria-label="Currency selector"><button id="currency-eur" class="currency-btn is-active" type="button">EUR</button><button id="currency-usd" class="currency-btn" type="button">USD</button></div>
      <button id="audio-toggle" type="button" aria-pressed="false">MUTO</button>
      <button id="order-btn" type="button" class="is-hidden" style="display:none;">Ordina</button>
      <button id="screenshot-btn" type="button" title="Salva screenshot">FOTO</button>
      <button id="rx-btn" type="button" title="Vista semitrasparente">RX</button>
      <div id="live-summary" aria-live="polite" aria-atomic="true"></div>
    </div>
    <div id="controls-overlay" class="controls-overlay">
      Mouse: trascina per ruotare, tasto destro per pan, rotella per zoom.<br>
      Touch mobile: usa 2 dita per pan e zoom.
    </div>
<div class="bottom">
      <div class="step-header">

        <button class="nav-btn back-btn is-hidden" onclick="goBack()" aria-label="Back">
          <span class="sr-only">Back</span>            <span class="nav-label">Back</span>
        </button>
        <div id="step-title-wrap">
          <div id="step-title">Finitura</div><button class="info-pill" type="button" data-info-key="finitura" data-info-dynamic="step" aria-label="Info Finitura">i</button>
          <button class="nav-btn reset-btn is-hidden" onclick="resetAllAccessories()" aria-label="Reset accessori">
            <span class="sr-only">Reset accessori</span>
              <span class="reset-label">RESETTA</span>
          </button>
        </div>
        <button class="nav-btn next-btn is-hidden" onclick="goNext()" aria-label="Go">
          <span class="sr-only">Go</span>            <span class="nav-label">Go</span>
        </button>
        <button class="nav-btn ghost-btn" aria-hidden="true" tabindex="-1"></button>
      </div>
      <div id="step-finitura" class="step">
        <div id="finish-select"></div>
      </div>
      <div id="step-colori" class="step hidden">
        <div class="color-row">
          <div class="color-group" id="group-hull">
            <span class="color-label" data-color-label="hull">CHIGLIA</span>
            <div id="hull-colors"></div>
          </div>
          <div class="color-group" id="group-deck">
            <span class="color-label" data-color-label="deck">PONTE</span>
            <div id="deck-colors"></div>
          </div>
          <div class="color-group" id="group-hatches">
            <span class="color-label" data-color-label="hatches">PORTELLI</span>
            <div id="hatches-colors"></div>
          </div>
          <div class="color-group" id="group-antiskid">
            <button class="info-pill" type="button" data-info-key="antiskid" aria-label="Info Antiscivolo">i</button>
            <span class="color-label" data-color-label="antiskid">ANTISCIVOLO</span>
            <div id="antiskid-select"></div>
          </div>
        </div>
      </div>
            <div id="step-accessori" class="step hidden">
        <label><input type="checkbox" data-accessory="tientibene" onchange="toggleAccessory('tientibene', this.checked)"> Tientibene</label>
        <label><input type="checkbox" data-accessory="panca" onchange="toggleAccessory('panca', this.checked)"> Panca</label>
        <label><input type="checkbox" data-accessory="schienale" onchange="toggleAccessory('schienale', this.checked)"> Schienale</label>
        <label><input type="checkbox" data-accessory="supporto" onchange="toggleAccessory('supporto', this.checked)"> Supporto motore</label>
        <label><input type="checkbox" data-accessory="motore" onchange="toggleAccessory('motore', this.checked)"> Motore</label>
        <label><input type="checkbox" data-accessory="impianto" onchange="toggleAccessory('impianto', this.checked)"> Impianto elettrico</label>
        <label><input type="checkbox" data-accessory="batteria" onchange="toggleAccessory('batteria', this.checked)"> Batteria al Litio</label>
        <label><input type="checkbox" data-accessory="fishfinder" onchange="toggleAccessory('fishfinder', this.checked)"> Ecoscandaglio</label>
        <label><input type="checkbox" data-accessory="trolling" onchange="toggleAccessory('trolling', this.checked)"> Motore di prua</label>
      </div>
    </div>
  </div>
</div>

<div class="home-link"><a href="https://ninga-skiffs.jimdosite.com/" target="_blank" rel="noopener">www.ningaskiffs.com</a></div>
<div id="info-panel" aria-hidden="true" inert>
  <div class="info-panel-head">
    <h3 id="info-title">Informazioni</h3>
    <button id="info-close" type="button">Chiudi</button>
  </div>
  <p id="info-body"></p>
</div>

<div id="order-modal" aria-hidden="true">
  <div class="order-dialog" role="dialog" aria-modal="true" aria-labelledby="order-title">
    <div class="order-header">
      <h3 id="order-title">Configurazione</h3>
      <button class="order-close" type="button">Chiudi</button>
    </div>
    <div class="order-summary">
      <div>
        <div><span class="label" id="order-label-id">ID</span> <span id="order-id"></span></div>
        <div><span class="label" id="order-label-finish">Finitura</span> <span id="order-finish"></span></div>
        <div><span class="label" id="order-label-colors">Colori</span> <span id="order-colors"></span></div>
        <div><span class="label" id="order-label-antiskid">Antiskid</span> <span id="order-antiskid"></span></div>
        <div><span class="label" id="order-label-accessories">Accessori</span> <span id="order-accessories"></span></div>
        <div><span class="label" id="order-label-price">Prezzo</span> <span id="order-price"></span></div>
      </div>
      <div class="order-qr" id="order-qr"></div>
    </div>
    <div class="order-grid">
      <label><span id="order-field-nome">Nome</span><input id="order-nome" type="text"></label>
      <label><span id="order-field-cognome">Cognome</span><input id="order-cognome" type="text"></label>
      <label><span id="order-field-email">Email</span><input id="order-email" type="email"></label>
      <label><span id="order-field-telefono">Telefono</span><input id="order-telefono" type="tel"></label>
      <label><span id="order-field-indirizzo">Indirizzo</span><input id="order-indirizzo" type="text"></label>
      <label><span id="order-field-citta">Citta</span><input id="order-citta" type="text"></label>
      <label><span id="order-field-cap">CAP</span><input id="order-cap" type="text"></label>
      <label><span id="order-field-note">Note</span><textarea id="order-note"></textarea></label>
    </div>
    <div class="order-actions">
      <button id="order-confirm" class="order-confirm" type="button">Conferma Configurazione</button>
      <button id="order-download" type="button">Scarica Configurazione</button>
    </div>
  </div>
</div>

<div id="ui">
</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js"
    }
  }
</script>


<script src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js';
  import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/controls/OrbitControls.js';
  import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/loaders/GLTFLoader.js';
  import { DRACOLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/loaders/DRACOLoader.js';
  import { MeshoptDecoder } from 'https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/libs/meshopt_decoder.module.js';
  import { RGBELoader } from 'https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/loaders/RGBELoader.js';

  const EMAILJS_SERVICE_ID = 'service_pgrsf1t';
  const EMAILJS_TEMPLATE_ID_CLIENT = 'template_pcbac3j';
  const EMAILJS_TEMPLATE_ID_ADMIN = 'template_sq2cwmp';
  // Optional EN client template (if empty, code falls back to IT client template)
  const EMAILJS_TEMPLATE_ID_CLIENT_EN = '';
  const EMAILJS_PUBLIC_KEY = 'Ds3gpi437iatxxEg1';
  const UPLOAD_ENDPOINT = 'https://ninga-upload-api.vercel.app/api/upload';
  let emailJsReady = false;

  import { Sky } from 'https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/objects/Sky.js';
  import { Water } from 'https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/objects/Water.js';

  const scene = new THREE.Scene();
  const SHOW_DEBUG_AXES = false;
  const INTERACT_HINT_OFFSET = new THREE.Vector3(-0.02, 0.11, 0.01);
  const raycaster = new THREE.Raycaster();
  const pointerNdc = new THREE.Vector2();
  let modelRoot = null;
  const animationClock = new THREE.Clock();
  let animationMixer = null;
  const animationActions = new Map();
  const animationClipsByNorm = new Map();
  const interactiveMeshesById = new Map();
  const interactiveAnchorsById = new Map();
  const interactiveState = new Map();
  let pancaAnimatedNode = null;
  let pancaPosition = 'center';
  let interactiveBusy = false;
  const normalizeId = (v) => String(v || '').toLowerCase().replace(/[^a-z0-9]+/g, '');
  const interactiveDefs = [
    { id: 'portello_prua', hitTokens: ['portelloprua'], openClips: ['Portello_prua_open'] },
    { id: 'portello_esa_prua', hitTokens: ['portelloesaprua'], openClips: ['Portello_esa_prua_open'] },
    { id: 'portello_esa_centro', hitTokens: ['portelloesacentro'], openClips: ['Portello_esa_centro_open'] },
    { id: 'portello_esa_poppa', hitTokens: ['portelloesapoppa'], openClips: ['Portello_esa_poppa_open'] },
    { id: 'deck_toggle', hitTokens: [] },
    { id: 'motore', hitTokens: ['fuoribordomotore'], openClips: ['Fuoribordo.motore_alza'], closeClips: ['Fuoribordo.motore_abbassa'], accessoryKey: 'motore' },
    { id: 'panca', hitTokens: ['panca'], openClips: ['panca_center_rear'], closeClips: ['panca_center_front'], accessoryKey: 'panca' },
    { id: 'tientibene_f', hitTokens: ['tientibenef', 'tientibene'], openClips: ['Tientibene_close'], accessoryKey: 'tientibene' }
  ];
  let modelAxesHelper = null;
  if(SHOW_DEBUG_AXES){
    const worldAxesHelper = new THREE.AxesHelper(0.6);
    scene.add(worldAxesHelper);
  }

  const camera = new THREE.PerspectiveCamera(60, 1.6, 0.1, 100);
  camera.position.set(0, 1.5, 5);

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha:true, preserveDrawingBuffer: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.25));
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.15;
  const viewer = document.getElementById('viewer');
  const interactHint = document.getElementById('interact-hint');
  const interactHintsLayer = document.getElementById('interact-hints');
  const liveSummaryEl = document.getElementById('live-summary');
  const hintWorldPos = new THREE.Vector3();
  const hintAdjustedWorldPos = new THREE.Vector3();
  const actionHintEls = new Map();
  const SHOW_NON_PANCA_HINTS = false;
  const ACTION_HINT_WORLD_OFFSETS = {
    portello_prua: { x: -0.055, y: 0, z: 0 },
    portello_esa_prua: { x: 0, y: 0, z: 0.03 },
    portello_esa_centro: { x: 0, y: 0, z: 0.03 },
    portello_esa_poppa: { x: 0, y: 0, z: 0.03 }
  };
  const INFO_CONTENT = {
    finitura: {
      title: 'Finitura',
      body: `Scegli il tipo di finitura dello scafo e delle superfici principali.
Ogni opzione influisce sull’estetica, sulla resistenza nel tempo e sulla facilità di manutenzione. Dal gelcoat classico alle soluzioni più moderne, seleziona lo stile che meglio rappresenta la tua barca.

GELCOAT -> Rivestimento protettivo tipico della nautica, applicato direttamente sullo stampo durante la costruzione dello scafo.
Offre una superficie liscia, resistente ai raggi UV e all’acqua salata, con un aspetto lucido e duraturo nel tempo.

ACRILICO -> Finitura verniciata con prodotti acrilici ad alta resistenza, applicata direttamente alla stampata in fase di postproduzione.
Garantisce colori profondi, elevata brillantezza e una buona protezione dagli agenti atmosferici, ideale per chi cerca una barca pi\u00F9 leggera e non deve lasciarla in acqua a lungo.`
    },
    colori: {
      title: 'Colori',
      body: `Personalizza i colori per rendere unica la tua configurazione.
Puoi combinare tonalit\u00E0 dello scafo, dettagli e finiture per creare un look sportivo, elegante o completamente su misura. Visualizza in tempo reale il risultato direttamente sul modello 3D.

WRAPPING -> Pellicola tecnica adesiva applicata sopra la superficie originale.
Permette di cambiare colore o stile senza interventi permanenti, con ampia scelta di texture e possibilit\u00E0 di rimozione futura.

RUGGED -> Finitura acrilica resistente ai graffi con effetto bucciato, per una barca pratica e resistente.`
    },
    antiskid: {
      title: 'Antiscivolo',
      body: `Trattamento superficiale progettato per aumentare l\u2019aderenza nelle zone calpestabili.  Riduce il rischio di scivolamento anche con superfici bagnate, migliorando sicurezza e comfort a bordo. Disponibile nelle varianti:

EVA -> Rivestimento in schiuma tecnica EVA, morbido al tatto e ad alta aderenza.
Garantisce comfort sotto i piedi, isolamento termico e un look moderno, con ottima resistenza ad acqua e raggi UV.

VERNICIATO -> Superficie trattata con vernice antiscivolo contenente microgranuli.
Mantiene un aspetto uniforme con lo scafo e offre buona resistenza e facilit\u00E0 di pulizia, ideale per uno stile pi\u00F9 tradizionale.

STAMPATO -> Texture antiscivolo integrata direttamente nello stampo durante la produzione.
Soluzione resistente e duratura, senza applicazioni aggiuntive, pensata per garantire grip costante nel tempo.`
    },
    accessori: {
      title: 'Accessori',
      body: `In questa sezione puoi aggiungere optional tecnici ed estetici pensati per migliorare comfort, funzionalità e stile a bordo.
Ogni scelta viene aggiornata in tempo reale e resa interattiva nella visualizzazione 3D per mostrarti subito il risultato finale della configurazione. Cliccando su RX rendi trasparente il ponte così da osservare la struttura interna della barca. Il viola rappresenta il volume schiumato per rendere innaffondabile il mezzo.`
    }
  };
  const INFO_CONTENT_EN = {
    finitura: {
      title: 'Finish',
      body: `Choose the finish type for the hull and main surfaces.
Each option affects aesthetics, long-term resistance, and ease of maintenance. From classic gelcoat to more modern solutions, select the style that best represents your boat.

GELCOAT -> A protective coating commonly used in boating, applied directly to the mold during hull production.
It provides a smooth surface, UV and saltwater resistance, and a glossy look that lasts over time.

ACRYLIC -> A high-resistance acrylic paint finish, applied directly to the molded part during post-production.
It ensures deep colors, high gloss, and good weather protection, ideal for those looking for a lighter boat that is not left in the water for long periods.`
    },
    colori: {
      title: 'Colors',
      body: `Customize colors to make your configuration unique.
You can combine hull tones, details, and finishes to create a sporty, elegant, or fully custom look. View the result in real time directly on the 3D model.

WRAPPING -> Technical adhesive film applied over the original surface.
It allows you to change color or style without permanent work, with a wide range of textures and the possibility of future removal.

RUGGED -> Scratch-resistant acrylic finish with a textured effect, for a practical and durable boat.`
    },
    antiskid: {
      title: 'Antiskid',
      body: `Surface treatment designed to increase grip in walkable areas. It reduces slipping risk even on wet surfaces, improving onboard safety and comfort. Available variants:

EVA -> Technical EVA foam covering, soft to the touch and highly grippy.
It provides underfoot comfort, thermal insulation, and a modern look, with excellent resistance to water and UV rays.

PAINTED -> Surface treated with antiskid paint containing micro-granules.
It keeps a uniform look with the hull and offers good resistance and easy cleaning, ideal for a more traditional style.

PRINTED -> Antiskid texture integrated directly into the mold during production.
A durable, long-lasting solution without additional applications, designed to ensure consistent grip over time.`
    },
    accessori: {
      title: 'Accessories',
      body: `In this section you can add technical and aesthetic options designed to improve comfort, functionality, and onboard style.
Each choice is updated in real time and made interactive in the 3D view so you can immediately see the final configuration result. By clicking RX, you make the deck transparent so you can observe the boat's internal structure. Purple highlights the foamed volume used to make the boat unsinkable.`
    }
  };
  function getInfoContentForLang(key){
    const k = String(key || '').toLowerCase();
    if(currentLang === 'en' && INFO_CONTENT_EN[k]) return INFO_CONTENT_EN[k];
    return INFO_CONTENT[k] || null;
  }
    let deckTransparent = false;
  let deckRxSavedAntiskid = 'none';
  let pancaArrowFrontEl = null;
  let pancaArrowRearEl = null;
  let pancaChoiceVisible = false;
  let pancaChoiceLeftTarget = null;
  let pancaChoiceRightTarget = null;
  renderer.setSize(viewer.clientWidth, viewer.clientHeight);
  viewer.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  window.camera = camera;
  window.controls = controls;
  window.camera = camera;
  window.controls = controls;
  controls.enablePan = true;
  controls.enableDamping = true;
  controls.autoRotate = false;
  controls.enableZoom = true;
  renderer.domElement.style.touchAction = 'none';
  controls.touches.ONE = THREE.TOUCH.ROTATE;
  controls.touches.TWO = THREE.TOUCH.DOLLY_PAN;
  const mobileUiQuery = window.matchMedia('(max-width: 900px)');
  const MOBILE_FRAMING_DIST_MUL = 2.0;
  const DESKTOP_FRAMING_DIST_MUL = 0.9;
  const MOBILE_MIN_DIST_MUL = 0.6;
  const MOBILE_MAX_DIST_MUL = 2.8;
  const DESKTOP_MIN_DIST_MUL = 0.4;
  const DESKTOP_MAX_DIST_MUL = 1.4;
  let framedMaxDim = 0;
  let framedCameraZ = 0;
  let lastMobileViewport = null;
  let controlsHintHidden = false;
  const controlsOverlay = document.getElementById('controls-overlay');
  function updateControlsOverlayText(){
    if(!controlsOverlay) return;
    controlsOverlay.style.display = 'none';
  }
  function applyInteractionScheme(){
    const isMobile = mobileUiQuery.matches;
    if(isMobile){
      controls.enableZoom = true;
      controls.touches.ONE = THREE.TOUCH.ROTATE;
      controls.touches.TWO = THREE.TOUCH.DOLLY_PAN;
    }else{
      controls.enableZoom = true;
      controls.touches.ONE = THREE.TOUCH.ROTATE;
      controls.touches.TWO = THREE.TOUCH.DOLLY_PAN;
    }
    updateControlsOverlayText();
  }
  function applyFramingForViewport(force = false){
    const isMobile = mobileUiQuery.matches;
    if(!force && isMobile === lastMobileViewport) return;
    lastMobileViewport = isMobile;
    if(!framedMaxDim || !framedCameraZ) return;
    camera.fov = isMobile ? 66 : 60;
    camera.updateProjectionMatrix();
    const distMul = isMobile ? MOBILE_FRAMING_DIST_MUL : DESKTOP_FRAMING_DIST_MUL;
    camera.position.set(0.2, framedMaxDim * 0.2, framedCameraZ * distMul);
    controls.minDistance = framedCameraZ * (isMobile ? MOBILE_MIN_DIST_MUL : DESKTOP_MIN_DIST_MUL);
    controls.maxDistance = framedCameraZ * (isMobile ? MOBILE_MAX_DIST_MUL : DESKTOP_MAX_DIST_MUL);
    controls.target.set(0, 0, 0);
    controls.update();
  }
  function hideControlsOverlay(){
    if(controlsHintHidden) return;
    controlsHintHidden = true;
    if(controlsOverlay) controlsOverlay.classList.add('is-hidden');
  }
  controls.addEventListener('start', hideControlsOverlay);

  function resetAnimationSystem(clips){
    animationMixer = modelRoot ? new THREE.AnimationMixer(modelRoot) : null;
    animationActions.clear();
    animationClipsByNorm.clear();
    (clips || []).forEach((clip) => {
      const key = normalizeId(clip?.name);
      if(key) animationClipsByNorm.set(key, clip);
    });
  }
  function findClipByAliases(aliases){
    const list = Array.isArray(aliases) ? aliases : [aliases];
    for(const raw of list){
      const key = normalizeId(raw);
      if(!key) continue;
      if(animationClipsByNorm.has(key)) return animationClipsByNorm.get(key);
      for(const [k, clip] of animationClipsByNorm.entries()){
        if(k.includes(key) || key.includes(k)) return clip;
      }
    }
    return null;
  }
  function findClipExact(name){
    const key = normalizeId(name);
    if(!key) return null;
    return animationClipsByNorm.get(key) || null;
  }
  function findFirstAvailableClip(aliases){
    const list = Array.isArray(aliases) ? aliases : [aliases];
    for(const alias of list){
      const clip = findClipByAliases(alias);
      if(clip) return clip;
    }
    return null;
  }
  function getClipAction(clip){
    if(!animationMixer || !clip) return null;
    const key = clip.name || clip.uuid;
    if(animationActions.has(key)) return animationActions.get(key);
    const action = animationMixer.clipAction(clip);
    action.clampWhenFinished = true;
    action.enabled = true;
    action.setLoop(THREE.LoopOnce, 1);
    animationActions.set(key, action);
    return action;
  }
  function playClipOnce(clip, reverse = false){
    if(!animationMixer || !clip) return Promise.resolve(false);
    const action = getClipAction(clip);
    if(!action) return Promise.resolve(false);
    action.reset();
    action.paused = false;
    action.enabled = true;
    action.setLoop(THREE.LoopOnce, 1);
    action.clampWhenFinished = true;
    if(reverse){
      action.timeScale = -1;
      action.time = Math.max(0.001, clip.duration || 0.001);
    }else{
      action.timeScale = 1;
      action.time = 0;
    }
    action.play();
    return new Promise((resolve) => {
      const onFinished = (e) => {
        if(e.action !== action) return;
        animationMixer.removeEventListener('finished', onFinished);
        resolve(true);
      };
      animationMixer.addEventListener('finished', onFinished);
    });
  }
  function stopDefActions(def, exceptClip = null){
    const clips = []
      .concat(def?.openClips || [])
      .concat(def?.closeClips || [])
      .map((alias) => findClipByAliases(alias))
      .filter(Boolean);
    clips.forEach((clip) => {
      if(exceptClip && clip === exceptClip) return;
      const action = getClipAction(clip);
      if(!action) return;
      action.stop();
      action.reset();
      action.enabled = false;
    });
  }
  function addInteractiveMesh(id, mesh){
    if(!mesh || !id) return;
    const list = interactiveMeshesById.get(id) || [];
    if(!list.includes(mesh)) list.push(mesh);
    mesh.userData.interactiveId = id;
    interactiveMeshesById.set(id, list);
  }
  function addInteractiveAnchor(id, obj){
    if(!obj || !id) return;
    const list = interactiveAnchorsById.get(id) || [];
    if(!list.includes(obj)) list.push(obj);
    interactiveAnchorsById.set(id, list);
  }
  function getInteractiveDef(id){
    return interactiveDefs.find((d) => d.id === id);
  }
  function getEsaPairForPanca(){
    if(pancaPosition === 'rear') return ['portello_esa_centro', 'portello_esa_prua'];
    if(pancaPosition === 'front') return ['portello_esa_poppa', 'portello_esa_centro'];
    if(pancaPosition === 'center') return ['portello_esa_poppa', 'portello_esa_prua'];
    return ['portello_esa_poppa', 'portello_esa_prua'];
  }
  function movePancaTo(target){
    if(target === pancaPosition) return Promise.resolve(false);
    const centerRearClip = findClipExact('panca_center_rear') || findFirstAvailableClip(['panca_center_rear', 'Panca_move_rear']);
    const centerFrontClip = findClipExact('panca_center_front') || findFirstAvailableClip(['panca_center_front', 'Panca_move_front']);
    const rearFrontClip = findClipExact('panca_rear_front') || findFirstAvailableClip(['panca_rear_front', 'Panca_rear_front']);
    const resetPancaActions = (exceptClip = null) => {
      [centerRearClip, centerFrontClip, rearFrontClip].forEach((clip) => {
        if(!clip || clip === exceptClip) return;
        const action = getClipAction(clip);
        if(!action) return;
        action.stop();
        action.reset();
        action.enabled = false;
      });
    };
    const playCenterRear = (rev = false) => {
      if(!centerRearClip) return Promise.resolve(false);
      resetPancaActions(centerRearClip);
      return playClipOnce(centerRearClip, rev);
    };
    const playCenterFront = (rev = false) => {
      if(!centerFrontClip) return Promise.resolve(false);
      resetPancaActions(centerFrontClip);
      return playClipOnce(centerFrontClip, rev);
    };
    const playRearFront = (rev = false) => {
      if(!rearFrontClip) return Promise.resolve(false);
      resetPancaActions(rearFrontClip);
      return playClipOnce(rearFrontClip, rev);
    };
    if(pancaPosition === 'center'){
      if(target === 'rear') return playCenterRear(false).then((ok) => { if(ok) pancaPosition = 'rear'; return ok; });
      if(target === 'front') return playCenterFront(false).then((ok) => { if(ok) pancaPosition = 'front'; return ok; });
    }
    if(pancaPosition === 'rear'){
      if(target === 'center') return playCenterRear(true).then((ok) => { if(ok) pancaPosition = 'center'; return ok; });
      if(target === 'front') return playRearFront(false).then((ok) => { if(ok) pancaPosition = 'front'; return ok; });
    }
    if(pancaPosition === 'front'){
      if(target === 'center') return playCenterFront(true).then((ok) => { if(ok) pancaPosition = 'center'; return ok; });
      if(target === 'rear') return playRearFront(true).then((ok) => { if(ok) pancaPosition = 'rear'; return ok; });
    }
    return Promise.resolve(false);
  }
  function closeAllEsaOpen(){
    const esaIds = ['portello_esa_prua', 'portello_esa_centro', 'portello_esa_poppa'];
    const jobs = [];
    esaIds.forEach((esaId) => {
      const isOpen = Boolean(interactiveState.get(esaId));
      if(!isOpen) return;
      const def = getInteractiveDef(esaId);
      if(!def) return;
      const openClip = findFirstAvailableClip(def.openClips || []);
      if(!openClip) return;
      stopDefActions(def, openClip);
      jobs.push(
        playClipOnce(openClip, true).then((ok) => {
          if(ok) interactiveState.set(esaId, false);
          return ok;
        })
      );
    });
    if(!jobs.length) return Promise.resolve(false);
    return Promise.all(jobs).then((arr) => arr.some(Boolean));
  }

  function isPancaAccessoryEnabled(){
    return Boolean(document.querySelector('#step-accessori input[data-accessory="panca"]')?.checked);
  }
  function canExecuteInteractive(id, shouldOpen){
    if(!shouldOpen) return { ok: true };
    if(id.startsWith('portello_esa_') && !isPancaAccessoryEnabled()) return { ok: true };
    if(id === 'motore' && pancaPosition === 'rear') return { ok: false };
    if(id === 'portello_esa_poppa' && (pancaPosition === 'rear' || Boolean(interactiveState.get('tientibene_f')))) return { ok: false };
    if(id === 'portello_esa_centro' && (pancaPosition === 'center' || Boolean(interactiveState.get('tientibene_f')))) return { ok: false };
    if(id === 'portello_esa_prua' && pancaPosition === 'front') return { ok: false };
    return { ok: true };
  }
  function ensureMotoreLowered(){
    const isEnabled = Boolean(document.querySelector('#step-accessori input[data-accessory="motore"]')?.checked);
    if(!isEnabled) return Promise.resolve(false);
    if(!Boolean(interactiveState.get('motore'))) return Promise.resolve(false);
    return toggleInteractiveById('motore');
  }
  function ensureTientibeneState(lowered){
    const isEnabled = Boolean(document.querySelector('#step-accessori input[data-accessory="tientibene"]')?.checked);
    if(!isEnabled) return Promise.resolve(false);
    const current = Boolean(interactiveState.get('tientibene_f'));
    if(current == Boolean(lowered)) return Promise.resolve(false);
    return toggleInteractiveById('tientibene_f');
  }

  function toggleInteractiveById(id){
    const def = getInteractiveDef(id);
    if(!def) return Promise.resolve(false);
    if(id === 'deck_toggle'){
      setDeckTransparency(!deckTransparent);
      return Promise.resolve(true);
    }
    const isOpen = Boolean(interactiveState.get(id));
    const shouldOpen = !isOpen;
    const gate = canExecuteInteractive(id, shouldOpen);
    if(!gate.ok) return Promise.resolve(false);
    const openClip = findFirstAvailableClip(def.openClips || []);
    const closeClip = findFirstAvailableClip(def.closeClips || []);
    if(!openClip && !closeClip) return Promise.resolve(false);
    const targetClip = shouldOpen ? openClip : (closeClip || openClip);
    stopDefActions(def, targetClip || null);
    const op = shouldOpen
      ? (openClip ? playClipOnce(openClip, false) : Promise.resolve(false))
      : (closeClip ? playClipOnce(closeClip, false) : playClipOnce(openClip, true));
    return op.then((ok) => {
      if(ok) interactiveState.set(id, shouldOpen);
      return ok;
    });
  }
  function triggerInteractiveAction(id){
    const def = interactiveDefs.find((d) => d.id === id);
    if(!def || interactiveBusy) return false;
    if(currentStep !== 'accessori') return false;
    if(id === 'panca'){
      const isEnabled = Boolean(document.querySelector('#step-accessori input[data-accessory="panca"]')?.checked);
      if(!isEnabled) return false;
      pancaChoiceVisible = true;
      return true;
    }
    if(id === 'tientibene_f'){
      const isEnabled = Boolean(document.querySelector('#step-accessori input[data-accessory="tientibene"]')?.checked);
      if(!isEnabled) return false;
      const isLowered = Boolean(interactiveState.get('tientibene_f'));
      const wantLowered = !isLowered;
      if(!wantLowered && pancaPosition === 'center') return false;
      interactiveBusy = true;
      const run = wantLowered
        ? closeAllEsaOpen()
          .then(() => (pancaPosition === 'center' ? movePancaTo('rear') : Promise.resolve(false)))
          .then(() => toggleInteractiveById('tientibene_f'))
        : toggleInteractiveById('tientibene_f');
      run.finally(() => {
        interactiveBusy = false;
      });
      return true;
    }
    interactiveBusy = true;
    toggleInteractiveById(id)
      .finally(() => {
        interactiveBusy = false;
      });
    return true;
  }
  function ensureActionHintElements(){
    if(!interactHintsLayer) return;
    interactiveDefs.forEach((def) => {
      if(def.id === 'panca') return;
      if(def.id === 'tientibene_f') return;
      if(def.id === 'deck_toggle') return;
      if(actionHintEls.has(def.id)) return;
      const el = document.createElement('button');
      el.type = 'button';
      el.className = 'interact-action-dot';
      el.title = def.id;
      el.setAttribute('aria-label', def.id);
      el.style.display = 'none';
      el.addEventListener('pointerdown', (e) => {
        e.stopPropagation();
      });
      el.addEventListener('pointerup', (e) => {
        e.stopPropagation();
        triggerInteractiveAction(def.id);
      });
      interactHintsLayer.appendChild(el);
      actionHintEls.set(def.id, el);
    });
  }
  function ensurePancaArrowElements(){
    if(!interactHintsLayer) return;
    if(!pancaArrowRearEl){
      pancaArrowRearEl = document.createElement('button');
      pancaArrowRearEl.type = 'button';
      pancaArrowRearEl.className = 'panca-arrow-btn';
      pancaArrowRearEl.textContent = 'centro';
      pancaArrowRearEl.title = 'Panca centro';
      pancaArrowRearEl.setAttribute('aria-label', 'Panca centro');
      pancaArrowRearEl.style.display = 'none';
      pancaArrowRearEl.addEventListener('pointerdown', (e) => e.stopPropagation());
      pancaArrowRearEl.addEventListener('pointerup', (e) => {
        e.stopPropagation();
        if(pancaChoiceLeftTarget) triggerPancaDirection(pancaChoiceLeftTarget);
      });
      interactHintsLayer.appendChild(pancaArrowRearEl);
    }
    if(!pancaArrowFrontEl){
      pancaArrowFrontEl = document.createElement('button');
      pancaArrowFrontEl.type = 'button';
      pancaArrowFrontEl.className = 'panca-arrow-btn';
      pancaArrowFrontEl.textContent = 'avanti';
      pancaArrowFrontEl.title = 'Panca avanti';
      pancaArrowFrontEl.setAttribute('aria-label', 'Panca avanti');
      pancaArrowFrontEl.style.display = 'none';
      pancaArrowFrontEl.addEventListener('pointerdown', (e) => e.stopPropagation());
      pancaArrowFrontEl.addEventListener('pointerup', (e) => {
        e.stopPropagation();
        if(pancaChoiceRightTarget) triggerPancaDirection(pancaChoiceRightTarget);
      });
      interactHintsLayer.appendChild(pancaArrowFrontEl);
    }
  }
  function getPancaChoiceLabel(target){
    if(target === 'rear') return 'indietro';
    if(target === 'center') return 'centro';
    if(target === 'front') return 'avanti';
    return '';
  }
  function triggerPancaDirection(target){
    if(interactiveBusy) return false;
    if(currentStep !== 'accessori') return false;
    const run = (job, closeEsaFirst = false) => {
      interactiveBusy = true;
      pancaChoiceVisible = false;
      const start = closeEsaFirst ? closeAllEsaOpen() : Promise.resolve(false);
      start.then(() => job())
        .finally(() => { interactiveBusy = false; });
      return true;
    };

    if(target === 'rear'){
      if(pancaPosition === 'center'){
        return run(() => ensureMotoreLowered().then(() => movePancaTo('rear')), true);
      }
      if(pancaPosition === 'front'){
        return run(() => ensureMotoreLowered()
          .then(() => ensureTientibeneState(true))
          .then(() => movePancaTo('rear')), true);
      }
      return false;
    }

    if(target === 'front'){
      if(pancaPosition === 'rear'){
        return run(() => ensureTientibeneState(true).then(() => movePancaTo('front')), true);
      }
      if(pancaPosition === 'center'){
        return run(() => movePancaTo('rear')
          .then(() => ensureTientibeneState(true))
          .then(() => movePancaTo('front')), true);
      }
      return false;
    }

    if(target === 'center'){
      if(pancaPosition === 'rear'){
        const tientibeneLowered = Boolean(interactiveState.get('tientibene_f'));
        const tientibeneRaised = !tientibeneLowered;
        return run(() => movePancaTo('center'), tientibeneRaised);
      }
      if(pancaPosition === 'front'){
        return run(() => ensureTientibeneState(true).then(() => movePancaTo('center')), true);
      }
      return false;
    }

    return false;
  }
  function updatePancaArrows(){
    ensurePancaArrowElements();
    if(!pancaArrowFrontEl || !pancaArrowRearEl || !interactHintsLayer) return;
    pancaArrowFrontEl.style.display = 'none';
    pancaArrowRearEl.style.display = 'none';
    if(currentStep !== 'accessori') return;
    const pancaEnabled = Boolean(document.querySelector('#step-accessori input[data-accessory="panca"]')?.checked);
    if(!pancaEnabled) return;
    if(!pancaChoiceVisible) return;
    if(pancaPosition === 'center'){
      pancaChoiceLeftTarget = 'rear';
      pancaChoiceRightTarget = 'front';
    }else if(pancaPosition === 'rear'){
      pancaChoiceLeftTarget = 'center';
      pancaChoiceRightTarget = 'front';
    }else if(pancaPosition === 'front'){
      pancaChoiceLeftTarget = 'rear';
      pancaChoiceRightTarget = 'center';
    }else{
      return;
    }
    const leftLabel = getPancaChoiceLabel(pancaChoiceLeftTarget);
    const rightLabel = getPancaChoiceLabel(pancaChoiceRightTarget);
    pancaArrowRearEl.textContent = leftLabel;
    pancaArrowRearEl.title = `Panca ${leftLabel}`;
    pancaArrowRearEl.setAttribute('aria-label', `Panca ${leftLabel}`);
    pancaArrowFrontEl.textContent = rightLabel;
    pancaArrowFrontEl.title = `Panca ${rightLabel}`;
    pancaArrowFrontEl.setAttribute('aria-label', `Panca ${rightLabel}`);
    if(!getInteractiveAnchorCenter('panca', hintWorldPos)) return;
    hintAdjustedWorldPos.copy(hintWorldPos);
    hintAdjustedWorldPos.project(camera);
    if(hintAdjustedWorldPos.z < -1 || hintAdjustedWorldPos.z > 1) return;
    const x = (hintAdjustedWorldPos.x * 0.5 + 0.5) * viewer.clientWidth;
    const y = (-hintAdjustedWorldPos.y * 0.5 + 0.5) * viewer.clientHeight;
    pancaArrowRearEl.style.left = `${x - 38}px`;
    pancaArrowRearEl.style.top = `${y + 18}px`;
    pancaArrowFrontEl.style.left = `${x + 38}px`;
    pancaArrowFrontEl.style.top = `${y + 18}px`;
    pancaArrowRearEl.style.display = 'block';
    pancaArrowFrontEl.style.display = 'block';
  }
  function getInteractiveAnchorCenter(id, out){
    if(id === 'panca' && pancaAnimatedNode){
      const boxP = new THREE.Box3().setFromObject(pancaAnimatedNode);
      if(!boxP.isEmpty()){
        boxP.getCenter(out);
        return true;
      }
    }
    const anchors = (interactiveAnchorsById.get(id) || []).filter(Boolean);
    if(anchors.length){
      const box = new THREE.Box3();
      anchors.forEach((obj) => box.expandByObject(obj));
      if(!box.isEmpty()){
        box.getCenter(out);
        return true;
      }
    }
    const meshes = (interactiveMeshesById.get(id) || []).filter((m) => m?.visible);
    if(!meshes.length) return false;
    const box = new THREE.Box3();
    meshes.forEach((mesh) => box.expandByObject(mesh));
    if(box.isEmpty()) return false;
    box.getCenter(out);
    return true;
  }
  function updateActionHints(){
    ensureActionHintElements();
    if(!interactHintsLayer) return;
    if(currentStep !== 'accessori'){
      actionHintEls.forEach((el) => { el.style.display = 'none'; });
      return;
    }
    if(!SHOW_NON_PANCA_HINTS){
      actionHintEls.forEach((el) => { el.style.display = 'none'; });
      return;
    }
    actionHintEls.forEach((el, id) => {
      const def = interactiveDefs.find((d) => d.id === id);
      if(def?.accessoryKey){
        const enabled = Boolean(document.querySelector(`#step-accessori input[data-accessory="${def.accessoryKey}"]`)?.checked);
        if(!enabled){
          el.style.display = 'none';
          return;
        }
      }
      const isOpen = Boolean(interactiveState.get(id));
      const gate = canExecuteInteractive(id, !isOpen);
      el.classList.toggle('is-disabled', !gate.ok);
      const hasClip = Boolean(findFirstAvailableClip(def?.openClips || []) || findFirstAvailableClip(def?.closeClips || []));
      if(!hasClip){
        el.style.display = 'none';
        return;
      }
      if(!getInteractiveAnchorCenter(id, hintWorldPos)){
        el.style.display = 'none';
        return;
      }
      hintAdjustedWorldPos.copy(hintWorldPos);
      const off = ACTION_HINT_WORLD_OFFSETS[id];
      if(off){
        hintAdjustedWorldPos.x += off.x || 0;
        hintAdjustedWorldPos.y += off.y || 0;
        hintAdjustedWorldPos.z += off.z || 0;
      }
      hintAdjustedWorldPos.project(camera);
      if(hintAdjustedWorldPos.z < -1 || hintAdjustedWorldPos.z > 1){
        el.style.display = 'none';
        return;
      }
      const x = (hintAdjustedWorldPos.x * 0.5 + 0.5) * viewer.clientWidth;
      const y = (-hintAdjustedWorldPos.y * 0.5 + 0.5) * viewer.clientHeight;
      el.style.left = `${x}px`;
      el.style.top = `${y}px`;
      el.style.display = 'block';
    });
  }
  function tryToggleInteractiveActionFromPointer(event){
    if(currentStep !== 'accessori') return false;
    if(interactiveBusy) return false;
    const rect = renderer.domElement.getBoundingClientRect();
    if(!rect.width || !rect.height) return false;
    pointerNdc.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    pointerNdc.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    const candidates = [];
    interactiveMeshesById.forEach((meshes) => meshes.forEach((m) => m && candidates.push(m)));
    if(!candidates.length) return false;
    raycaster.setFromCamera(pointerNdc, camera);
    const hits = raycaster.intersectObjects(candidates, false);
    if(!hits.length) return false;
    const id = hits[0]?.object?.userData?.interactiveId;
    if(!id) return false;
    return triggerInteractiveAction(id);
  }

  const ambient = new THREE.AmbientLight(0xffffff, 0.25);
  scene.add(ambient);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
  dirLight.position.set(4, 6, 3);
  scene.add(dirLight);


  const sky = new Sky();
  sky.scale.setScalar(10000);
  scene.add(sky);
  sky.visible = false;

  const skyUniforms = sky.material.uniforms;
  skyUniforms['turbidity'].value = 1.6;
  skyUniforms['rayleigh'].value = 3.5;
  skyUniforms['mieCoefficient'].value = 0.0025;
  skyUniforms['mieDirectionalG'].value = 0.85;

  const sun = new THREE.Vector3();
  const phi = THREE.MathUtils.degToRad(35);
  const theta = THREE.MathUtils.degToRad(180);
  sun.setFromSphericalCoords(1, phi, theta);
  sky.material.uniforms['sunPosition'].value.copy(sun);

  const pmremGenerator = new THREE.PMREMGenerator(renderer);
  let environmentLoaded = false;
  let environmentLoadingPromise = null;
  let water;
  const WATER_LEVEL_OFFSET = -0.008;
  let waterTargetY = -0.43;

  function loadEnvironment(){
    if(environmentLoadingPromise) return environmentLoadingPromise;
    environmentLoaded = true;

    environmentLoadingPromise = new Promise((resolve) => {
      new RGBELoader()
        .setPath('hdr/')
        .load('puresky.hdr', (hdrTexture) => {
          const envMap = pmremGenerator.fromEquirectangular(hdrTexture).texture;
          scene.background = envMap;
          scene.environment = envMap;
          hdrTexture.dispose();
          pmremGenerator.dispose();
          resolve(true);
        }, undefined, () => {
          resolve(false);
        });
    });

    const waterGeometry = new THREE.PlaneGeometry(10000, 10000);
    water = new Water(
      waterGeometry,
      {
        clipBias: 0.003,
        textureWidth: 512,
        textureHeight: 512,
        waterNormals: new THREE.TextureLoader().load(
          'https://threejs.org/examples/textures/waternormals.jpg',
          (texture) => {
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
          }
        ),
        sunDirection: new THREE.Vector3(),
        sunColor: 0xffffff,
        waterColor: 0x0f7a4a,
        alpha: 0.65,
        distortionScale: 0.02,
        fog: scene.fog !== undefined
      }
    );
    water.material.transparent = true;
    water.rotation.x = -Math.PI / 2;
    water.position.y = waterTargetY;
    scene.add(water);
    water.renderOrder = 4;
    configureWaterMaskMeshes();

    return environmentLoadingPromise;
  }

  function configureWaterMaskMeshes(){
    waterMaskMeshes.forEach((mesh) => {
      if(!mesh || !mesh.isMesh) return;
      const base = Array.isArray(mesh.material) ? mesh.material[0] : mesh.material;
      if(!base) return;
      const maskMat = base.clone ? base.clone() : base;
      maskMat.colorWrite = false;
      maskMat.depthWrite = true;
      maskMat.depthTest = true;
      maskMat.transparent = false;
      maskMat.opacity = 1;
      maskMat.side = THREE.DoubleSide;
      maskMat.needsUpdate = true;
      mesh.material = maskMat;
      mesh.visible = true;
      mesh.renderOrder = 3;
    });
  }

  let hullMat, deckMat, hatchesMat;
  let bottazzoMat, scrittaMat;
  const scrittaMats = [];
  let chirpTexture = null;
  const accessories = {};
  const antiskidEvaMeshes = [];
  const schienaleMeshes = [];
  const chirpMeshes = [];
  const trollingMeshes = [];
  const trollingDeployMeshes = [];
  const waterMaskMeshes = [];
  let trollingDeployed = false;
  const accessoryMeshMap = {
    schienale: ['mesh_0_2'],
    antiskid_eva: ['mesh_0_1'],
    fishfinder: ['mesh_0']
  };
  const accessoryMeshNames = new Set(Object.values(accessoryMeshMap).flat());
  const sounds = {
    bg: new Audio('audio/gabbiani.mp3'),
    on: new Audio('audio/click.mp3'),
    off: new Audio('audio/blip.mp3')
  };
  sounds.bg.loop = true;
  sounds.bg.volume = 0.18;
  sounds.on.volume = 0.8;
  sounds.off.volume = 0.8;
  let audioUnlocked = false;
  let audioEnabled = true;

  function unlockAudio(){
    if(!audioEnabled) return;
    if(audioUnlocked) return;
    audioUnlocked = true;
    sounds.bg.play().catch(() => {});
  }

  function setAudioEnabled(enabled, fromUser = false){
    audioEnabled = enabled;
    sounds.bg.muted = !enabled;
    sounds.on.muted = !enabled;
    sounds.off.muted = !enabled;
    const btn = document.getElementById('audio-toggle');
    if(btn){
      btn.classList.toggle('is-muted', !enabled);
      const dict = I18N[currentLang] || I18N.it;
      btn.textContent = enabled ? dict.muteOn : dict.muteOff;
      btn.setAttribute('aria-pressed', String(!enabled));
    }
    if(!enabled){
      sounds.bg.pause();
      return;
    }
    if(fromUser){
      audioUnlocked = true;
      sounds.bg.play().catch(() => {});
    }else{
      unlockAudio();
    }
  }

  document.addEventListener('pointerdown', unlockAudio, { once: true });
  document.addEventListener('keydown', unlockAudio, { once: true });
  document.addEventListener('pointerdown', hideControlsOverlay, { once: true });
  document.addEventListener('keydown', hideControlsOverlay, { once: true });
  const accessoryKeys = [
    'tientibene',
    'panca',
    'schienale',
    'motore',
    'supporto',
    'trolling',
    'fishfinder',
    'impianto',
    'batteria'
  ];
  const accessoryGroups = {
    panca: [],
    tientibene: [],
    schienale: [],
    motore: [],
    supporto: [],
    trolling: [],
    fishfinder: [],
    impianto: [],
    batteria: []
  };
  function getAccessoryKey(objName, matName){
    const name = (objName || '').toLowerCase();
    const mat = (matName || '').toLowerCase();
    if(name.includes('tientibene')) return 'tientibene';
    if(name.includes('panca')) return 'panca';
    if(name.includes('schienale')) return 'schienale';
    if(name.includes('supporto')) return 'supporto';
    if(name.includes('trolling')) return 'trolling';
    if(name.includes('fuoribordo')) return 'motore';
    if(name.includes('motore')) return 'motore';
    if(name.includes('fishfinder')) return 'fishfinder';
    if(name.includes('impianto')) return 'impianto';
    if(name.includes('batteria')) return 'batteria';
    if(mat.includes('trolling')) return 'trolling';
    if(mat.includes('fuoribordo')) return 'motore';
    return '';
  }

  const TEXTURE_TILING_MULTIPLIER = 1;
  const TEXTURE_STRETCH_U = 1;
  const TEXTURE_STRETCH_V = 1;
  function tileU(v){ return v * TEXTURE_TILING_MULTIPLIER * TEXTURE_STRETCH_U; }
  function tileV(v){ return v * TEXTURE_TILING_MULTIPLIER * TEXTURE_STRETCH_V; }
  function addScrittaMaterial(mat){
    if(!mat) return;
    if(scrittaMats.includes(mat)) return;
    scrittaMats.push(mat);
    if(!scrittaMat) scrittaMat = mat;
  }
  function applyScrittaAppearance(tex, color = '#ffffff'){
    if(!tex || !scrittaMats.length) return;
    scrittaMats.forEach((mat) => {
      if(!mat) return;
      mat.map = tex;
      if(mat.color) mat.color.set(color);
      mat.transparent = true;
      mat.alphaTest = 0.5;
      mat.needsUpdate = true;
    });
  }

  const loader = new GLTFLoader();
  const dracoLoader = new DRACOLoader();
  dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/libs/draco/');
  dracoLoader.setDecoderConfig({ type: 'js' });
  dracoLoader.preload();
  loader.setCrossOrigin('anonymous');
  loader.setDRACOLoader(dracoLoader);
  loader.setMeshoptDecoder(MeshoptDecoder);
  const loadingOverlay = document.getElementById('loading');
  const loadingText = document.getElementById('loading-text');
  const loadingFill = document.getElementById('loading-fill');
  const mobileRotateQuery = window.matchMedia('(max-width: 900px) and (orientation: portrait)');
  let loadToken = 0;
const accessoryInputs = document.querySelectorAll('#step-accessori input[type="checkbox"]');
  accessoryInputs.forEach((cb) => {
    cb.addEventListener('change', () => {
      updatePrice();
    });
  });
const accessoryDeps = {
    schienale: ['tientibene'],
    motore: ['supporto'],
    batteria: ['impianto'],
    fishfinder: ['impianto', 'tientibene', 'batteria'],
    trolling: ['batteria']
  };
  const accessoryLabels = {
    tientibene: 'Tientibene',
    panca: 'Panca',
    schienale: 'Schienale',
    motore: 'Motore',
    supporto: 'Supporto motore',
    trolling: 'Motore di prua',
    fishfinder: 'Ecoscandaglio',
    impianto: 'Impianto elettrico',
    batteria: 'Batteria al Litio'
  };

  function setAccessoryChecked(key, checked, silent = false){
    const cb = document.querySelector(`#step-accessori input[data-accessory="${key}"]`);
    if(cb) cb.checked = checked;
    toggleAccessory(key, checked, silent);
  }

    function updateAccessoryRules(){
      accessoryInputs.forEach((cb) => {
        const key = cb.dataset.accessory;
        const deps = accessoryDeps[key];
        const allowed = !deps || deps.every(dep => {
          const depCb = document.querySelector(`#step-accessori input[data-accessory="${dep}"]`);
          return depCb?.checked;
        });
        cb.disabled = !allowed;
        const label = cb.closest('label');
        if(label){
          label.classList.toggle('is-locked', !allowed);
        }
        if(!allowed && cb.checked){
          setAccessoryChecked(key, false, true);
        }
      });
    }


      function updateNavLabels(step){
    const nextBtn = document.querySelector('#viewer-ui .next-btn .nav-label');
    if(nextBtn){
      const dict = I18N[currentLang] || I18N.it;
      nextBtn.textContent = step === 'accessori' ? dict.end : dict.go;
    }
  }

  function applyAccessoryLabelTexts(){
    const dict = (I18N[currentLang] || I18N.it).acc;
    document.querySelectorAll('#step-accessori input[data-accessory]').forEach((input) => {
      const key = input.getAttribute('data-accessory') || '';
      const label = input.closest('label');
      if(!label || !dict[key]) return;
      if(input.nextSibling && input.nextSibling.nodeType === 3){
        input.nextSibling.nodeValue = ` ${dict[key]}`;
      }else{
        label.appendChild(document.createTextNode(` ${dict[key]}`));
      }
    });
  }

  function getStepTitleText(step){
    const dict = I18N[currentLang] || I18N.it;
    return dict.stepTitle[step] || dict.stepTitle.finitura;
  }

  function applyLanguageUI(){
    const dict = I18N[currentLang] || I18N.it;
    const backLabel = document.querySelector('#viewer-ui .back-btn .nav-label');
    if(backLabel) backLabel.textContent = dict.back;
    const resetLabel = document.querySelector('#viewer-ui .reset-btn .reset-label');
    if(resetLabel) resetLabel.textContent = dict.reset;
    const orderBtn = document.getElementById('order-btn');
    if(orderBtn) orderBtn.textContent = dict.order;
    const screenshotBtn = document.getElementById('screenshot-btn');
    if(screenshotBtn){ screenshotBtn.title = dict.photoTitle; screenshotBtn.textContent = dict.photoBtn || 'PHOTO'; }
    const rxBtn = document.getElementById('rx-btn');
    if(rxBtn) rxBtn.title = dict.rxTitle;
    const loading = document.getElementById('loading-text');
    if(loading && /Caricamento|Loading/.test(loading.textContent || '')){
      if((loading.textContent || '').includes('0%')) loading.textContent = dict.loadingStart;
    }
    const infoCloseBtn = document.getElementById('info-close');
    if(infoCloseBtn) infoCloseBtn.textContent = currentLang === 'en' ? 'Close' : 'Chiudi';
    const title = document.getElementById('step-title');
    if(title) title.textContent = getStepTitleText(currentStep);
    const colorLabelEls = document.querySelectorAll('[data-color-label]');
    colorLabelEls.forEach((el) => {
      const key = el.getAttribute('data-color-label');
      if(!key) return;
      const v = dict.colorLabels && dict.colorLabels[key];
      if(v) el.textContent = v;
    });
    document.querySelectorAll('.info-pill[data-info-key]').forEach((infoPill) => {
      const stepKey = String(currentStep || 'finitura').toLowerCase();
      const dynamicStep = infoPill.getAttribute('data-info-dynamic') === 'step';
      if(dynamicStep){
        infoPill.setAttribute('aria-label', dict.infoAria[stepKey] || dict.infoAria.finitura);
        return;
      }
      const key = infoPill.getAttribute('data-info-key') || '';
      const title = getInfoContentForLang(key)?.title || 'Informazioni';
      infoPill.setAttribute('aria-label', `Info ${title}`);
    });
    const itBtn = document.getElementById('lang-it');
    const enBtn = document.getElementById('lang-en');
    if(itBtn) itBtn.classList.toggle('is-active', currentLang === 'it');
    if(enBtn) enBtn.classList.toggle('is-active', currentLang === 'en');
    applyCurrencyUI();
    const orderT = dict.orderModal || I18N.it.orderModal;
    const setText = (id, value) => {
      const el = document.getElementById(id);
      if(el) el.textContent = value;
    };
    setText('order-title', orderT.title);
    const orderCloseBtn = document.querySelector('#order-modal .order-close');
    if(orderCloseBtn) orderCloseBtn.textContent = orderT.close;
    setText('order-label-id', orderT.labels.id);
    setText('order-label-finish', orderT.labels.finish);
    setText('order-label-colors', orderT.labels.colors);
    setText('order-label-antiskid', orderT.labels.antiskid);
    setText('order-label-accessories', orderT.labels.accessories);
    setText('order-label-price', orderT.labels.price);
    setText('order-field-nome', orderT.fields.nome);
    setText('order-field-cognome', orderT.fields.cognome);
    setText('order-field-email', orderT.fields.email);
    setText('order-field-telefono', orderT.fields.telefono);
    setText('order-field-indirizzo', orderT.fields.indirizzo);
    setText('order-field-citta', orderT.fields.citta);
    setText('order-field-cap', orderT.fields.cap);
    setText('order-field-note', orderT.fields.note);
    setText('order-confirm', orderT.confirm);
    setText('order-download', orderT.download);
    applyAccessoryLabelTexts();
    updateNavLabels(currentStep);
    setAudioEnabled(audioEnabled, false);
    renderLiveSummary();
  }

  function setLanguage(lang){
    currentLang = (lang === 'en') ? 'en' : 'it';
    refreshColorMenusForLanguage();
    applyLanguageUI();
  }
  function applyCurrencyUI(){
    const eurBtn = document.getElementById('currency-eur');
    const usdBtn = document.getElementById('currency-usd');
    if(eurBtn) eurBtn.classList.toggle('is-active', currentCurrency === 'EUR');
    if(usdBtn) usdBtn.classList.toggle('is-active', currentCurrency === 'USD');
  }
  function formatMoney(valueEuro){
    const eur = Number(valueEuro) || 0;
    if(currentCurrency === 'USD'){
      const usd = eur * EUR_TO_USD;
      return `$ ${usd.toLocaleString('en-US', { maximumFractionDigits: 0 })}`;
    }
    return `${"\u20AC"} ${eur.toLocaleString('it-IT')}`;
  }
  function setCurrency(currency){
    currentCurrency = currency === 'USD' ? 'USD' : 'EUR';
    applyCurrencyUI();
    updatePrice();
    const orderPrice = document.getElementById('order-price');
    if(orderPrice) orderPrice.textContent = getPriceSummary();
  }

  function syncAccessoryUI(){
    accessoryInputs.forEach((cb) => {
      const key = cb.dataset.accessory;
      if(key) toggleAccessory(key, cb.checked, true);
    });
    updateAccessoryRules();
    updatePrice();
  }

    function resetAccessoryUI(){
    accessoryInputs.forEach((cb) => {
      cb.checked = false;
    });
    syncAccessoryUI();
  }
  const glbUrls = [
    'models/fisher40_action6_light_noq.glb?v=3',
    'models/fisher40_base_nodraco.glb?v=6'
  ];
  let glbIndex = 0;

  function loadGlb(){
    const url = glbUrls[glbIndex];
    const token = ++loadToken;
    let progressSeen = false;
    let loadTimeout;
    if(loadingOverlay){
      loadingOverlay.style.display = 'flex';
    }
    if(loadingText){
      loadingText.textContent = 'Caricamento modello 0%';
    }
    if(loadingFill){
      loadingFill.style.width = '0%';
    }
    loadTimeout = setTimeout(() => {
      if(token !== loadToken) return;
      if(loadingText){
        loadingText.textContent = 'Caricamento lento...';
      }
      if(!progressSeen && glbIndex < glbUrls.length - 1){
        glbIndex += 1;
        loadGlb();
      }
    }, 6000);
    loader.load(url, (gltf) => {
    if(token !== loadToken) return;
    if(loadTimeout) clearTimeout(loadTimeout);
    modelRoot = gltf.scene;
    resetAnimationSystem(gltf.animations || []);
    interactiveMeshesById.clear();
    interactiveAnchorsById.clear();
    interactiveState.clear();
    pancaAnimatedNode = null;
    pancaPosition = 'center';
    interactiveDefs.forEach((d) => interactiveState.set(d.id, false));
    modelRoot.scale.set(0.3,0.3,0.3);
    modelRoot.position.set(0,-1,0);
    scene.add(modelRoot);

    // Removed axes helper for clean view

    scrittaMats.length = 0;
    scrittaMat = null;
    trollingMeshes.length = 0;
    trollingDeployMeshes.length = 0;
    waterMaskMeshes.length = 0;
    modelRoot.traverse(obj => {
      if(obj.isMesh){
        const matName = obj.material?.name || '';
        const matNameLower = matName.toLowerCase();
        if(matName === 'Hull') hullMat=obj.material;
        if(matName === 'Deck') deckMat=obj.material;
        if(matName === 'Hatches' || matName === 'hatches' || matName === 'Portelli') hatchesMat=obj.material;
        if(matName === 'Gomma') bottazzoMat=obj.material;
        if(matName === 'Scritta' || matNameLower.includes('scritta')) addScrittaMaterial(obj.material);
        if(!scrittaMat && obj.name==='Scritta') addScrittaMaterial(obj.material);
        if(!scrittaMat && typeof obj.material?.name === 'string' && obj.material.name.toLowerCase().includes('scritta')) {
          addScrittaMaterial(obj.material);
        }
        const objNameLower = (obj.name || '').toLowerCase();
        const objMaterials = Array.isArray(obj.material) ? obj.material : [obj.material];
        if(objNameLower.includes('scritta')){
          objMaterials.forEach((m) => addScrittaMaterial(m));
        }
        objMaterials.forEach((m) => {
          const name = (m?.name || '').toLowerCase();
          if(name.includes('scritta')) addScrittaMaterial(m);
        });
        if(matNameLower.includes('chirp') || obj.name?.toLowerCase().includes('chirp')) chirpMeshes.push(obj);
        if(obj.name==='Tientibene') accessories.tientibene=obj;
        if(obj.name==='Panca') accessories.panca=obj;
        if(normalizeId(obj.name) === 'panca'){
          pancaAnimatedNode = obj;
          addInteractiveAnchor('panca', obj);
        }
        if(obj.name==='Schienale' || obj.name?.toLowerCase()==='schienale') accessories.schienale=obj;
        if(obj.name==='Motore') accessories.motore=obj;
        if(obj.name==='Fuoribordo') accessories.motore=obj;
        if(obj.name?.toLowerCase()==='supporto') accessories.supporto = obj;
        if(obj.name==='trolling' || obj.name?.toLowerCase()==='trolling') accessories.trolling = obj;
        if(obj.name==='Fishfinder' || obj.name?.toLowerCase()==='fishfinder') accessories.fishfinder = obj;
        if(obj.name==='Impianto' || obj.name?.toLowerCase()==='impianto' || obj.name==='ImpiantoElettrico' || obj.name?.toLowerCase()==='impiantoelettrico') accessories.impianto = obj;
        if(obj.name==='Batteria' || obj.name?.toLowerCase()==='batteria' || obj.name==='BatteriaLitio' || obj.name?.toLowerCase()==='batterialitio') accessories.batteria = obj;

        const parentNameLower = (obj.parent?.name || '').toLowerCase();
        const grandParentNameLower = (obj.parent?.parent?.name || '').toLowerCase();
        const nameCandidates = [objNameLower, parentNameLower, grandParentNameLower];
        const nameCandidatesNorm = nameCandidates.map((n) => normalizeId(n));
        const isTrollingDeploy = nameCandidates.some((n) => n.includes('trolling_deploy'));
        interactiveDefs.forEach((def) => {
          const matches = (def.hitTokens || []).some((token) => nameCandidatesNorm.some((n) => n.includes(token)));
          if(matches){
            addInteractiveMesh(def.id, obj);
            const objNameNorm = normalizeId(obj.name || '');
            const isDirectAnchor = (def.hitTokens || []).some((token) => objNameNorm.includes(token));
            if(isDirectAnchor){
              addInteractiveAnchor(def.id, obj);
            }
          }
        });
        if(normalizeId(obj.name) === 'panca001'){
          addInteractiveAnchor('panca', obj);
        }
        const isAccessoryName = (n) => (
          n.includes('tientibene') ||
          n.includes('panca') ||
          n.includes('schienale') ||
          n.includes('supporto') ||
          n.includes('trolling') ||
          n.includes('fuoribordo') ||
          n.includes('motore') ||
          n.includes('fishfinder') ||
          n.includes('impianto') ||
          n.includes('batteria') ||
          n.includes('antiskid_eva') ||
          n.includes('chirp')
        );
        const isAccessoryMaterial = (m) => (
          m.includes('clean silver') ||
          m.includes('procedural skin') ||
          m.includes('manopola') ||
          m.includes('fuoribordo') ||
          m.includes('trolling') ||
          m.includes('chirp')
        );
        const isMappedAccessoryMesh = accessoryMeshNames.has(obj.name);
        const shouldHideByPrefix =
          nameCandidates.some((n) => isAccessoryName(n)) ||
          isAccessoryMaterial(matNameLower) ||
          isMappedAccessoryMesh;
        if(shouldHideByPrefix){
          obj.visible = false;
        }
        if(nameCandidates.some(n => n === 'antiskid_eva' || n.includes('antiskid') || n.includes('eva')) || obj.name === 'mesh_0_1' || obj.name === 'EVA' || obj.name?.toLowerCase().includes('eva') || matNameLower.includes('sponge')){          antiskidEvaMeshes.push(obj);          obj.material = obj.material?.clone?.() || obj.material;          obj.visible = false;        }
        if(obj.name?.toLowerCase()==='fishfinder'){
          // Clone to avoid changing shared materials (e.g. Doors).
          obj.material = obj.material?.clone?.() || obj.material;
          if(obj.material){
            if('metalness' in obj.material) obj.material.metalness = 0;
            if('roughness' in obj.material) obj.material.roughness = 0.9;
            obj.material.needsUpdate = true;
          }
        }
        if(obj.name?.toLowerCase()==='schienale' || obj.name === 'mesh_0_2'){
          schienaleMeshes.push(obj);
        }
        if(obj.name?.toLowerCase().includes('trolling') && !isTrollingDeploy){
          trollingMeshes.push(obj);
        }
        if(isTrollingDeploy){
          trollingDeployMeshes.push(obj);
        }

        const groupKey =
          getAccessoryKey(obj.name, '') ||
          getAccessoryKey(obj.parent?.name, '') ||
          getAccessoryKey(obj.parent?.parent?.name, '') ||
          (obj.name?.toLowerCase().includes('chirp') ? 'fishfinder' : '') ||
          (matNameLower.includes('chirp') ? 'fishfinder' : '') ||
          (accessoryMeshMap.schienale?.includes(obj.name) ? 'schienale' : '') ||
          (accessoryMeshMap.tientibene?.includes(obj.name) ? 'tientibene' : '') ||
          (accessoryMeshMap.panca?.includes(obj.name) ? 'panca' : '') ||
          (accessoryMeshMap.supporto?.includes(obj.name) ? 'supporto' : '') ||
          (accessoryMeshMap.motore?.includes(obj.name) ? 'motore' : '') ||
          (accessoryMeshMap.trolling?.includes(obj.name) ? 'trolling' : '');
        if(groupKey && accessoryGroups[groupKey] && !isTrollingDeploy) accessoryGroups[groupKey].push(obj);
      }
    });

    // Preload scritta textures once
    if(!scrittaTextures.black){
      scrittaTextures.black = textureLoader.load('images/Scritta_black.png', (t) => {
        t.wrapS = t.wrapT = THREE.ClampToEdgeWrapping;
        t.repeat.set(1, 1);
        t.offset.set(0, 0);
        t.colorSpace = THREE.SRGBColorSpace;
        t.flipY = false;
        t.needsUpdate = true;
      });
    }
    if(!scrittaTextures.white){
      scrittaTextures.white = textureLoader.load('images/Scritta_white.png', (t) => {
        t.wrapS = t.wrapT = THREE.ClampToEdgeWrapping;
        t.repeat.set(1, 1);
        t.offset.set(0, 0);
        t.colorSpace = THREE.SRGBColorSpace;
        t.flipY = false;
        t.needsUpdate = true;
      });
    }
    if(!chirpTexture){
      chirpTexture = textureLoader.load('images/Chirp.png', (t) => {
        t.wrapS = t.wrapT = THREE.RepeatWrapping;
        t.colorSpace = THREE.SRGBColorSpace;
        t.flipY = false;
        t.needsUpdate = true;
        applyChirpTextureToMeshes();
      });
    }
    if(!antiskidTexture){
      antiskidTexture = textureLoader.load('images/antiskid.jpg', (t) => {
        t.wrapS = t.wrapT = THREE.RepeatWrapping;
        t.repeat.set(tileU(0.8), tileV(0.8));
      });
    }

    // Reflection camera for water looks from below; keep shell materials double-sided
    // to avoid seeing deck interior through culled backfaces.
    [hullMat, deckMat, hatchesMat].forEach((mat) => {
      if(!mat) return;
      mat.side = THREE.DoubleSide;
      if('shadowSide' in mat) mat.shadowSide = THREE.DoubleSide;
      mat.needsUpdate = true;
    });

    if(hullMat) hullMat.color.set('#ffffff');
    if(deckMat) deckMat.color.set('#ffffff');
    if(hatchesMat) hatchesMat.color.set('#ffffff');
    if(bottazzoMat) bottazzoMat.color.set('#000000');
    applyScrittaAppearance(scrittaTextures.black, '#ffffff');
    applyChirpTextureToMeshes();
    Object.values(accessories).forEach(a=>a.visible=false);
    Object.values(accessoryGroups).forEach(list => list.forEach(a => a.visible = false));
    trollingDeployMeshes.forEach((m) => m.visible = false);
    antiskidEvaMeshes.forEach(mesh => mesh.visible = false);
    applyEvaTextureToMeshes(antiskidEvaMeshes);
    syncSchienaleMaterial();
    syncTrollingMaterial();
    applyMaterialOverrides(modelRoot);
    configureWaterMaskMeshes();
    applyChirpTextureToMeshes();

    // Auto-center and frame model in the camera view
    const box = new THREE.Box3().setFromObject(modelRoot);
    const size = new THREE.Vector3();
    const center = new THREE.Vector3();
    box.getSize(size);
    box.getCenter(center);
    modelRoot.position.sub(center);
    modelRoot.position.add(new THREE.Vector3(-0.05, 0, 0));

    const maxDim = Math.max(size.x, size.y, size.z);
    if(SHOW_DEBUG_AXES){
      if(modelAxesHelper && modelRoot){
        modelRoot.remove(modelAxesHelper);
      }
      modelAxesHelper = new THREE.AxesHelper(Math.max(0.2, maxDim * 0.25));
      modelRoot.add(modelAxesHelper);
    }
    camera.fov = mobileUiQuery.matches ? 66 : 60;
    camera.updateProjectionMatrix();
    const fov = camera.fov * (Math.PI / 180);
    let cameraZ = Math.abs(maxDim / (2 * Math.tan(fov / 2)));
    cameraZ *= 1;
    framedMaxDim = maxDim;
    framedCameraZ = cameraZ;
    const distMul = mobileUiQuery.matches ? MOBILE_FRAMING_DIST_MUL : DESKTOP_FRAMING_DIST_MUL;
    camera.position.set(0.2, maxDim * 0.2, cameraZ * distMul);
    camera.lookAt(0, 0, 0);
    controls.target.set(0, 0, 0);
    controls.update();

    controls.minDistance = cameraZ * (mobileUiQuery.matches ? MOBILE_MIN_DIST_MUL : DESKTOP_MIN_DIST_MUL);
      controls.maxDistance = cameraZ * (mobileUiQuery.matches ? MOBILE_MAX_DIST_MUL : DESKTOP_MAX_DIST_MUL);

      waterTargetY = -maxDim * 0.12 + 0.110 + WATER_LEVEL_OFFSET;
      if(water){
        water.position.y = waterTargetY;
      }
      syncAccessoryUI();
      const envReady = loadEnvironment();
      Promise.race([
        envReady,
        new Promise((resolve) => setTimeout(resolve, 2500))
      ]).finally(() => {
        if(token !== loadToken) return;
        if(loadingOverlay){
          loadingOverlay.style.display = 'none';
        }
      });
    }, (xhr) => {
      if(token !== loadToken) return;
      progressSeen = true;
      if(!xhr || !loadingFill || !loadingText) return;
      if(xhr.total){
        const pct = Math.min(100, Math.round((xhr.loaded / xhr.total) * 100));
        loadingFill.style.width = `${pct}%`;
        loadingText.textContent = `Caricamento modello ${pct}%`;
      }else{
        loadingText.textContent = 'Caricamento modello...';
      }
    }, err => {
      if(token !== loadToken) return;
      if(loadTimeout) clearTimeout(loadTimeout);
      if(glbIndex < glbUrls.length - 1){
        glbIndex += 1;
        loadGlb();
        return;
      }
      console.error('Errore caricamento GLB:', err);
      if(loadingText){
        const details = err?.message ? ` (${err.message})` : '';
        loadingText.textContent = `Errore caricamento modello${details}`;
      }
    });
    }

  function applyMobileRotate(){
    renderer.setSize(viewer.clientWidth, viewer.clientHeight);
    camera.aspect = viewer.clientWidth / viewer.clientHeight;
    camera.updateProjectionMatrix();
    applyInteractionScheme();
    applyFramingForViewport();
  }

  loadEnvironment();
  loadGlb();

  let finishSelected = false;
  let hullSelected = false;
  let deckSelected = false;
  let hatchesSelected = false;
  let currentStep = 'finitura';
  let currentLang = 'it';
  let currentCurrency = 'EUR';
  const EUR_TO_USD = 1.1;
  const I18N = {
    it: {
      stepTitle: { finitura: 'Finitura', colori: 'Colori', accessori: 'Accessori' },
      back: 'Indietro',
      go: 'Avanti',
      end: 'Fine',
      reset: 'RESETTA',
      order: 'Ordina',
      photoTitle: 'Salva screenshot',
      photoBtn: 'FOTO',
      muteOn: 'MUTO',
      muteOff: 'AUDIO',
      rxTitle: 'Vista semitrasparente',
      loadingStart: 'Caricamento modello 0%',
      acc: {
        tientibene: 'Tientibene',
        panca: 'Panca',
        schienale: 'Schienale',
        supporto: 'Supporto motore',
        motore: 'Motore',
        impianto: 'Impianto elettrico',
        batteria: 'Batteria al Litio',
        fishfinder: 'Ecoscandaglio',
        trolling: 'Motore di prua'
      },
      infoAria: { finitura: 'Info Finitura', colori: 'Info Colori', accessori: 'Info Accessori' },
      colorLabels: { hull: 'CHIGLIA', deck: 'PONTE', hatches: 'PORTELLI', antiskid: 'ANTISCIVOLO' },
      orderModal: {
        title: 'Configurazione',
        close: 'Chiudi',
        labels: { id: 'ID', finish: 'Finitura', colors: 'Colori', antiskid: 'Antiscivolo', accessories: 'Accessori', price: 'Prezzo' },
        fields: { nome: 'Nome', cognome: 'Cognome', email: 'Email', telefono: 'Telefono', indirizzo: 'Indirizzo', citta: 'Citta', cap: 'CAP', note: 'Note' },
        confirm: 'Conferma Configurazione',
        download: 'Scarica Configurazione'
      }
    },
    en: {
      stepTitle: { finitura: 'Finish', colori: 'Colors', accessori: 'Accessories' },
      back: 'Back',
      go: 'Go',
      end: 'End',
      reset: 'RESET',
      order: 'Order',
      photoTitle: 'Save screenshot',
      photoBtn: 'PHOTO',
      muteOn: 'MUTE',
      muteOff: 'UNMUTE',
      rxTitle: 'Semi-transparent view',
      loadingStart: 'Loading model 0%',
      acc: {
        tientibene: 'Grab Rail',
        panca: 'Bench',
        schienale: 'Backrest',
        supporto: 'Engine Bracket',
        motore: 'Engine',
        impianto: 'Electrical System',
        batteria: 'Lithium Battery',
        fishfinder: 'Fishfinder',
        trolling: 'Trolling Motor'
      },
      infoAria: { finitura: 'Finish Info', colori: 'Colors Info', accessori: 'Accessories Info' },
      colorLabels: { hull: 'HULL', deck: 'DECK', hatches: 'DOORS', antiskid: 'ANTISKID' },
      orderModal: {
        title: 'Configuration',
        close: 'Close',
        labels: { id: 'ID', finish: 'Finish', colors: 'Colors', antiskid: 'Antiskid', accessories: 'Accessories', price: 'Price' },
        fields: { nome: 'Name', cognome: 'Surname', email: 'Email', telefono: 'Phone', indirizzo: 'Address', citta: 'City', cap: 'ZIP', note: 'Notes' },
        confirm: 'Confirm Configuration',
        download: 'Download Configuration'
      }
    }
  };
  let accessoriUnlocked = false;
  let selectedFinish = null;
  let selectedHull = null;
  let selectedDeck = null;
  let selectedHatches = null;
  let selectedHullLabel = '';
  let selectedDeckLabel = '';
    let selectedDeckMode = null;
    let selectedHullMode = null;
    let selectedHatchesMode = null;
  let selectedHatchesLabel = '';
    let presetLocked = false;
    let presetName = '';
  let hullDark = false;
  let deckDark = false;
  let wrappingWhite = false;
  let hatchesAuto = true;
  const colorSelects = { hull: null, deck: null, hatches: null };
  function setColorLabel(group, label){
    if(!label) return;
    if(group === 'hull') selectedHullLabel = label;
    else if(group === 'deck') selectedDeckLabel = label;
    else if(group === 'hatches') selectedHatchesLabel = label;
  }
  const gelcoatTriggers = { hull: null, deck: null, hatches: null };
  const textureLoader = new THREE.TextureLoader();
  let antiskidTexture = null;
  let antiskidPrintTexture = null;
  let antiskidEvaTexture = null;
  let ruggedTexture = null;
  function applyMaterialOverrides(root){
    if(!root) return;
    let yamahaMat = null;
    let ossaturaMat = null;
    root.traverse((obj) => {
      if(!obj.isMesh || !obj.material) return;
      const list = Array.isArray(obj.material) ? obj.material : [obj.material];
      list.forEach((m) => {
        if(!m?.name) return;
        const name = m.name.toLowerCase();
        if(name === 'yamaha') yamahaMat = m;
        if(name === 'ossatura') ossaturaMat = m;
      });
    });
    if(yamahaMat){
      if(yamahaMat.color) yamahaMat.color.set('#696969');
      yamahaMat.transparent = false;
      yamahaMat.opacity = 1;
      yamahaMat.alphaTest = 0;
      yamahaMat.depthWrite = true;
      yamahaMat.depthTest = true;
      if('alphaMap' in yamahaMat) yamahaMat.alphaMap = null;
      yamahaMat.needsUpdate = true;
    }
    if(ossaturaMat && ossaturaMat.color) ossaturaMat.color.set('#808080');

    const toBlackPlastic = (mat) => {
      if(!mat) return mat;
      const m = mat.clone?.() || mat;
      if(m.color) m.color.set('#000000');
      m.map = null;
      m.emissiveMap = null;
      if(m.emissive) m.emissive.set('#000000');
      m.transparent = false;
      m.opacity = 1;
      m.alphaTest = 0;
      if('metalness' in m) m.metalness = 0;
      if('roughness' in m) m.roughness = 1;
      m.needsUpdate = true;
      return m;
    };

    const cloneWithColor = (mat, color) => {
      if(!mat) return mat;
      const m = mat.clone?.() || mat;
      if(m.color) m.color.set(color);
      m.needsUpdate = true;
      return m;
    };
    const toOpaqueYamaha = (mat) => {
      if(!mat) return mat;
      const m = mat.clone?.() || mat;
      if(m.color) m.color.set('#696969');
      m.transparent = false;
      m.opacity = 1;
      m.alphaTest = 0;
      m.depthWrite = true;
      m.depthTest = true;
      m.side = THREE.FrontSide;
      if('alphaMap' in m) m.alphaMap = null;
      if('map' in m && m.map && m.map.format === THREE.AlphaFormat) m.map = null;
      m.needsUpdate = true;
      return m;
    };

    const toKey = (name) => (name || '').toLowerCase().replace(/\./g, '');
    const yamahaTargets = new Set([
      'fuoribordostl001',
      'fuoribordostl002',
      'fuoribordostl004',
      'fuoribordomotore',
      'fuoribordomanetta',
      'fuoribordoattacco'
    ]);
    const plasticTargets = new Set([
      'fuoribordostl',
      'fuoribordostl003',
      'fuoribordomanopola',
      'manopola',
      'fishfinder',
      'trolling002',
      'trolling003',
      'trolling004',
      'trolling005',
      'trolling_deploy001',
      'trolling_deploy002',
      'trolling_deploy003',
      'trolling_deploy005'
    ]);

    root.traverse((obj) => {
      if(!obj.isMesh) return;
      const objNameLower = String(obj.name || '').toLowerCase();
      if(objNameLower.includes('water_blocker') || objNameLower.includes('waterblocker') || objNameLower.includes('waterblock')){
        if(!waterMaskMeshes.includes(obj)) waterMaskMeshes.push(obj);
        return;
      }

      const key = toKey(obj.name);
      const parentKey = toKey(obj.parent?.name);
      const grandParentKey = toKey(obj.parent?.parent?.name);
      const candidateKeys = [key, parentKey, grandParentKey];
      const isChirpMesh =
        candidateKeys.some((k) => k.includes('chirp')) ||
        objNameLower.includes('chirp') ||
        (Array.isArray(obj.material) ? obj.material : [obj.material]).some((m) =>
          String(m?.name || '').toLowerCase().includes('chirp')
        );

      if(isChirpMesh){
        return;
      }

      if(objNameLower == 'ossatura'){
        if(Array.isArray(obj.material)){
          obj.material = obj.material.map((m) => cloneWithColor(m, '#00FF00'));
        }else{
          obj.material = cloneWithColor(obj.material, '#00FF00');
        }
        return;
      }

      if(objNameLower.includes('shiumata') || objNameLower.includes('schiumata')){
        if(Array.isArray(obj.material)){
          obj.material = obj.material.map((m) => cloneWithColor(m, '#9400D3'));
        }else{
          obj.material = cloneWithColor(obj.material, '#9400D3');
        }
        return;
      }

      if(candidateKeys.some((k) => plasticTargets.has(k))){
        if(Array.isArray(obj.material)){
          obj.material = obj.material.map((m) => toBlackPlastic(m));
        }else{
          obj.material = toBlackPlastic(obj.material);
        }
        return;
      }
      if(yamahaMat && candidateKeys.some((k) => yamahaTargets.has(k))){
        if(Array.isArray(obj.material)){
          obj.material = obj.material.map((m) => toOpaqueYamaha(m || yamahaMat));
        }else{
          obj.material = toOpaqueYamaha(obj.material || yamahaMat);
        }
      }
    });
  }
  let selectedAntiskid = '';
  const scrittaTextures = {
    black: null,
    white: null
  };

    const priceTable = {
      base: 6000,
      finishPct: {
        gelcoat: 0.0,
        paint: 0.0
      },
      colorUpcharges: {
        hull: { white: 0, color: 150, wrapping: 500, rugged: 250 },
        deck: { white: 0, color: 150, wrapping: 500, rugged: 250 },
        hatches: { white: 0, color: 50, wrapping: 150, rugged: 100 }
      },
      accessories: {
        tientibene: 500,
        panca: 1000,
        schienale: 250,
        motore: 3000,
        supporto: 150,
        trolling: 2000,
        fishfinder: 800,
        impianto: 500,
        batteria: 300,
        antiskid: {
          none: 0,
          paint: 150,
          print: 500,
          eva: 300
        }
      }
    };
function updatePrice(){
    let total = priceTable.base;
    if(selectedFinish){
      total += priceTable.base * (priceTable.finishPct[selectedFinish] || 0);
    }
    const isChecked = (name) =>
      document.querySelector(`#step-accessori input[data-accessory="${name}"]`)?.checked;
    const isVisible = (name) =>
      accessories[name]?.visible ||
      (accessoryGroups[name] && accessoryGroups[name].some(obj => obj.visible));
    const isSelected = (name) => Boolean(isChecked(name) || isVisible(name));
    total += isSelected('tientibene') ? priceTable.accessories.tientibene : 0;
    total += isSelected('panca') ? priceTable.accessories.panca : 0;
    total += isSelected('schienale') ? priceTable.accessories.schienale : 0;
    total += isSelected('motore') ? priceTable.accessories.motore : 0;
    total += isSelected('supporto') ? priceTable.accessories.supporto : 0;
    total += isSelected('trolling') ? priceTable.accessories.trolling : 0;
    total += isSelected('fishfinder') ? priceTable.accessories.fishfinder : 0;
    total += isSelected('impianto') ? priceTable.accessories.impianto : 0;
    total += isSelected('batteria') ? priceTable.accessories.batteria : 0;      total += getAntiskidPrice();
      const modePrice = (group, mode) => {
        const table = priceTable?.colorUpcharges?.[group];
        if(!table) return 0;
        return table[mode || 'white'] || 0;
      };
      total += modePrice('hull', selectedHullMode);
      total += modePrice('deck', selectedDeckMode);
      total += modePrice('hatches', selectedHatchesMode);
    const el = document.getElementById('price-tag');
    if(el) el.textContent = formatMoney(total);
    renderLiveSummary();
  }

  function showStep(step){      updateNavLabels(step);
    if(step === 'accessori' && !accessoriUnlocked){
      step = 'colori';
    }
    if(step !== 'accessori'){
      accessoriUnlocked = false;
    }
    document.getElementById('step-finitura').classList.add('hidden');
    document.getElementById('step-colori').classList.add('hidden');
    document.getElementById('step-accessori').classList.add('hidden');
    document.getElementById(`step-${step}`).classList.remove('hidden');

    const backBtn = document.querySelector('#viewer-ui .back-btn');
    const resetBtn = document.querySelector('#viewer-ui .reset-btn');
    const nextBtn = document.querySelector('#viewer-ui .next-btn');
    if(backBtn){
      const isFirst = step === 'finitura';
      backBtn.classList.toggle('is-disabled', isFirst);
      backBtn.setAttribute('aria-disabled', isFirst ? 'true' : 'false');
      backBtn.classList.toggle('is-hidden', isFirst);
      backBtn.style.display = isFirst ? 'none' : 'inline-flex';
    }
    if(resetBtn){
      resetBtn.classList.toggle('is-hidden', step !== 'accessori');
    }
    const orderBtn = document.getElementById('order-btn');
    if(orderBtn){
      orderBtn.classList.add('is-hidden');
      orderBtn.style.display = 'none';
    }
    if(nextBtn){
      const showNext = step !== 'finitura' ? true : finishSelected;
      nextBtn.classList.toggle('is-hidden', !showNext);
      nextBtn.style.display = showNext ? 'inline-flex' : 'none';
    }
    const isMobile = window.matchMedia && window.matchMedia('(max-width: 900px)').matches;

    if(backBtn){
      backBtn.style.display = (step === 'finitura') ? 'none' : 'inline-flex';
      backBtn.style.pointerEvents = (step === 'finitura') ? 'none' : 'auto';
      if(isMobile){
        backBtn.style.position = 'absolute';
        backBtn.style.top = '10px';
        backBtn.style.left = '12px';
        backBtn.style.right = 'auto';
      }else{
        backBtn.style.removeProperty('position');
        backBtn.style.removeProperty('top');
        backBtn.style.removeProperty('left');
        backBtn.style.removeProperty('right');
      }
    }

    if(nextBtn){
      const showNext = step !== 'finitura' ? true : finishSelected;
      nextBtn.style.display = showNext ? 'inline-flex' : 'none';
      nextBtn.style.pointerEvents = showNext ? 'auto' : 'none';
      if(isMobile){
        nextBtn.style.position = 'absolute';
        nextBtn.style.top = '10px';
        nextBtn.style.right = '12px';
        nextBtn.style.left = 'auto';
      }else{
        nextBtn.style.removeProperty('position');
        nextBtn.style.removeProperty('top');
        nextBtn.style.removeProperty('left');
        nextBtn.style.removeProperty('right');
      }
    }

    const title = document.getElementById('step-title');
    if(title){
      title.textContent = getStepTitleText(step);
    }
    const viewerEl = document.getElementById('viewer');
    if(viewerEl){
      viewerEl.classList.toggle('step-finitura', step === 'finitura');
      viewerEl.classList.toggle('step-colori', step === 'colori');
      viewerEl.classList.toggle('step-accessori', step === 'accessori');
    }
    document.body.classList.toggle('step-finitura', step === 'finitura');
    document.body.classList.toggle('step-colori', step === 'colori');
    document.body.classList.toggle('step-accessori', step === 'accessori');
    currentStep = step;
    if(step !== 'colori'){
      document.body.classList.remove('color-menu-open');
      const viewerEl = document.getElementById('viewer');
      if(viewerEl) viewerEl.classList.remove('color-menu-open');
    }else{
      syncColorMenuOpenState();
    }
    if(step !== 'accessori' && deckTransparent){
      setDeckTransparency(false);
    }
    updateRxButtonState();
  }

  const colorPalettes = {
    gelcoat: {
      hull: [
        { label: 'Bianco', color: '#ffffff' },
        { label: 'Verde acqua', color: '#7FFFD4' },
        { label: 'Ciano', color: '#00FFFF' },
        { label: 'Lime', color: '#7FFF00' },
        { label: 'Blu notte', color: '#00008B' },
        { label: 'Blu elettrico', color: '#0000FF' },
        { label: 'Nero', color: '#000000' },
        { label: 'Grigio', color: '#808080' },
        { label: 'Grigio fumo', color: '#A9A9A9' },
        { label: 'Bronzo', color: '#B8860B' },
        { label: 'Giallo sole', color: '#FFFF00' },
        { label: 'Arancione', color: '#FFA500' },
        { label: 'Rosso', color: '#FF0000' },
        { label: 'Oliva', color: '#808000' },
        { label: 'Magenta', color: '#FF00FF' },
        { label: 'Salmone', color: '#FFA07A' },
        { label: 'Indaco', color: '#4B0082' }
      ],
      deck: [
        { label: 'Bianco', color: '#ffffff' },
        { label: 'Verde acqua', color: '#7FFFD4' },
        { label: 'Ciano', color: '#00FFFF' },
        { label: 'Lime', color: '#7FFF00' },
        { label: 'Blu notte', color: '#00008B' },
        { label: 'Blu elettrico', color: '#0000FF' },
        { label: 'Nero', color: '#000000' },
        { label: 'Grigio', color: '#808080' },
        { label: 'Grigio fumo', color: '#A9A9A9' },
        { label: 'Bronzo', color: '#B8860B' },
        { label: 'Giallo sole', color: '#FFFF00' },
        { label: 'Arancione', color: '#FFA500' },
        { label: 'Rosso', color: '#FF0000' },
        { label: 'Oliva', color: '#808000' },
        { label: 'Magenta', color: '#FF00FF' },
        { label: 'Salmone', color: '#FFA07A' },
        { label: 'Indaco', color: '#4B0082' }
      ],
      hatches: [
        { label: 'Bianco', color: '#ffffff' },
        { label: 'Verde acqua', color: '#7FFFD4' },
        { label: 'Ciano', color: '#00FFFF' },
        { label: 'Lime', color: '#7FFF00' },
        { label: 'Blu notte', color: '#00008B' },
        { label: 'Blu elettrico', color: '#0000FF' },
        { label: 'Nero', color: '#000000' },
        { label: 'Grigio', color: '#808080' },
        { label: 'Grigio fumo', color: '#A9A9A9' },
        { label: 'Bronzo', color: '#B8860B' },
        { label: 'Giallo sole', color: '#FFFF00' },
        { label: 'Arancione', color: '#FFA500' },
        { label: 'Rosso', color: '#FF0000' },
        { label: 'Oliva', color: '#808000' },
        { label: 'Magenta', color: '#FF00FF' },
        { label: 'Salmone', color: '#FFA07A' },
        { label: 'Indaco', color: '#4B0082' }
      ]
    },
    wrapping: {
      hull: [
        { label: 'Miele', color: '#ffffff', texture: 'images/wrapping/honey21.jpg', scale: 0.5, scaleU: 0.4, scaleV: 0.6 },
        { label: 'Onda', color: '#234a63', texture: 'images/wrapping/Wave.jpg', scale: 0.7 },
        { label: 'Carbonio', color: '#333333', texture: 'images/wrapping/Carbon.jpg', scale: 1 },
        { label: 'Mimetico', color: '#3b4a3a', texture: 'images/wrapping/Camu.jpg', scale: 0.2 },
        { label: 'Mimetico 2', color: '#3b4a3a', texture: 'images/wrapping/Camu2.jpg', scale: 0.2 },
        { label: 'Laser', color: '#ffffff', texture: 'images/wrapping/Laser.jpg', scale: 0.7 },
        { label: 'Onda verde', color: '#ffffff', texture: 'images/wrapping/Greenwave.jpg', scale: 0.7 },
        { label: 'Astratto', color: '#ffffff', texture: 'images/wrapping/Abstract.jpg', scale: 0.5 }
      ],
      deck: [
        { label: 'Miele', color: '#ffffff', texture: 'images/wrapping/honey21.jpg', scale: 0.5, scaleU: 0.4, scaleV: 0.6 },
        { label: 'Onda', color: '#234a63', texture: 'images/wrapping/Wave.jpg', scale: 0.7 },
        { label: 'Carbonio', color: '#333333', texture: 'images/wrapping/Carbon.jpg', scale: 1 },
        { label: 'Mimetico', color: '#3b4a3a', texture: 'images/wrapping/Camu.jpg', scale: 0.2 },
        { label: 'Mimetico 2', color: '#3b4a3a', texture: 'images/wrapping/Camu2.jpg', scale: 0.2 },
        { label: 'Laser', color: '#ffffff', texture: 'images/wrapping/Laser.jpg', scale: 0.7 },
        { label: 'Onda verde', color: '#ffffff', texture: 'images/wrapping/Greenwave.jpg', scale: 0.7 },
        { label: 'Astratto', color: '#ffffff', texture: 'images/wrapping/Abstract.jpg', scale: 0.5 }
      ],
      hatches: [
        { label: 'Miele', color: '#ffffff', texture: 'images/wrapping/honey21.jpg', scale: 0.5, scaleU: 0.4, scaleV: 0.6 },
        { label: 'Onda', color: '#234a63', texture: 'images/wrapping/Wave.jpg', scale: 0.7 },
        { label: 'Carbonio', color: '#333333', texture: 'images/wrapping/Carbon.jpg', scale: 1 },
        { label: 'Mimetico', color: '#3b4a3a', texture: 'images/wrapping/Camu.jpg', scale: 0.2 },
        { label: 'Mimetico 2', color: '#3b4a3a', texture: 'images/wrapping/Camu2.jpg', scale: 0.2 },
        { label: 'Laser', color: '#ffffff', texture: 'images/wrapping/Laser.jpg', scale: 0.7 },
        { label: 'Onda verde', color: '#ffffff', texture: 'images/wrapping/Greenwave.jpg', scale: 0.7 },
        { label: 'Astratto', color: '#ffffff', texture: 'images/wrapping/Abstract.jpg', scale: 0.5 }
      ]
    },
    paint: {
      hull: [
        { label: 'Bianco', color: '#ffffff' },
        { label: 'Verde acqua', color: '#7FFFD4' },
        { label: 'Ciano', color: '#00FFFF' },
        { label: 'Lime', color: '#7FFF00' },
        { label: 'Blu notte', color: '#00008B' },
        { label: 'Blu elettrico', color: '#0000FF' },
        { label: 'Nero', color: '#000000' },
        { label: 'Grigio', color: '#808080' },
        { label: 'Grigio fumo', color: '#A9A9A9' },
        { label: 'Bronzo', color: '#B8860B' },
        { label: 'Giallo sole', color: '#FFFF00' },
        { label: 'Arancione', color: '#FFA500' },
        { label: 'Rosso', color: '#FF0000' },
        { label: 'Oliva', color: '#808000' },
        { label: 'Magenta', color: '#FF00FF' },
        { label: 'Salmone', color: '#FFA07A' },
        { label: 'Indaco', color: '#4B0082' }
      ],
      deck: [
        { label: 'Bianco', color: '#ffffff' },
        { label: 'Verde acqua', color: '#7FFFD4' },
        { label: 'Ciano', color: '#00FFFF' },
        { label: 'Lime', color: '#7FFF00' },
        { label: 'Blu notte', color: '#00008B' },
        { label: 'Blu elettrico', color: '#0000FF' },
        { label: 'Nero', color: '#000000' },
        { label: 'Grigio', color: '#808080' },
        { label: 'Grigio fumo', color: '#A9A9A9' },
        { label: 'Bronzo', color: '#B8860B' },
        { label: 'Giallo sole', color: '#FFFF00' },
        { label: 'Arancione', color: '#FFA500' },
        { label: 'Rosso', color: '#FF0000' },
        { label: 'Oliva', color: '#808000' },
        { label: 'Magenta', color: '#FF00FF' },
        { label: 'Salmone', color: '#FFA07A' },
        { label: 'Indaco', color: '#4B0082' }
      ],
      hatches: [
        { label: 'Bianco', color: '#ffffff' },
        { label: 'Verde acqua', color: '#7FFFD4' },
        { label: 'Ciano', color: '#00FFFF' },
        { label: 'Lime', color: '#7FFF00' },
        { label: 'Blu notte', color: '#00008B' },
        { label: 'Blu elettrico', color: '#0000FF' },
        { label: 'Nero', color: '#000000' },
        { label: 'Grigio', color: '#808080' },
        { label: 'Grigio fumo', color: '#A9A9A9' },
        { label: 'Bronzo', color: '#B8860B' },
        { label: 'Giallo sole', color: '#FFFF00' },
        { label: 'Arancione', color: '#FFA500' },
        { label: 'Rosso', color: '#FF0000' },
        { label: 'Oliva', color: '#808000' },
        { label: 'Magenta', color: '#FF00FF' },
        { label: 'Salmone', color: '#FFA07A' },
        { label: 'Indaco', color: '#4B0082' }
      ]
    },
    rugged: {
      all: [
        { label: 'Laguna', color: '#556B2F' },
        { label: 'Foche', color: '#2F4F4F' },
        { label: 'Acido', color: '#7FFF00' }
      ]
    }
  };

  function renderColorSelect(group, containerId, colors){
    const container = document.getElementById(containerId);
    if(!container) return;
    container.innerHTML = '';
    const select = document.createElement('select');
    const placeholder = document.createElement('option');
    placeholder.textContent = 'Select';
    placeholder.value = '';
    placeholder.disabled = true;
    placeholder.selected = true;
    select.appendChild(placeholder);
    select.dataset.group = group;
    colorSelects[group] = select;
    let isInit = true;
    colors.forEach(({ label, color, texture, scale, scaleU, scaleV }) => {
      const displayLabel = translateColorMenuLabel(label);
      const opt = document.createElement('option');
      opt.textContent = displayLabel;
      opt.value = color || '';
      if(texture) opt.dataset.texture = texture;
      if(scale) opt.dataset.scale = scale;
      if(Number.isFinite(scaleU)) opt.dataset.scaleU = String(scaleU);
      if(Number.isFinite(scaleV)) opt.dataset.scaleV = String(scaleV);
      select.appendChild(opt);
    });
    select.addEventListener('change', () => {
      const opt = select.selectedOptions[0];
      if(!opt || !opt.value) return;
      const proxyBtn = {
          textContent: opt.textContent,
          dataset: {
          texture: opt.dataset.texture,
          scale: opt.dataset.scale,
          scaleU: opt.dataset.scaleU,
          scaleV: opt.dataset.scaleV
        }
      };
      setColorLabel(group, opt.textContent);
      if(group === 'hull') setHull(opt.value, proxyBtn);
      else if(group === 'deck') setDeck(opt.value, proxyBtn);
      else setHatches(opt.value, proxyBtn, !isInit);
      isInit = false;
    });
    container.appendChild(select);
  }
  function createChoiceOption(label, onPick){
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'choice-option';
    btn.textContent = label;
    btn.addEventListener('click', (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      onPick();
    });
    return btn;
  }

  function createChoiceSubmenu(title){
    const wrap = document.createElement('div');
    wrap.className = 'choice-sub';
    const trigger = document.createElement('button');
    trigger.type = 'button';
    trigger.className = 'choice-option';
    trigger.textContent = title;
    const submenu = document.createElement('div');
    submenu.className = 'choice-submenu';
    trigger.addEventListener('click', (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      const willOpen = !wrap.classList.contains('is-open');
      const host = wrap.parentElement;
      if(host){
        host.querySelectorAll('.choice-sub.is-open').forEach((el) => {
          if(el !== wrap) el.classList.remove('is-open');
        });
      }
      wrap.classList.toggle('is-open', willOpen);
    });
    wrap.appendChild(trigger);
    wrap.appendChild(submenu);
    return { wrap, submenu };
  }

  function syncColorMenuOpenState(){
    const hasOpen = Boolean(document.querySelector('#step-colori .color-choice-dropdown.is-open'));
    document.body.classList.toggle('color-menu-open', hasOpen);
    const viewerEl = document.getElementById('viewer');
    if(viewerEl){
      viewerEl.classList.toggle('color-menu-open', hasOpen);
    }
  }
  function translateColorMenuLabel(label){
    const txt = String(label || '').trim();
    if(currentLang !== 'en') return txt;
    const map = {
      'Bianco': 'White',
      'Colori': 'Colors',
      'Verde acqua': 'Aquamarine',
      'Ciano': 'Cyan',
      'Lime': 'Lime',
      'Blu notte': 'Navy blue',
      'Blu elettrico': 'Electric blue',
      'Nero': 'Black',
      'Grigio': 'Gray',
      'Grigio fumo': 'Smoke gray',
      'Bronzo': 'Bronze',
      'Giallo sole': 'Sun yellow',
      'Arancione': 'Orange',
      'Rosso': 'Red',
      'Oliva': 'Olive',
      'Magenta': 'Magenta',
      'Salmone': 'Salmon',
      'Indaco': 'Indigo',
      'Miele': 'Honey',
      'Onda': 'Wave',
      'Carbonio': 'Carbon',
      'Mimetico': 'Camo',
      'Mimetico 2': 'Camo 2',
      'Onda verde': 'Greenwave',
      'Astratto': 'Abstract',
      'Laguna': 'Lagoon',
      'Foche': 'Seals',
      'Acido': 'Acid'
    };
    return map[txt] || txt;
  }

  function updateChoiceDropdownDirection(dropdown){
    if(!dropdown) return;
    if(window.matchMedia && window.matchMedia('(max-width: 900px)').matches){
      dropdown.classList.remove('open-up');
      return;
    }
    const menu = dropdown.querySelector('.choice-menu');
    if(!menu) return;
    dropdown.classList.remove('open-up');
    const prevDisplay = menu.style.display;
    const prevVisibility = menu.style.visibility;
    menu.style.visibility = 'hidden';
    menu.style.display = 'flex';
    const menuHeight = Math.min(menu.scrollHeight || 0, 360);
    menu.style.display = prevDisplay;
    menu.style.visibility = prevVisibility;
    const hostRect = dropdown.getBoundingClientRect();
    const spaceBelow = window.innerHeight - hostRect.bottom;
    const spaceAbove = hostRect.top;
    if(spaceBelow < (menuHeight + 12) && spaceAbove > spaceBelow){
      dropdown.classList.add('open-up');
    }
  }

  function renderGelcoatMenu(group, containerId, colors, wrappingOptions, ruggedOptions){
    const container = document.getElementById(containerId);
    if(!container) return;
    if(typeof container._choiceCleanup === 'function'){
      container._choiceCleanup();
      container._choiceCleanup = null;
    }
    container.innerHTML = '';

    const select = document.createElement('select');
    select.style.display = 'none';
    select.dataset.group = group;
    const placeholder = document.createElement('option');
    placeholder.textContent = 'Select';
    placeholder.value = '';
    placeholder.disabled = true;
    placeholder.selected = true;
    select.appendChild(placeholder);

    const whiteEntry = colors.find(c => ['white','bianco'].includes((c.label || '').toLowerCase()));
    if(whiteEntry){
      const opt = document.createElement('option');
      opt.textContent = translateColorMenuLabel(whiteEntry.label || 'Bianco');
      opt.value = whiteEntry.color || '#ffffff';
      select.appendChild(opt);
    }

    const colorEntries = colors.filter(c => !['white','bianco'].includes((c.label || '').toLowerCase()));
    colorEntries.forEach((entry) => {
      const opt = document.createElement('option');
      opt.textContent = translateColorMenuLabel(entry.label);
      opt.value = entry.color || '';
      select.appendChild(opt);
    });

    (wrappingOptions || []).forEach((entry) => {
      const opt = document.createElement('option');
      opt.textContent = translateColorMenuLabel(entry.label);
      opt.value = entry.color || '#ffffff';
      if(entry.texture) opt.dataset.texture = entry.texture;
      if(entry.scale) opt.dataset.scale = entry.scale;
      if(Number.isFinite(entry.scaleU)) opt.dataset.scaleU = String(entry.scaleU);
      if(Number.isFinite(entry.scaleV)) opt.dataset.scaleV = String(entry.scaleV);
      select.appendChild(opt);
    });

    (ruggedOptions || []).forEach((entry) => {
      const opt = document.createElement('option');
      opt.textContent = translateColorMenuLabel(entry.label);
      opt.value = entry.color || '';
      opt.dataset.rugged = '1';
      select.appendChild(opt);
    });

    const dropdown = document.createElement('div');
    dropdown.className = 'choice-dropdown color-choice-dropdown';
    const trigger = document.createElement('button');
    trigger.type = 'button';
    trigger.className = 'choice-btn trigger';
    trigger.textContent = 'Select';
    const menu = document.createElement('div');
    menu.className = 'choice-menu';
    dropdown.appendChild(trigger);
    dropdown.appendChild(menu);

    const optionButtons = new Map();
    const makeKey = (entry) => `${entry.label}|${entry.color || ''}|${entry.texture || ''}|${entry.scale || ''}|${entry.scaleU || ''}|${entry.scaleV || ''}|${entry.rugged ? '1' : '0'}`;
    const setSelected = (entry) => {
      optionButtons.forEach((btn) => btn.classList.remove('is-selected'));
      const key = makeKey(entry);
      const btn = optionButtons.get(key);
      if(btn) btn.classList.add('is-selected');
      trigger.textContent = entry.label || 'Select';
    };
    const pickEntry = (entry) => {
      const opts = Array.from(select.options || []);
      const target = opts.find((o) => {
        if((o.textContent || '').trim() !== (entry.label || '').trim()) return false;
        if((o.value || '') !== (entry.color || '')) return false;
        if((o.dataset.texture || '') !== (entry.texture || '')) return false;
        if((o.dataset.scale || '') !== String(entry.scale || '')) return false;
        if((o.dataset.scaleU || '') !== String(entry.scaleU || '')) return false;
        if((o.dataset.scaleV || '') !== String(entry.scaleV || '')) return false;
        const r = o.dataset.rugged ? '1' : '0';
        return r === (entry.rugged ? '1' : '0');
      });
      if(!target) return;
      const targetIndex = opts.indexOf(target);
      if(targetIndex >= 0){
        select.selectedIndex = targetIndex;
      }else{
        select.value = target.value;
      }
      setSelected(entry);
      select.dispatchEvent(new Event('change'));
      dropdown.classList.remove('is-open');
      dropdown.querySelectorAll('.choice-sub.is-open').forEach((el) => el.classList.remove('is-open'));
      syncColorMenuOpenState();
    };

    if(whiteEntry){
      const entry = { label: translateColorMenuLabel(whiteEntry.label || 'Bianco'), color: whiteEntry.color || '#ffffff' };
      const btn = createChoiceOption(entry.label, () => pickEntry(entry));
      optionButtons.set(makeKey(entry), btn);
      menu.appendChild(btn);
    }

    if(colorEntries.length){
      const sub = createChoiceSubmenu(translateColorMenuLabel('Colori'));
      const grid = document.createElement('div');
      grid.className = 'color-swatch-grid';
      colorEntries.forEach((entry) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'color-swatch-option';
        btn.title = translateColorMenuLabel(entry.label);
        btn.setAttribute('aria-label', translateColorMenuLabel(entry.label));
        btn.style.background = entry.color || '#ffffff';
        const sw = document.createElement('span');
        sw.className = 'swatch';
        btn.appendChild(sw);
        btn.addEventListener('click', (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          pickEntry({ label: translateColorMenuLabel(entry.label), color: entry.color || '' });
        });
        optionButtons.set(makeKey({ label: translateColorMenuLabel(entry.label), color: entry.color || '' }), btn);
        grid.appendChild(btn);
      });
      sub.submenu.appendChild(grid);
      menu.appendChild(sub.wrap);
    }

    if((wrappingOptions || []).length){
      const sub = createChoiceSubmenu('Wrapping');
      const grid = document.createElement('div');
      grid.className = 'texture-swatch-grid';
      wrappingOptions.forEach((entry) => {
        const optEntry = {
          label: translateColorMenuLabel(entry.label),
          color: entry.color || '#ffffff',
          texture: entry.texture || '',
          scale: entry.scale || '',
          scaleU: Number.isFinite(entry.scaleU) ? String(entry.scaleU) : '',
          scaleV: Number.isFinite(entry.scaleV) ? String(entry.scaleV) : ''
        };
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'texture-swatch-option';
        btn.title = translateColorMenuLabel(entry.label);
        btn.setAttribute('aria-label', translateColorMenuLabel(entry.label));
        if(entry.texture){
          btn.style.backgroundImage = `url('${entry.texture}')`;
        }
        btn.addEventListener('click', (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          pickEntry(optEntry);
        });
        optionButtons.set(makeKey({ ...optEntry, rugged: false }), btn);
        grid.appendChild(btn);
      });
      sub.submenu.appendChild(grid);
      menu.appendChild(sub.wrap);
    }

    if((ruggedOptions || []).length){
      const sub = createChoiceSubmenu('Rugged');
      const grid = document.createElement('div');
      grid.className = 'color-swatch-grid rugged-swatch-grid';
      ruggedOptions.forEach((entry) => {
        const optEntry = { label: translateColorMenuLabel(entry.label), color: entry.color || '', rugged: true };
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'color-swatch-option rugged-swatch-option';
        btn.title = translateColorMenuLabel(entry.label);
        btn.setAttribute('aria-label', translateColorMenuLabel(entry.label));
        btn.style.backgroundColor = entry.color || '#556B2F';
        btn.style.backgroundImage = "url('images/rugged.jpg')";
        btn.style.backgroundSize = 'cover';
        btn.style.backgroundPosition = 'center';
        btn.style.backgroundBlendMode = 'multiply';
        btn.addEventListener('click', (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          pickEntry(optEntry);
        });
        optionButtons.set(makeKey(optEntry), btn);
        grid.appendChild(btn);
      });
      sub.submenu.appendChild(grid);
      menu.appendChild(sub.wrap);
    }

    let isInit = true;
    select.addEventListener('change', () => {
      const opt = select.selectedOptions[0];
      if(!opt || !opt.value) return;
      const entry = {
        label: (opt.textContent || '').trim(),
        color: opt.value || '',
        texture: opt.dataset.texture || '',
        scale: opt.dataset.scale || '',
        scaleU: opt.dataset.scaleU || '',
        scaleV: opt.dataset.scaleV || '',
        rugged: Boolean(opt.dataset.rugged)
      };
      setSelected(entry);
      const proxyBtn = {
        textContent: entry.label,
        dataset: {
          texture: entry.texture,
          scale: entry.scale,
          scaleU: entry.scaleU,
          scaleV: entry.scaleV,
          rugged: entry.rugged ? '1' : ''
        }
      };
      setColorLabel(group, entry.label);
      if(group === 'hull') setHull(entry.color, proxyBtn);
      else if(group === 'deck') setDeck(entry.color, proxyBtn);
      else setHatches(entry.color, proxyBtn, group === 'hatches' && !isInit);
      isInit = false;
    });

    const onDocPointer = (ev) => {
      if(!dropdown.contains(ev.target)){
        dropdown.classList.remove('is-open');
        dropdown.querySelectorAll('.choice-sub.is-open').forEach((el) => el.classList.remove('is-open'));
        syncColorMenuOpenState();
      }
    };
    document.addEventListener('pointerdown', onDocPointer);
    container._choiceCleanup = () => {
      document.removeEventListener('pointerdown', onDocPointer);
    };
    trigger.addEventListener('click', (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      updateChoiceDropdownDirection(dropdown);
      dropdown.classList.toggle('is-open');
      dropdown.style.zIndex = dropdown.classList.contains('is-open') ? '5000' : '';
      if(!dropdown.classList.contains('is-open')){
        dropdown.querySelectorAll('.choice-sub.is-open').forEach((el) => el.classList.remove('is-open'));
      }
      syncColorMenuOpenState();
    });

    colorSelects[group] = select;
    container.appendChild(select);
    container.appendChild(dropdown);
  }

  function renderAntiskidSelect(){
    const container = document.getElementById('antiskid-select');
    if(!container) return;
    if(typeof container._choiceCleanup === 'function'){
      container._choiceCleanup();
      container._choiceCleanup = null;
    }
    container.innerHTML = '';
    const select = document.createElement('select');
    select.style.display = 'none';
    const placeholder = document.createElement('option');
    placeholder.textContent = 'Select';
    placeholder.value = '';
    placeholder.disabled = true;
    placeholder.selected = true;
    select.appendChild(placeholder);
    const dropdown = document.createElement('div');
    dropdown.className = 'choice-dropdown color-choice-dropdown antiskid-choice-dropdown';
    const trigger = document.createElement('button');
    trigger.type = 'button';
    trigger.className = 'choice-btn trigger';
    trigger.textContent = 'Select';
    const menu = document.createElement('div');
    menu.className = 'choice-menu';
    dropdown.appendChild(trigger);
    dropdown.appendChild(menu);
    const rebuildChoiceMenu = () => {
      menu.innerHTML = '';
      Array.from(select.options || []).forEach((opt) => {
        if(!opt.value) return;
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'choice-option';
        btn.textContent = opt.textContent || '';
        btn.addEventListener('click', (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          select.value = opt.value;
          select.dispatchEvent(new Event('change'));
          dropdown.classList.remove('is-open');
          syncColorMenuOpenState();
        });
        menu.appendChild(btn);
      });
      const selectedOpt = select.selectedOptions && select.selectedOptions[0];
      trigger.textContent = (selectedOpt && selectedOpt.value) ? (selectedOpt.textContent || 'Select') : 'Select';
    };
    select.addEventListener('change', () => {
      if(!select.value) return;
      selectedAntiskid = select.value;
        updateAntiskidFinish();
        updatePrice();
      const selectedOpt = select.selectedOptions && select.selectedOptions[0];
      trigger.textContent = (selectedOpt && selectedOpt.value) ? (selectedOpt.textContent || 'Select') : 'Select';
    });
    trigger.addEventListener('click', (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      updateChoiceDropdownDirection(dropdown);
      dropdown.classList.toggle('is-open');
      dropdown.style.zIndex = dropdown.classList.contains('is-open') ? '5000' : '';
      syncColorMenuOpenState();
    });
    const onDocPointer = (ev) => {
      if(!dropdown.contains(ev.target)){
        dropdown.classList.remove('is-open');
        syncColorMenuOpenState();
      }
    };
    document.addEventListener('pointerdown', onDocPointer);
    container._choiceCleanup = () => {
      document.removeEventListener('pointerdown', onDocPointer);
    };
    container._rebuildChoiceMenu = rebuildChoiceMenu;
    container.appendChild(select);
    container.appendChild(dropdown);
    updateAntiskidOptions(selectedFinish);
  }

      function resolveFinishMode(btn){
      if(btn?.dataset?.rugged) return 'rugged';
      if(btn?.dataset?.texture) return 'wrapping';
      const label = (btn?.textContent || '').trim().toLowerCase();
      if(label === 'white' || label === 'bianco') return 'white';
      return 'color';
    }

function updateAntiskidOptions(finish){
      const select = document.querySelector('#antiskid-select select');
      if(!select) return;
      const isEn = currentLang === 'en';
      const baseOptions = [
        { label: isEn ? 'None' : 'Nessuno', value: 'none' },
        { label: 'Eva', value: 'eva' },
        { label: isEn ? 'Painted' : 'Verniciato', value: 'paint' },
        { label: isEn ? 'Printed' : 'Stampato', value: 'print' }
      ];
      let allowed = baseOptions;
      if(finish === 'gelcoat' || finish === 'paint'){
        const mode = selectedDeckMode || 'color';
        if(mode === 'wrapping'){
          allowed = baseOptions.filter(o => o.value === 'none' || o.value === 'eva' || o.value === 'print');
        }else if(mode === 'rugged'){
          allowed = baseOptions.filter(o => o.value === 'none' || o.value === 'eva' || o.value === 'paint');
        }else{
          allowed = baseOptions;
        }
      }
      select.innerHTML = '';
      const placeholder = document.createElement('option');
      placeholder.textContent = 'Select';
      placeholder.value = '';
      placeholder.disabled = true;
      placeholder.selected = true;
      select.appendChild(placeholder);
      allowed.forEach(({ label, value }) => {
        const opt = document.createElement('option');
        opt.textContent = label;
        opt.value = value;
        select.appendChild(opt);
      });
      if(!allowed.some(opt => opt.value === selectedAntiskid)){
        selectedAntiskid = '';
      }
      select.value = selectedAntiskid || '';
      updateAntiskidFinish();
      const container = document.getElementById('antiskid-select');
      if(container && typeof container._rebuildChoiceMenu === 'function'){
        container._rebuildChoiceMenu();
      }
    }

  function updateColorOptions(finish){
    const palette = colorPalettes[finish] || colorPalettes.gelcoat;
    hullSelected = false;
    deckSelected = false;
    hatchesSelected = false;
    hatchesAuto = true;
    const groupHull = document.getElementById('group-hull');
    const groupDeck = document.getElementById('group-deck');
    const groupHatches = document.getElementById('group-hatches');
    if(finish === 'rugged'){
      if(groupDeck) groupDeck.classList.add('hidden');
      if(groupHatches) groupHatches.classList.add('hidden');
      if(groupHull) groupHull.classList.remove('hidden');
      renderColorSelect('hull', 'hull-colors', palette.all);
      renderColorSelect('deck', 'deck-colors', []);
      renderColorSelect('hatches', 'hatches-colors', []);
    }else if(finish === 'gelcoat' || finish === 'paint'){
      if(groupDeck) groupDeck.classList.remove('hidden');
      if(groupHatches) groupHatches.classList.remove('hidden');
      if(groupHull) groupHull.classList.remove('hidden');
      const wrapPalette = colorPalettes.wrapping || {};
      const ruggedPalette = finish === 'gelcoat' ? [] : (colorPalettes.rugged?.all || []);
      renderGelcoatMenu('hull', 'hull-colors', palette.hull, wrapPalette.hull || [], ruggedPalette);
      renderGelcoatMenu('deck', 'deck-colors', palette.deck, wrapPalette.deck || [], ruggedPalette);
      renderGelcoatMenu('hatches', 'hatches-colors', palette.hatches, wrapPalette.hatches || [], ruggedPalette);
    }else{
      if(groupDeck) groupDeck.classList.remove('hidden');
      if(groupHatches) groupHatches.classList.remove('hidden');
      if(groupHull) groupHull.classList.remove('hidden');
      renderColorSelect('hull', 'hull-colors', palette.hull);
      renderColorSelect('deck', 'deck-colors', palette.deck);
      renderColorSelect('hatches', 'hatches-colors', palette.hatches);
    }
    updateAntiskidOptions(finish);
  }

  function findColorOptionByState(select, state){
    if(!select || !state) return null;
    const opts = Array.from(select.options || []);
    return opts.find((o) => {
      if((o.value || '') !== (state.value || '')) return false;
      if((o.dataset.texture || '') !== (state.texture || '')) return false;
      if((o.dataset.scale || '') !== (state.scale || '')) return false;
      if((o.dataset.scaleU || '') !== (state.scaleU || '')) return false;
      if((o.dataset.scaleV || '') !== (state.scaleV || '')) return false;
      const r = o.dataset.rugged ? '1' : '0';
      return r === (state.rugged || '0');
    }) || null;
  }

  function refreshColorMenusForLanguage(){
    if(!selectedFinish) return;
    const groups = ['hull', 'deck', 'hatches'];
    const snapshot = {};
    groups.forEach((group) => {
      const sel = colorSelects[group];
      const opt = sel?.selectedOptions?.[0];
      if(!opt || !opt.value) return;
      snapshot[group] = {
        value: opt.value || '',
        texture: opt.dataset.texture || '',
        scale: opt.dataset.scale || '',
        scaleU: opt.dataset.scaleU || '',
        scaleV: opt.dataset.scaleV || '',
        rugged: opt.dataset.rugged ? '1' : '0'
      };
    });
    const antiskidSnapshot = selectedAntiskid || 'none';

    updateColorOptions(selectedFinish);

    groups.forEach((group) => {
      const state = snapshot[group];
      if(!state) return;
      const sel = colorSelects[group];
      const match = findColorOptionByState(sel, state);
      if(!sel || !match) return;
      sel.selectedIndex = Array.from(sel.options).indexOf(match);
      sel.dispatchEvent(new Event('change'));
    });

    const antiskidSel = document.querySelector('#antiskid-select select');
    if(antiskidSel && Array.from(antiskidSel.options || []).some((o) => o.value === antiskidSnapshot)){
      antiskidSel.value = antiskidSnapshot;
      antiskidSel.dispatchEvent(new Event('change'));
    }
  }

  function applyAntiskid(mat, color){
    if(!mat) return;
    if(!antiskidTexture){
      mat.color.set(color);
      mat.needsUpdate = true;
      antiskidTexture = textureLoader.load('images/antiskid.jpg', (t) => {
        t.wrapS = t.wrapT = THREE.RepeatWrapping;
        t.repeat.set(tileU(0.8), tileV(0.8));
        t.colorSpace = THREE.SRGBColorSpace;
        t.flipY = false;
        mat.map = t;
        mat.color.set(color);
        mat.needsUpdate = true;
      });
      return;
    }
    mat.map = antiskidTexture;
    mat.color.set(color);
    mat.needsUpdate = true;
  }
  function applyRuggedTexture(mat, color){
    if(!mat) return;
    if(!ruggedTexture){
      ruggedTexture = textureLoader.load('images/rugged.jpg', (t) => {
        t.wrapS = t.wrapT = THREE.RepeatWrapping;
        t.repeat.set(tileU(2), tileV(2));
        t.colorSpace = THREE.SRGBColorSpace;
        t.flipY = false;
        t.needsUpdate = true;
        applyRuggedTexture(mat, color);
      });
      return;
    }
    mat.map = ruggedTexture;
    mat.userData.baseMap = ruggedTexture;
    mat.color.set(color);
    if('metalness' in mat) mat.metalness = 0;
    if('roughness' in mat) mat.roughness = 1;
    if('vertexColors' in mat) mat.vertexColors = false;
    mat.needsUpdate = true;
  }

  function applyAntiskidVariant(mat, color, mode){
    if(!mat) return;
    if(mode === 'paint'){
      applyAntiskid(mat, color);
      return;
    }
    applyAntiskid(mat, color);
  }

    function applyEvaTextureToMeshes(meshes){
    if(!meshes?.length) return;
    const applyTexture = (tex) => {
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(tileU(0.4), tileV(0.4));
        tex.center.set(0.5, 0.5);
        tex.rotation = Math.PI / 2;
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.flipY = false;
      tex.needsUpdate = true;
      meshes.forEach((mesh) => {
        if(!mesh) return;
        ensurePlanarUv(mesh);
        const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
        materials.forEach((mat) => {
          if(!mat) return;
          mat.map = tex;
          if(mat.color) mat.color.set('#ffffff');
          if('metalness' in mat) mat.metalness = 0;
          if('roughness' in mat) mat.roughness = 1;
          mat.needsUpdate = true;
        });
      });
    };
    if(antiskidEvaTexture){
      applyTexture(antiskidEvaTexture);
      return;
    }
    antiskidEvaTexture = textureLoader.load('images/teak.jpg', (t) => {
      applyTexture(t);
    });
  }

  
    function applyPaintTextureToMeshes(meshes, color){
      if(!meshes?.length) return;
      const applyTexture = (tex) => {
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(tileU(1), tileV(1));
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.flipY = false;
        tex.needsUpdate = true;
        meshes.forEach((mesh) => {
          if(!mesh) return;
          ensurePlanarUv(mesh);
          const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
          materials.forEach((mat) => {
            if(!mat) return;
            mat.map = tex;
            if(mat.color) mat.color.set(color || '#ffffff');
            if('metalness' in mat) mat.metalness = 0;
            if('roughness' in mat) mat.roughness = 1;
            mat.needsUpdate = true;
          });
        });
      };
      if(antiskidTexture){
        applyTexture(antiskidTexture);
        return;
      }
      antiskidTexture = textureLoader.load('images/antiskid.jpg', (t) => {
        applyTexture(t);
      });
    }

function applyChirpTextureToMeshes(){
    if(!chirpMeshes.length || !chirpTexture) return;
    chirpMeshes.forEach((mesh) => {
      if(!mesh?.material) return;
      const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
      materials.forEach((mat) => {
        if(!mat) return;
        mat.map = chirpTexture;
        if(mat.color) mat.color.set('#ffffff');
        mat.transparent = true;
        mat.alphaTest = 0.5;
        mat.polygonOffset = true;
        mat.polygonOffsetFactor = -1;
        mat.polygonOffsetUnits = -1;
        mat.needsUpdate = true;
      });
      mesh.renderOrder = 2;
    });
  }

  function ensurePlanarUv(mesh, axis = 'xz', uniform = true){
    const geom = mesh?.geometry;
    if(!geom || geom.attributes?.uv) return;
    geom.computeBoundingBox();
    const box = geom.boundingBox;
    if(!box) return;
    const size = new THREE.Vector3();
    box.getSize(size);
    const pos = geom.attributes.position;
    const uvs = new Float32Array(pos.count * 2);
    const sizeX = size.x || 1;
    const sizeY = size.y || 1;
    const sizeZ = size.z || 1;
    const denomU = uniform ? Math.max(sizeX, axis === 'xy' ? sizeY : sizeZ) : (axis === 'xy' ? sizeX : sizeX);
    const denomV = uniform ? Math.max(sizeX, axis === 'xy' ? sizeY : sizeZ) : (axis === 'xy' ? sizeY : sizeZ);
    for(let i = 0; i < pos.count; i++){
      const x = pos.getX(i);
      const y = pos.getY(i);
      const z = pos.getZ(i);
      let u = 0;
      let v = 0;
      if(axis === 'xy'){
        u = denomU ? (x - box.min.x) / denomU : 0;
        v = denomV ? (y - box.min.y) / denomV : 0;
      }else{
        u = denomU ? (x - box.min.x) / denomU : 0;
        v = denomV ? (z - box.min.z) / denomV : 0;
      }
      uvs[i * 2] = u;
      uvs[i * 2 + 1] = v;
    }
    geom.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
    geom.attributes.uv.needsUpdate = true;
  }

  function applyPrintTextureToMeshes(meshes, color){
    if(!meshes?.length) return;
    const applyTexture = (tex) => {
      tex.repeat.set(tileU(5), tileV(5));
      tex.needsUpdate = true;
      meshes.forEach((mesh) => {
        if(!mesh) return;
        ensurePlanarUv(mesh);
        const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
        materials.forEach((mat) => {
          if(!mat) return;
          mat.map = tex;
          if(mat.color) mat.color.set(color || '#ffffff');
          if('metalness' in mat) mat.metalness = 0;
          if('roughness' in mat) mat.roughness = 1;
          mat.needsUpdate = true;
        });
      });
    };
    if(antiskidPrintTexture){
      antiskidPrintTexture.repeat.set(tileU(5), tileV(5));
      antiskidPrintTexture.needsUpdate = true;
      applyTexture(antiskidPrintTexture);
      return;
    }
    antiskidPrintTexture = textureLoader.load('images/millepunte2.jpg', (t) => {
      t.wrapS = t.wrapT = THREE.RepeatWrapping;
      t.repeat.set(tileU(5), tileV(5));
      t.colorSpace = THREE.SRGBColorSpace;
      t.flipY = false;
      t.needsUpdate = true;
      applyTexture(t);
    });
  }

  function updateAntiskidEvaMeshes(){
      const isEva = selectedAntiskid === 'eva';
      const isPrint = selectedAntiskid === 'print';
      const isPaint = selectedAntiskid === 'paint';
      const shouldShow = isEva || isPrint || isPaint;
      antiskidEvaMeshes.forEach(mesh => {
        mesh.visible = shouldShow;
      });
      if(isEva){
        applyEvaTextureToMeshes(antiskidEvaMeshes);
      }
      if(isPrint){
        applyPrintTextureToMeshes(antiskidEvaMeshes, selectedDeck || '#ffffff');
      }
      if(isPaint){
        applyPaintTextureToMeshes(antiskidEvaMeshes, selectedDeck || '#ffffff');
      }
    }

    function syncSchienaleMaterial(){
    if(!schienaleMeshes.length || !hatchesMat) return;
    schienaleMeshes.forEach((mesh) => {
      if(!mesh) return;
      if(mesh.material === hatchesMat || !mesh.material){
        mesh.material = hatchesMat?.clone?.() || mesh.material;
      }
      const mat = mesh.material;
      if(!mat) return;
      mat.color.copy(hatchesMat.color);
      mat.map = hatchesMat.map || null;
      mat.userData.baseMap = hatchesMat.userData?.baseMap || null;
      mat.normalMap = null;
      mat.roughnessMap = null;
      mat.metalnessMap = null;
      if('metalness' in mat) mat.metalness = 0;
      if('roughness' in mat) mat.roughness = 1;
      mat.needsUpdate = true;
    });
  }

  function syncTrollingMaterial(){
    const allTrolling = [...trollingMeshes, ...trollingDeployMeshes];
    if(!allTrolling.length) return;
    allTrolling.forEach((mesh) => {
      if(!mesh) return;
      if(!mesh.userData?.trollingFixed){
        mesh.material = mesh.material?.clone?.() || mesh.material;
        mesh.userData.trollingFixed = true;
      }
      const mat = mesh.material;
      if(!mat) return;
      mat.normalMap = null;
      mat.roughnessMap = null;
      mat.metalnessMap = null;
      if('metalness' in mat) mat.metalness = 0;
      if('roughness' in mat) mat.roughness = 1;
      mat.needsUpdate = true;
    });
  }

  function updateAntiskidFinish(){
      updateAntiskidEvaMeshes();
      if(selectedFinish === 'wrapping') return;
      if(!selectedAntiskid || selectedAntiskid === 'none') return;
      if(selectedAntiskid === 'eva' || selectedAntiskid === 'print' || selectedAntiskid === 'paint') return;
      if(selectedDeck) applyAntiskidVariant(deckMat, selectedDeck, selectedAntiskid);
      if(selectedHatches) applyAntiskidVariant(hatchesMat, selectedHatches, selectedAntiskid);
      syncSchienaleMaterial();
    }

    function applyWrappingTextureFor(mat, texturePath, scale, scaleU, scaleV){
    if(!mat) return;
    if(texturePath){
      mat.color.set('#ffffff');
      textureLoader.load(texturePath, (t) => {
        t.wrapS = t.wrapT = THREE.RepeatWrapping;
        const s = Number.isFinite(scale) && scale > 0 ? scale : 2;
        const su = Number.isFinite(scaleU) && scaleU > 0 ? scaleU : s;
        const sv = Number.isFinite(scaleV) && scaleV > 0 ? scaleV : s;
        t.repeat.set(tileU(su), tileV(sv));
        mat.map = t;
        mat.needsUpdate = true;
      });
    }else{
      mat.map = null;
      mat.needsUpdate = true;
    }
  }

  function isDarkColor(hex){
    if(!hex || typeof hex !== 'string') return false;
    const cleaned = hex.replace('#', '');
    if(cleaned.length !== 6) return false;
    const r = parseInt(cleaned.slice(0, 2), 16);
    const g = parseInt(cleaned.slice(2, 4), 16);
    const b = parseInt(cleaned.slice(4, 6), 16);
    const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b);
    return luminance < 80;
  }

  function isWrappingWhiteTrigger(texturePath){
    if(!texturePath) return false;
    const name = texturePath.toLowerCase();
    return name.includes('carbon') || name.includes('greenwave') || name.includes('abstract');
  }

  function updateLogoAndBottazzo(){
    const makeWhite = wrappingWhite || hullDark;
    const color = makeWhite ? '#FFFFFF' : '#000000';
    if(bottazzoMat){
      if(bottazzoMat.map){
        bottazzoMat.map = null;
      }
      bottazzoMat.color.set(color);
      bottazzoMat.needsUpdate = true;
    }
    if(scrittaMats.length){
      const tex = makeWhite ? scrittaTextures.white : scrittaTextures.black;
      if(tex){
        applyScrittaAppearance(tex, '#ffffff');
      }else{
        const texPath = makeWhite ? 'images/Scritta_white.png' : 'images/Scritta_black.png';
        textureLoader.load(texPath, (t) => {
          applyScrittaAppearance(t, '#ffffff');
        });
      }
    }
  }

  window.selectFinitura = function(f, btn, autoNext = true) {
    setActiveColor('finish', btn);
    finishSelected = true;
    selectedFinish = f;
    resetColorsToBase();
    updateColorOptions(f);
    applyStandardColorDefaults();
    updateAntiskidFinish();
    updatePrice();
    if(autoNext && currentStep === 'finitura') showStep('colori');
  };

  function applyStandardColorDefaults(){
    const pickDefault = (group) => {
      const select = colorSelects[group];
      if(!select) return;
      const options = Array.from(select.options || []).filter((opt) => Boolean(opt.value));
      if(!options.length) return;
      const target = options.find((opt) => {
        const value = String(opt.value || '').toLowerCase();
        const label = String(opt.textContent || '').trim().toLowerCase();
        return value === '#ffffff' || label === 'bianco' || label === 'white';
      }) || options[0];
      select.value = target.value;
      select.dispatchEvent(new Event('change'));
    };

    pickDefault('hull');
    pickDefault('deck');
    pickDefault('hatches');

    selectedAntiskid = 'none';
    const antiskidSel = document.querySelector('#antiskid-select select');
    if(antiskidSel){
      antiskidSel.value = 'none';
      antiskidSel.dispatchEvent(new Event('change'));
    }else{
      updateAntiskidFinish();
    }
  }

  function resetColorsToBase(){
    hullSelected = false;
    deckSelected = false;
    hatchesSelected = false;
    hatchesAuto = true;
    selectedHull = null;
    selectedDeck = null;
    selectedHatches = null;
    if(hullMat){
      hullMat.map = null;
      hullMat.color.set('#ffffff');
      hullMat.needsUpdate = true;
    }


    
    if(deckMat){
      deckMat.map = null;
      deckMat.color.set('#ffffff');
      deckMat.needsUpdate = true;
    }
    if(hatchesMat){
      hatchesMat.map = null;
      hatchesMat.color.set('#ffffff');
      hatchesMat.needsUpdate = true;
    }
    wrappingWhite = false;
    hullDark = false;
    deckDark = false;
    selectedAntiskid = 'none';
    const antiskidSelect = document.querySelector('#antiskid-select select');
    if(antiskidSelect){
      antiskidSelect.value = 'none';
    }
    updateAntiskidFinish();
    updateLogoAndBottazzo();
  }

  function resetAllConfig(){
        finishSelected = false;
        selectedFinish = null;
        accessoriUnlocked = false;
        selectedHullMode = null;
        selectedDeckMode = null;
        selectedHatchesMode = null;
        unlockConfigurator();
        resetColorsToBase();
        resetAccessoryUI();
        updateAccessoryRules();
        const finishSelect = document.querySelector('#finish-select select');
        if(finishSelect) finishSelect.value = '';
        const antiskidSelect = document.querySelector('#antiskid-select select');
        if(antiskidSelect) antiskidSelect.value = '';
        updatePrice();
        if(deckTransparent){
          setDeckTransparency(false);
        }
      }


    


  function setActiveColor(group, btn){
    if(!btn) return;
    document.querySelectorAll(`button[data-group="${group}"]`).forEach(b => {
      b.classList.toggle('active', b === btn);
    });
  }

  
    function selectOptionByLabel(select, label){
      if(!select) return;
      const opts = Array.from(select.options || []);
      const target = opts.find(o => (o.textContent || '').trim().toLowerCase() === label.toLowerCase());
      if(target){
        select.value = target.value;
        select.dispatchEvent(new Event('change'));
      }
    }
    function selectColorByState(group, cfg = {}){
      const sel = colorSelects[group];
      if(!sel) return false;
      const desiredValue = String(cfg.value || '');
      const desiredTexture = String(cfg.texture || '');
      const desiredRugged = cfg.rugged ? '1' : '0';
      const opts = Array.from(sel.options || []);
      const target = opts.find((opt) => {
        if(!opt.value) return false;
        if(desiredValue && String(opt.value || '').toLowerCase() !== desiredValue.toLowerCase()) return false;
        if(String(opt.dataset.texture || '') !== desiredTexture) return false;
        const r = opt.dataset.rugged ? '1' : '0';
        return r === desiredRugged;
      });
      if(!target) return false;
      sel.selectedIndex = opts.indexOf(target);
      sel.dispatchEvent(new Event('change'));
      return true;
    }

    function lockConfigurator(){
      presetLocked = true;
      const finishSelect = document.querySelector('#finish-select select');
      if(finishSelect) finishSelect.disabled = true;
      document.querySelectorAll('#step-colori select').forEach(sel => sel.disabled = true);
      const antiskidSel = document.querySelector('#antiskid-select select');
      if(antiskidSel) antiskidSel.disabled = true;
    }

    function unlockConfigurator(){
      presetLocked = false;
      presetName = '';
      const finishSelect = document.querySelector('#finish-select select');
      if(finishSelect) finishSelect.disabled = false;
      document.querySelectorAll('#step-colori select').forEach(sel => sel.disabled = false);
      const antiskidSel = document.querySelector('#antiskid-select select');
      if(antiskidSel) antiskidSel.disabled = false;
    }


    function applyPresetConfig(name){
      presetName = name;
      accessoriUnlocked = true;
      resetAccessoryUI();
      if(name === 'nico'){
        selectFinitura('paint', null, false);
      }else if(name === 'gabry'){
        selectFinitura('gelcoat', null, false);
      }

      const applyChoices = () => {
        if(name === 'nico'){
          // Nico: Acrilico, Hull nero, Deck/Doors rugged acido, antiskid verniciato.
          selectColorByState('hull', { value: '#000000' });
          selectColorByState('deck', { value: '#7FFF00', rugged: true });
          selectColorByState('hatches', { value: '#7FFF00', rugged: true });
          selectedAntiskid = 'paint';
        }else if(name === 'gabry'){
          // Gabry: Gelcoat, Hull aquamarine, Deck/Doors white, antiskid eva.
          selectColorByState('hull', { value: '#7FFFD4' });
          selectColorByState('deck', { value: '#ffffff' });
          selectColorByState('hatches', { value: '#ffffff' });
          selectedAntiskid = 'eva';
        }
        const antiskidSel = document.querySelector('#antiskid-select select');
        if(antiskidSel){
          antiskidSel.value = selectedAntiskid || '';
          antiskidSel.dispatchEvent(new Event('change'));
        }
        updateAntiskidFinish();
        updatePrice();

        if(name === 'nico'){
          ['tientibene', 'panca', 'schienale', 'supporto'].forEach((key) => {
            setAccessoryChecked(key, true, true);
          });
        }else if(name === 'gabry'){
          document.querySelectorAll('#step-accessori input[data-accessory]').forEach((input) => {
            const key = input.getAttribute('data-accessory');
            if(!key) return;
            setAccessoryChecked(key, key !== 'motore', true);
          });
        }
        updateAccessoryRules();
        updatePrice();
        lockConfigurator();
        accessoriUnlocked = true;
        setTimeout(() => showStep('accessori'), 0);
      };

      setTimeout(applyChoices, 0);
    }

function renderFinishSelect(){
    const container = document.getElementById('finish-select');
    if(!container) return;
    container.innerHTML = '';
    const select = document.createElement('select');
    const placeholder = document.createElement('option');
    placeholder.textContent = 'Select';
    placeholder.value = '';
    placeholder.disabled = true;
    placeholder.selected = true;
    select.appendChild(placeholder);
    const options = [
        { label: 'GELCOAT', value: 'gelcoat' },
        { label: 'ACRILICO', value: 'paint' },
        { label: 'NICO (Acrilico)', value: 'nico' },
        { label: 'GABRY (Gelcoat)', value: 'gabry' }
      ];
    options.forEach(({ label, value }) => {
        const opt = document.createElement('option');
        opt.textContent = label;
        opt.value = value;
        if(value === 'nico') opt.style.color = '#00ff00';
        if(value === 'gabry') opt.style.color = '#3aa7ff';
        select.appendChild(opt);
      });
    select.addEventListener('change', () => {
        if(!select.value) return;
        if(select.value === 'nico' || select.value === 'gabry'){
          applyPresetConfig(select.value);
          setTimeout(() => {
            if(currentStep !== 'accessori') showStep('accessori');
          }, 0);
          return;
        }
        selectFinitura(select.value, null, true);
      });
    container.appendChild(select);
  }

  window.setHull = function(color, btn){
      selectedHullMode = resolveFinishMode(btn);
    if(btn?.dataset?.texture){
      applyWrappingTextureFor(
        hullMat,
        btn.dataset.texture,
        Number.parseFloat(btn.dataset.scale),
        Number.parseFloat(btn.dataset.scaleU),
        Number.parseFloat(btn.dataset.scaleV)
      );
      wrappingWhite = isWrappingWhiteTrigger(btn.dataset.texture);
      hullDark = false;
    }else if(btn?.dataset?.rugged){
      applyRuggedTexture(hullMat, color);
      hullDark = isDarkColor(color);
      wrappingWhite = false;
    }else if(selectedFinish === 'rugged'){
      applyAntiskid(hullMat, color);
      applyAntiskid(deckMat, color);
      applyAntiskid(hatchesMat, color);
      hullDark = isDarkColor(color);
      deckDark = hullDark;
      wrappingWhite = false;
      deckSelected = true;
      hatchesSelected = true;
      selectedDeck = color;
      selectedHatches = color;
    }else if(hullMat){
      hullMat.map = null;
      hullMat.color.set(color);
      hullMat.needsUpdate = true;
      hullDark = isDarkColor(color);
      wrappingWhite = false;
    }
    hullSelected = true;
    selectedHull = color;
    checkStep();
    updateLogoAndBottazzo();
      updatePrice();
  }
  window.setDeck = function(color, btn){
      selectedDeckMode = resolveFinishMode(btn);
    if(btn?.dataset?.texture){
      applyWrappingTextureFor(
        deckMat,
        btn.dataset.texture,
        Number.parseFloat(btn.dataset.scale),
        Number.parseFloat(btn.dataset.scaleU),
        Number.parseFloat(btn.dataset.scaleV)
      );
      wrappingWhite = isWrappingWhiteTrigger(btn.dataset.texture);
      deckDark = false;
    }else if(btn?.dataset?.rugged){
      applyRuggedTexture(deckMat, color);
      deckDark = isDarkColor(color);
      wrappingWhite = false;
    }else if(deckMat){
      if(deckMat.userData?.compositeMap){
        deckMat.userData.compositeMap.dispose();
        deckMat.userData.compositeMap = null;
      }
      deckMat.userData.baseMap = null;
      deckMat.map = null;
      deckMat.color.set(color);
      deckMat.needsUpdate = true;
      deckDark = isDarkColor(color);
      wrappingWhite = false;
    }
    deckSelected = true;
    selectedDeck = color;
      updateAntiskidOptions(selectedFinish);
    checkStep();
    updateLogoAndBottazzo();
      updatePrice();
    if(hatchesAuto){
      setHatches(color, btn, false);
      if(btn?.textContent) setColorLabel('hatches', btn.textContent);
      if(selectedFinish === 'gelcoat' && btn?.textContent && gelcoatTriggers?.hatches){
        gelcoatTriggers.hatches.textContent = btn.textContent;
      }
      const hSelect = colorSelects.hatches;
      if(hSelect){
        if(btn?.dataset.texture){
          const match = Array.from(hSelect.options).find(opt => opt.dataset.texture === btn.dataset.texture);
          if(match){
            hSelect.value = match.value;
          }
        }else{
          hSelect.value = color;
        }
      }
    }
  };

  window.setHatches = function(color, btn, manual = true){
      selectedHatchesMode = resolveFinishMode(btn);
    if(btn?.textContent) setColorLabel('hatches', btn.textContent);
    if(btn?.dataset?.texture){
      applyWrappingTextureFor(
        hatchesMat,
        btn.dataset.texture,
        Number.parseFloat(btn.dataset.scale),
        Number.parseFloat(btn.dataset.scaleU),
        Number.parseFloat(btn.dataset.scaleV)
      );
    }else if(btn?.dataset?.rugged){
      applyRuggedTexture(hatchesMat, color);
    }else if(hatchesMat){
      if(hatchesMat.userData?.compositeMap){
        hatchesMat.userData.compositeMap.dispose();
        hatchesMat.userData.compositeMap = null;
      }
      hatchesMat.userData.baseMap = null;
      hatchesMat.map = null;
      hatchesMat.color.set(color);
      hatchesMat.needsUpdate = true;
    }
    hatchesSelected = true;
    selectedHatches = color;
    updateAntiskidFinish();
      updatePrice();
    checkStep();
    if(manual) hatchesAuto = false;
  };;;;

  window.setBottazzoColor = function(color){
    if(bottazzoMat){
      bottazzoMat.color.set(color);
      bottazzoMat.needsUpdate = true;
    }
  };

  window.setScrittaColor = function(color){
    scrittaMats.forEach((mat) => {
      if(!mat?.color) return;
      mat.color.set(color);
      mat.needsUpdate = true;
    });
  };
  function checkStep(){
    if(hullSelected && deckSelected && hatchesSelected && currentStep === 'colori'){
      accessoriUnlocked = true;
    }
  }

  window.goBack = function(){
      const accessoriEl = document.getElementById('step-accessori');
      const accessoriVisible = accessoriEl && accessoriEl.offsetParent !== null && accessoriEl.getClientRects().length > 0;
      const titleEl = document.getElementById('step-title');
      const titleText = titleEl ? (titleEl.textContent || '').trim().toLowerCase() : '';
      const stepForBack = titleText === 'accessori' ? 'accessori' : (accessoriVisible ? 'accessori' : currentStep);
      const finishSel = selectedFinish || (document.querySelector('#finish-select select') && document.querySelector('#finish-select select').value) || '';

      if(stepForBack === 'accessori'){
        if(presetLocked || presetName){
          unlockConfigurator();
          accessoriUnlocked = false;
          resetAllConfig();
          showStep('finitura');
          return;
        }
        showStep('colori');
        return;
      }
      if(stepForBack === 'colori'){
        resetAllConfig();
        showStep('finitura');
      }
    };
  window.goNext = function(){
    if(currentStep === 'finitura'){
      if(!finishSelected) return;
      showStep('colori');
      return;
    }
    if(currentStep === 'colori'){
        const hasSelectValues = Boolean(colorSelects.hull?.value) && Boolean(colorSelects.deck?.value) && Boolean(colorSelects.hatches?.value);
        if(!(hullSelected && deckSelected && hatchesSelected) && !hasSelectValues) return;
        if(hasSelectValues){
          hullSelected = true;
          deckSelected = true;
          hatchesSelected = true;
        }
        accessoriUnlocked = true;
        showStep('accessori');
        return;
      }
    if(currentStep === 'accessori'){
      triggerOrderFlow();
      return;
    }
  };
  window.toggleAccessory = function(name,state, silent = false){
    if(accessories[name]) accessories[name].visible=state;
    if(accessoryGroups[name]) accessoryGroups[name].forEach(obj => obj.visible = state);
    if(name === 'schienale' && state){
      syncSchienaleMaterial();
    }
    if(name === 'trolling'){
      syncTrollingMaterial();
      trollingDeployed = false;
      trollingMeshes.forEach((m) => m.visible = Boolean(state));
      trollingDeployMeshes.forEach((m) => m.visible = false);
      if(modelRoot){
        applyMaterialOverrides(modelRoot);
        applyChirpTextureToMeshes();
      }
    }
    if(!silent){
      const sfx = state ? sounds.on : sounds.off;
      if(sfx){
        if(audioEnabled && !audioUnlocked){
          audioUnlocked = true;
        }
        sfx.currentTime = 0;
        sfx.play().catch(() => {});
      }
      unlockAudio();
    }
    updatePrice();
    updateAccessoryRules();
    updatePrice();
  };

  // Prepared for interactive control: swaps base trolling with deploy variant.
  window.setTrollingDeployState = function(deployed){
    const baseVisible = Boolean(document.querySelector('#step-accessori input[data-accessory="trolling"]')?.checked);
    if(!baseVisible){
      trollingDeployed = false;
      trollingMeshes.forEach((m) => m.visible = false);
      trollingDeployMeshes.forEach((m) => m.visible = false);
      return;
    }
    trollingDeployed = Boolean(deployed);
    trollingMeshes.forEach((m) => m.visible = !deployed);
    trollingDeployMeshes.forEach((m) => m.visible = deployed);
  };

  function tryToggleTrollingDeployFromPointer(event){
    if(currentStep !== 'accessori') return false;
    const trollingChecked = Boolean(document.querySelector('#step-accessori input[data-accessory="trolling"]')?.checked);
    if(!trollingChecked) return false;
    const rect = renderer.domElement.getBoundingClientRect();
    if(!rect.width || !rect.height) return false;
    pointerNdc.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    pointerNdc.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    const candidates = [...trollingMeshes, ...trollingDeployMeshes].filter(Boolean);
    if(!candidates.length) return false;
    raycaster.setFromCamera(pointerNdc, camera);
    const hits = raycaster.intersectObjects(candidates, false);
    if(!hits.length) return false;
    window.setTrollingDeployState(!trollingDeployed);
    return true;
  }

  function updateInteractHint(){
    if(!interactHint) return;
    interactHint.style.display = 'none';
  }

  function updateRxButtonState(){
    const btn = document.getElementById('rx-btn');
    if(!btn) return;
    const show = currentStep === 'accessori';
    btn.style.display = show ? 'inline-block' : 'none';
    btn.classList.toggle('is-active', show && deckTransparent);
    btn.setAttribute('aria-pressed', String(show && deckTransparent));
  }

  function setDeckTransparency(enabled){
    const next = Boolean(enabled);
    if(deckTransparent === next){
      updateRxButtonState();
      return;
    }
    deckTransparent = next;
    const setMat = (mat) => {
      if(!mat) return;
      mat.transparent = next;
      mat.opacity = next ? 0.18 : 1;
      mat.depthWrite = !next;
      mat.needsUpdate = true;
    };
    setMat(deckMat);
    setMat(hatchesMat);

    const antiskidSel = document.querySelector('#antiskid-select select');
    if(next){
      deckRxSavedAntiskid = selectedAntiskid || 'none';
      selectedAntiskid = 'none';
      if(antiskidSel){
        antiskidSel.value = 'none';
        antiskidSel.disabled = true;
      }
      updateAntiskidFinish();
    }else{
      if(antiskidSel) antiskidSel.disabled = false;
      selectedAntiskid = deckRxSavedAntiskid || 'none';
      if(antiskidSel) antiskidSel.value = selectedAntiskid;
      updateAntiskidFinish();
    }
    updatePrice();
    updateRxButtonState();
  }

  function toggleDeckTransparency(){
    setDeckTransparency(!deckTransparent);
  }


  window.resetAllAccessories = function(){
    resetAccessoryUI();
  };

    let currentOrderId = null;
  let lastScreenshotDataUrl = null;
  let lastPresetScreenshots = [];
  

  function generateOrderId(){
    const rand = Math.floor(Math.random() * 1e6).toString().padStart(6, '0');
    return `NS-${Date.now()}-${rand}`;
  }

    function getAccessoriesSummary(){
    const dict = I18N[currentLang] || I18N.it;
    const accMap = dict.acc || {};
    const items = [];
    document.querySelectorAll('#step-accessori input[type="checkbox"]')?.forEach((cb) => {
      if(cb.checked){
        const key = cb.dataset.accessory;
        const label = (key && accMap[key]) || cb.closest('label')?.textContent?.trim() || key;
        if(label) items.push(label);
      }
    });
    return items.length ? items.join(', ') : (currentLang === 'en' ? 'None' : 'Nessuno');
  }
    function getSelectedAccessoriesDetailed(){
    const dict = I18N[currentLang] || I18N.it;
    const accMap = dict.acc || {};
    const antiskidTitle = currentLang === 'en' ? 'Antiskid' : 'Antiscivolo';
    const isChecked = (name) =>
      document.querySelector(`#step-accessori input[data-accessory="${name}"]`)?.checked;
    const isVisible = (name) =>
      accessories[name]?.visible ||
      (accessoryGroups[name] && accessoryGroups[name].some(obj => obj.visible));
    const isSelected = (name) => Boolean(isChecked(name) || isVisible(name));
    const order = [
      { key: 'antiskid', label: antiskidTitle },
      { key: 'tientibene', label: accMap.tientibene || 'Tientibene' },
      { key: 'panca', label: accMap.panca || 'Panca' },
      { key: 'schienale', label: accMap.schienale || 'Schienale' },
      { key: 'supporto', label: accMap.supporto || 'Supporto motore' },
      { key: 'motore', label: accMap.motore || 'Motore' },
      { key: 'trolling', label: accMap.trolling || 'Motore di prua' },
      { key: 'fishfinder', label: accMap.fishfinder || 'Ecoscandaglio' },
      { key: 'impianto', label: accMap.impianto || 'Impianto elettrico' },
      { key: 'batteria', label: accMap.batteria || 'Batteria al Litio' }
    ];
    const items = [];
    order.forEach((item) => {
      if(item.key === 'antiskid'){
        if((selectedAntiskid || 'none') !== 'none'){
          const price = getAntiskidPrice();
          const label = `${antiskidTitle} (${getAntiskidLabel()})`;
          items.push({ label, price });
        }
        return;
      }
      if(isSelected(item.key)){
        const price = priceTable?.accessories?.[item.key] ?? 0;
        items.push({ label: item.label, price });
      }
    });
    return items;
  }
      function formatEuro(value){
    return formatMoney(value);
  }
      function getFinishLabel(){
    const map = currentLang === 'en'
      ? { gelcoat: 'Gelcoat', paint: 'Acrylic', rugged: 'Rugged', wrapping: 'Wrapping' }
      : { gelcoat: 'Gelcoat', paint: 'Verniciato', rugged: 'Rugged', wrapping: 'Wrapping' };
    return map[selectedFinish] || selectedFinish || '-';
  }
  function getSelectLabel(sel, fallback){
    if(!sel) return fallback || '-';
    const opt = sel.options?.[sel.selectedIndex];
    return opt?.textContent?.trim() || fallback || '-';
  }
  function getAntiskidLabel(){
    const sel = document.querySelector('#antiskid-select select');
    return getSelectLabel(sel, selectedAntiskid || 'none');
  }
  function getColorLabel(group, fallback){
    if(group === 'hull' && selectedHullLabel) return selectedHullLabel;
    if(group === 'deck' && selectedDeckLabel) return selectedDeckLabel;
    if(group === 'hatches' && selectedHatchesLabel) return selectedHatchesLabel;
    return getSelectLabel(colorSelects[group], fallback || '-');
  }
function getColorsSummary(){
    const hull = getColorLabel('hull', selectedHull || '-');
    const deck = getColorLabel('deck', selectedDeck || '-');
    const doors = getColorLabel('hatches', selectedHatches || '-');
    const l = currentLang === 'en'
      ? { hull: 'Hull', deck: 'Deck', doors: 'Doors' }
      : { hull: 'Chiglia', deck: 'Ponte', doors: 'Portelli' };
    return `${l.hull} (${hull}), ${l.deck} (${deck}), ${l.doors} (${doors})`;
  }

    function getAntiskidPrice(){
    const key = (selectedAntiskid || 'none').toLowerCase();
    if(key === 'none') return 0;
    const table = priceTable?.accessories?.antiskid;
    if(typeof table === 'number') return table || 0;
    return (table && typeof table === 'object') ? (table[key] ?? 0) : 0;
  }
  function getPriceSummary(){
    const el = document.getElementById('price-tag');
    return el ? el.textContent.trim() : '';
  }
  function renderLiveSummary(){
    if(!liveSummaryEl) return;
    const isEn = currentLang === 'en';
    const t = isEn
      ? { title: 'Live summary', finish: 'Finish', colors: 'Colors', antiskid: 'Antiskid', accessories: 'Accessories' }
      : { title: 'Riepilogo live', finish: 'Finitura', colors: 'Colori', antiskid: 'Antiscivolo', accessories: 'Accessori' };
    const rows = [];
    if(selectedFinish){
      rows.push(`<li><b>${t.finish}:</b> ${getFinishLabel()}</li>`);
    }
    if(selectedHull || selectedDeck || selectedHatches){
      rows.push(`<li><b>${t.colors}:</b> ${getColorsSummary()}</li>`);
    }
    if(selectedAntiskid && selectedAntiskid !== 'none'){
      rows.push(`<li><b>${t.antiskid}:</b> ${getAntiskidLabel()}</li>`);
    }
    const hasAccessories = Boolean(document.querySelector('#step-accessori input[type="checkbox"]:checked'));
    if(hasAccessories){
      rows.push(`<li><b>${t.accessories}:</b> ${getAccessoriesSummary()}</li>`);
    }
    liveSummaryEl.innerHTML = `<div class="live-summary-title">${t.title}</div><ul>${rows.join('')}</ul>`;
  }
  function getExportI18n(){
    if(currentLang === 'en'){
      return {
        saved: 'Saved',
        customConfig: 'Custom configuration',
        config: 'Configuration',
        finish: 'Finish',
        colors: 'Colors',
        hull: 'Hull',
        deck: 'Deck',
        doors: 'Doors',
        antiskid: 'Antiskid',
        selectedAccessories: 'Selected accessories',
        none: 'None',
        total: 'Configuration total',
        footer: 'Images and specifications are indicative. Prices may vary.',
        filePrefix: 'order',
        emailSubject: 'Configuration order',
        customer: 'Customer',
        name: 'Name',
        surname: 'Surname',
        phone: 'Phone',
        address: 'Address',
        city: 'City',
        zip: 'ZIP',
        notes: 'Notes',
        emailRequired: 'Please enter a valid email address.',
        sending: 'Sending...',
        sentOk: 'Order sent successfully. We will contact you shortly.',
        sentErr: 'Order sending failed. You can download the PDF and try again.'
      };
    }
    return {
      saved: 'Salvato',
      customConfig: 'Configurazione personalizzata',
      config: 'Configurazione',
      finish: 'Finitura',
      colors: 'Colori',
      hull: 'Chiglia',
      deck: 'Ponte',
      doors: 'Portelli',
      antiskid: 'Antiscivolo',
      selectedAccessories: 'Accessori selezionati',
      none: 'Nessuno',
      total: 'Totale configurazione',
      footer: 'Immagini e specifiche sono indicative. Prezzi soggetti a variazione.',
      filePrefix: 'ordine',
      emailSubject: 'Ordine configurazione',
      customer: 'Cliente',
      name: 'Nome',
      surname: 'Cognome',
      phone: 'Telefono',
      address: 'Indirizzo',
      city: 'Citta',
      zip: 'CAP',
      notes: 'Note',
      emailRequired: 'Inserisci un indirizzo email valido.',
      sending: 'Invio...',
      sentOk: 'Ordine inviato correttamente. Ti contatteremo a breve.',
      sentErr: 'Errore invio ordine. Puoi scaricare il PDF e riprovare.'
    };
  }

        function getEmailPayloadForTemplate(payload, assets = {}, includeImages = true){
    const t = getExportI18n();
    const colori = getColorsSummary();
    const finitura = typeof getFinishLabel === 'function' ? getFinishLabel() : payload.finish;
    const antiskid = typeof getAntiskidLabel === 'function' ? getAntiskidLabel() : payload.antiskid;
    const now = new Date();
    const locale = currentLang === 'en' ? 'en-US' : 'it-IT';
    const date = now.toLocaleDateString(locale) + ' ' + now.toLocaleTimeString(locale, { hour: '2-digit', minute: '2-digit' });
    const imgMain = includeImages ? (assets.img_main || '') : '';
    const imgTop = includeImages ? (assets.img_top_right || '') : '';
    const imgBottom = includeImages ? (assets.img_bottom_right || '') : '';
    return {
      id: payload.id,
      finitura,
      colori,
      antiskid,
      accessori: payload.accessories,
      prezzo: payload.price,
      nome: payload.customer.nome,
      cognome: payload.customer.cognome,
      email: payload.customer.email,
      telefono: payload.customer.telefono,
      indirizzo: payload.customer.indirizzo,
      citta: payload.customer.citta,
      cap: payload.customer.cap,
      note: payload.customer.note,
      date,
      img_main: imgMain,
      img_top_right: imgTop,
      img_bottom_right: imgBottom,
      qr: assets.qr || '',
      lbl_custom_config: t.customConfig,
      lbl_configuration: t.config,
      lbl_finish: t.finish,
      lbl_colors: t.colors,
      lbl_antiskid: t.antiskid,
      lbl_accessories_selected: t.selectedAccessories,
      lbl_total: t.total,
      lbl_footer_note: t.footer,
      img_block_style: includeImages ? '' : 'display:none;',
      img_main_style: imgMain ? 'display:block;' : 'display:none;',
      img_top_right_style: imgTop ? 'display:block;' : 'display:none;',
      img_bottom_right_style: imgBottom ? 'display:block;' : 'display:none;',
      configurazione_json: JSON.stringify(payload)
    };
  }
  function canSendEmail(){
    return Boolean(window.emailjs && EMAILJS_SERVICE_ID && EMAILJS_TEMPLATE_ID_CLIENT && EMAILJS_TEMPLATE_ID_ADMIN && EMAILJS_PUBLIC_KEY);
  }
  function getEmailTemplateIdsByLang(){
    return {
      admin: EMAILJS_TEMPLATE_ID_ADMIN,
      client: currentLang === 'en'
        ? (EMAILJS_TEMPLATE_ID_CLIENT_EN || EMAILJS_TEMPLATE_ID_CLIENT)
        : EMAILJS_TEMPLATE_ID_CLIENT
    };
  }

  function initEmailJs(){
    if(emailJsReady) return;
    if(window.emailjs && EMAILJS_PUBLIC_KEY){
      window.emailjs.init(EMAILJS_PUBLIC_KEY);
      emailJsReady = true;
    }
  }

    function sendOrderEmails(payload, assets){
    if(!canSendEmail()){
      return Promise.reject(new Error('EmailJS non configurato'));
    }
    initEmailJs();
    const tpl = getEmailTemplateIdsByLang();
    const dataAdmin = getEmailPayloadForTemplate(payload, assets, false);
    const dataClient = getEmailPayloadForTemplate(payload, assets, true);
    console.log('EmailJS admin template:', tpl.admin);
    console.log('EmailJS client template:', tpl.client, 'to', payload.customer.email);
    const sendAdmin = window.emailjs.send(EMAILJS_SERVICE_ID, tpl.admin, dataAdmin);
    const sendClient = window.emailjs.send(EMAILJS_SERVICE_ID, tpl.client, {
      ...dataClient,
      to_email: payload.customer.email
    });
    return Promise.all([sendAdmin, sendClient]).then((results) => {
      console.log('EmailJS risultati:', results);
      return results;
    });
  }
  function prepareOrderPayload(){
    const getVal = (id) => document.getElementById(id)?.value || '';
    return {
      id: currentOrderId || generateOrderId(),
      finish: selectedFinish || '',
      colors: {
        hull: getColorLabel('hull', selectedHull || ''),
        deck: getColorLabel('deck', selectedDeck || ''),
        hatches: getColorLabel('hatches', selectedHatches || '')
      },
      antiskid: selectedAntiskid || 'none',
      accessories: getAccessoriesSummary(),
      price: getPriceSummary(),
      customer: {
        nome: getVal('order-nome'),
        cognome: getVal('order-cognome'),
        email: getVal('order-email'),
        telefono: getVal('order-telefono'),
        indirizzo: getVal('order-indirizzo'),
        citta: getVal('order-citta'),
        cap: getVal('order-cap'),
        note: getVal('order-note')
      }
    };
  }
function openOrderModal(){
    if(!currentOrderId){
      currentOrderId = generateOrderId();
    }
    const modal = document.getElementById('order-modal');
    if(!modal) return;
    modal.classList.add('is-open');
    modal.setAttribute('aria-hidden', 'false');
    const setText = (id, value) => {
      const el = document.getElementById(id);
      if(el) el.textContent = value || '';
    };
    setText('order-id', currentOrderId);
    setText('order-finish', getFinishLabel());
    setText('order-colors', getColorsSummary());
    setText('order-antiskid', getAntiskidLabel());
    setText('order-accessories', getAccessoriesSummary());
    setText('order-price', getPriceSummary());
    const qrEl = document.getElementById('order-qr');
    if(qrEl){
      qrEl.innerHTML = '';
      if(typeof QRCode !== 'undefined'){
        new QRCode(qrEl, { text: currentOrderId, width: 128, height: 128 });
      }
    }
  }
  let orderFlowBusy = false;
  async function triggerOrderFlow(){
    if(orderFlowBusy) return;
    orderFlowBusy = true;
    const orderBtn = document.getElementById('order-btn');
    const prev = orderBtn ? orderBtn.textContent : 'Ordina';
    if(orderBtn){
      orderBtn.disabled = true;
      orderBtn.textContent = 'Caricamento...';
    }
    try{
      lastPresetScreenshots = await capturePresetScreenshots();
    }catch(err){
      console.warn('Preset screenshot fallito', err);
      lastPresetScreenshots = [];
    }finally{
      if(orderBtn){
        orderBtn.disabled = false;
        orderBtn.textContent = prev;
      }
      orderFlowBusy = false;
    }
    openOrderModal();
  }

  function closeOrderModal(){
    const modal = document.getElementById('order-modal');
    if(!modal) return;
    modal.classList.remove('is-open');
    modal.setAttribute('aria-hidden', 'true');
  }
  function captureScreenshot(){
    if(!renderer || !renderer.domElement) return null;
    try{
      const dataUrl = renderer.domElement.toDataURL('image/png');
      lastScreenshotDataUrl = dataUrl;
      return dataUrl;
    }catch(err){
      console.warn('Screenshot fallito', err);
      return null;
    }
  }

    function setCameraView(pos, target){
    if(!camera || !controls) return;
    camera.position.set(pos[0], pos[1], pos[2]);
    controls.target.set(target[0], target[1], target[2]);
    controls.update();
    renderer.render(scene, camera);
  }

      async function uploadDataUrl(dataUrl){
    if(!dataUrl || !UPLOAD_ENDPOINT || UPLOAD_ENDPOINT.includes('YOUR-VERCEL-APP')){
      return '';
    }
    const res = await fetch(UPLOAD_ENDPOINT, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ dataUrl })
    });
    if(!res.ok){
      throw new Error(`Upload failed: ${res.status}`);
    }
    const json = await res.json();
    return json.url || '';
  }
  async function downscaleDataUrl(dataUrl, maxWidth){
    return new Promise((resolve) => {
      if(!dataUrl){
        resolve('');
        return;
      }
      const img = new Image();
      img.onload = () => {
        try{
          const scale = Math.min(1, maxWidth / (img.naturalWidth || maxWidth));
          if(scale >= 1){
            resolve(dataUrl);
            return;
          }
          const canvas = document.createElement('canvas');
          canvas.width = Math.max(1, Math.round((img.naturalWidth || maxWidth) * scale));
          canvas.height = Math.max(1, Math.round((img.naturalHeight || maxWidth) * scale));
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          resolve(canvas.toDataURL('image/jpeg', 0.82));
        }catch(err){
          resolve(dataUrl);
        }
      };
      img.onerror = () => resolve(dataUrl);
      img.src = dataUrl;
    });
  }

          async function prepareEmailAssets(){
    let shots = Array.isArray(lastPresetScreenshots) ? lastPresetScreenshots : [];
    if(!shots.length){
      try{
        shots = await capturePresetScreenshots();
      }catch(err){
        shots = [];
      }
    }
    const side = shots.find(s => s.label === 'Side') || shots[0] || null;
    const rear = shots.find(s => s.label === 'Rear') || shots[1] || null;
    const top = shots.find(s => s.label === 'Top') || shots[2] || null;
    const qrData = await makeQrDataUrl(currentOrderId || generateOrderId());
    const [img_main, img_top_right, img_bottom_right, qr] = await Promise.all([
      uploadDataUrl(side?.dataUrl || ''),
      uploadDataUrl(rear?.dataUrl || ''),
      uploadDataUrl(top?.dataUrl || ''),
      uploadDataUrl(qrData)
    ]);
    return { img_main, img_top_right, img_bottom_right, qr };
  }

  async function capturePresetScreenshots(){
    if(!renderer || !camera || !controls) return [];
    const captureWidth = 1600;
    const captureHeight = 900;
    const prevPixelRatio = renderer.getPixelRatio();
    const prevAspect = camera.aspect;
    const prevFov = camera.fov;
    const prevSize = renderer.getSize(new THREE.Vector2());
    const originalPos = camera.position.clone();
    const originalTarget = controls.target.clone();
    const target = [-0.10810611905192113, -0.167470325414858, -0.13144927171760207];
    const views = [
      { label: 'Side', pos: [0.0516653740024167, 0.1820664977829592, 0.8294428750065087], target: [-0.05, -0.167470325414858, -0.13144927171760207] },
      { label: 'Rear', pos: [-0.8191399443716609, 0.1300141316619867, 0.3925348763178731] },
      { label: 'Top', pos: [0.4912714944470407, 0.4747723290977302, -0.4437419989992951], target: [0.05, -0.08190660770733932, 0.07343899384140155] }
    ];
    const results = [];
    try{
      // Force a consistent landscape render target to avoid stretched images on mobile.
      renderer.setPixelRatio(1);
      renderer.setSize(captureWidth, captureHeight, false);
      camera.aspect = captureWidth / captureHeight;
      camera.updateProjectionMatrix();
      for(const view of views){
        setCameraView(view.pos, view.target || target);
        await new Promise((resolve) => requestAnimationFrame(() => resolve()));
        const shot = captureScreenshot();
        if(shot){
          results.push({ label: view.label, dataUrl: shot });
        }
      }
    }finally{
      camera.position.copy(originalPos);
      controls.target.copy(originalTarget);
      camera.fov = prevFov;
      camera.aspect = prevAspect;
      camera.updateProjectionMatrix();
      renderer.setPixelRatio(prevPixelRatio);
      renderer.setSize(prevSize.x, prevSize.y, false);
      controls.update();
      renderer.render(scene, camera);
    }
    return results;
  }

function downloadScreenshot(){
    const dataUrl = captureScreenshot();
    if(!dataUrl) return;
    const link = document.createElement('a');
    const id = currentOrderId || 'config';
    link.href = dataUrl;
    link.download = `screenshot-${id}.png`;
    document.body.appendChild(link);
    link.click();
    link.remove();
  }

  async function loadImageAsDataUrl(src){
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => {
        try{
          const canvas = document.createElement('canvas');
          canvas.width = img.naturalWidth;
          canvas.height = img.naturalHeight;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0);
          resolve({
            dataUrl: canvas.toDataURL('image/png'),
            width: img.naturalWidth,
            height: img.naturalHeight
          });
        }catch(err){
          reject(err);
        }
      };
      img.onerror = reject;
      img.src = src;
    });
  }

  async function makeQrDataUrl(text){
    return new Promise((resolve) => {
      if(typeof QRCode === 'undefined'){
        resolve(null);
        return;
      }
      const holder = document.createElement('div');
      holder.style.position = 'absolute';
      holder.style.left = '-9999px';
      holder.style.top = '-9999px';
      document.body.appendChild(holder);
      new QRCode(holder, { text, width: 160, height: 160 });
      const img = holder.querySelector('img');
      if(img && img.src){
        resolve(img.src);
      }else{
        const canvas = holder.querySelector('canvas');
        resolve(canvas ? canvas.toDataURL('image/png') : null);
      }
      holder.remove();
    });
  }

  async function downloadOrderPdf(){
    if(!window.jspdf?.jsPDF) return;
    const doc = new window.jspdf.jsPDF({ unit: 'mm', format: 'a4' });
    const pageW = doc.internal.pageSize.getWidth();
    const pageH = doc.internal.pageSize.getHeight();
    const margin = 12;

    if(!currentOrderId){
      currentOrderId = generateOrderId();
    }
    const t = getExportI18n();

    let logoData = null;
    try{
      logoData = await loadImageAsDataUrl('images/Scritta_black.png');
    }catch(err){
      console.warn('Logo non caricato', err);
    }

    const now = new Date();
    const locale = currentLang === 'en' ? 'en-US' : 'it-IT';
    const dateStr = now.toLocaleDateString(locale) + ' ' + now.toLocaleTimeString(locale, { hour: '2-digit', minute: '2-digit' });

    // Header
    if(logoData && logoData.dataUrl){
      const maxW = 57;
      const maxH = 15;
      const ratio = logoData.width && logoData.height ? (logoData.width / logoData.height) : 4;
      let w = maxW;
      let h = w / ratio;
      if(h > maxH){
        h = maxH;
        w = h * ratio;
      }
      doc.addImage(logoData.dataUrl, 'PNG', margin, 10, w, h, undefined, 'FAST');
    }
    doc.setFontSize(9);
    doc.setTextColor(60);
    doc.text(`Ninga ID: ${currentOrderId}`, pageW - margin, 12, { align: 'right' });
    doc.text(`${t.saved}: ${dateStr}`, pageW - margin, 17, { align: 'right' });

    const qrData = await makeQrDataUrl(currentOrderId);
    if(qrData){
      const qrSize = 22;
      doc.addImage(qrData, 'PNG', pageW - margin - qrSize, 25, qrSize, qrSize, undefined, 'FAST');
    }

    doc.setDrawColor(210);
    doc.line(margin, 22, pageW - margin, 22);

    // Title
    doc.setTextColor(20);
    doc.setFontSize(24);
    doc.text('FISHER 40', margin, 34);
    doc.setFontSize(12);
    doc.text(t.customConfig, margin, 41);

    // Images layout
    let shots = Array.isArray(lastPresetScreenshots) ? lastPresetScreenshots : [];
    if(!shots.length){
      const single = lastScreenshotDataUrl || captureScreenshot();
      if(single){
        shots = [{ label: 'Vista', dataUrl: single }];
      }
    }
    if(shots.length === 1){
      shots = [shots[0], shots[0], shots[0]];
    }else if(shots.length === 2){
      shots = [shots[0], shots[1], shots[1]];
    }

    const imgTop = 50;
    const imgGap = 4;
    const leftW = 118;
    const leftH = 78;
    const rightW = pageW - margin - (margin + leftW) - imgGap;
    const rightH = (leftH - imgGap) / 2;
    const leftX = margin;
    const rightX = margin + leftW + imgGap;

    if(shots[0]){
      doc.addImage(shots[0].dataUrl, 'PNG', leftX, imgTop, leftW, leftH, undefined, 'FAST');
    }
    if(shots[1]){
      doc.addImage(shots[1].dataUrl, 'PNG', rightX, imgTop, rightW, rightH, undefined, 'FAST');
    }
    if(shots[2]){
      doc.addImage(shots[2].dataUrl, 'PNG', rightX, imgTop + rightH + imgGap, rightW, rightH, undefined, 'FAST');
    }

            // Configurazione + Accessori
    const listTop = imgTop + leftH + 10;
    doc.setDrawColor(210);
    doc.line(margin, listTop, pageW - margin, listTop);

    doc.setFontSize(10);
    doc.setTextColor(20);
    doc.setFont('helvetica', 'bold');
    doc.text(t.config, margin, listTop + 6);
    doc.setFont('helvetica', 'normal');

    doc.setFontSize(9);
    const cfgStartY = listTop + 12;
        doc.text(`- ${t.finish}: ${getFinishLabel()}`, margin + 2, cfgStartY);
    const finishPct = priceTable?.finishPct?.[selectedFinish] || 0;
    const finishPrice = priceTable.base + (priceTable.base * finishPct);
    doc.text(formatEuro(finishPrice), pageW - margin, cfgStartY, { align: 'right' });
    const hullLabel = getColorLabel('hull', selectedHull || '-');
    const deckLabel = getColorLabel('deck', selectedDeck || '-');
    const doorsLabel = getColorLabel('hatches', selectedHatches || '-');
    const colorsY = cfgStartY + 5;
    const colorsLine = `- ${t.colors}: ${t.hull} (${hullLabel}), ${t.deck} (${deckLabel}), ${t.doors} (${doorsLabel})`;
    doc.setFont('helvetica', 'normal');
    doc.text(colorsLine, margin + 2, colorsY);
    doc.text(`- ${t.antiskid}: ${getAntiskidLabel()}`, margin + 2, cfgStartY + 10);

    const items = getSelectedAccessoriesDetailed();
    const rowH = 5;
    const listStartY = cfgStartY + 20;

    doc.setFontSize(10);
    doc.setFont('helvetica', 'bold');
    doc.text(t.selectedAccessories, margin, listStartY);
    doc.setFont('helvetica', 'normal');

    const accessoriesY = listStartY + 6;
    if(items.length){
      items.forEach((item, idx) => {
        const y = accessoriesY + idx * rowH;
        doc.text(`- ${item.label}`, margin + 2, y);
        doc.text(formatEuro(item.price), pageW - margin, y, { align: 'right' });
      });
    }else{
      doc.setTextColor(90);
      doc.text(t.none, margin + 2, accessoriesY);
      doc.setTextColor(20);
    }

    const totalLineY = accessoriesY + Math.max(items.length, 1) * rowH + 2;
    doc.setDrawColor(210);
    doc.line(margin, totalLineY, pageW - margin, totalLineY);
    const totalTextY = totalLineY + 7;
    doc.setFontSize(11);
    doc.setFont('helvetica', 'bold');
    doc.text(t.total, margin, totalTextY);
    doc.text(getPriceSummary() || '-', pageW - margin, totalTextY, { align: 'right' });
    doc.setFont('helvetica', 'normal');

    // Footer notes
    doc.setFontSize(8);
    doc.setTextColor(120);
    const noteY = totalTextY + 8;
    doc.text(t.footer, margin, noteY);

    doc.save(`${t.filePrefix}-${currentOrderId || 'config'}.pdf`);
  }
window.addEventListener('DOMContentLoaded', () => {
    const orderBtn = document.getElementById('order-btn');
    const orderModal = document.getElementById('order-modal');
    const orderClose = document.querySelector('#order-modal .order-close');
    const orderDownload = document.getElementById('order-download');
    const orderConfirm = document.getElementById('order-confirm');
    initEmailJs();
    if(orderBtn){
      orderBtn.addEventListener('click', () => {
        if(currentStep !== 'accessori') return;
        triggerOrderFlow();
      });
    }
    if(orderClose){
      orderClose.addEventListener('click', () => {
        closeOrderModal();
      });
    }
    if(orderModal){
      orderModal.addEventListener('click', (e) => {
        if(e.target === orderModal){
          closeOrderModal();
        }
      });
    }
    if(orderDownload){
      orderDownload.addEventListener('click', () => {
        downloadOrderPdf();
      });
    }
    if(orderConfirm){
      orderConfirm.addEventListener('click', async () => {
        const t = getExportI18n();
        const payload = prepareOrderPayload();
        if(!payload.customer.email || !payload.customer.email.includes('@')){
          alert(t.emailRequired);
          return;
        }
        if(canSendEmail()){
          const originalLabel = orderConfirm.textContent;
          orderConfirm.disabled = true;
          orderConfirm.textContent = t.sending;
          try{
            const assets = await prepareEmailAssets();
            await sendOrderEmails(payload, assets);
            alert(t.sentOk);
          }catch(err){
            console.error(err);
            alert(t.sentErr);
          }finally{
            orderConfirm.disabled = false;
            orderConfirm.textContent = originalLabel;
          }
          return;
        }
        const subject = `${t.emailSubject} ${payload.id}`;
        const finishLabel = getFinishLabel();
        const antiskidLabel = getAntiskidLabel();
        const accessoriesLabel = getAccessoriesSummary();
        const body = `ID: ${payload.id}
${t.finish}: ${finishLabel}
${t.colors}: ${t.hull} (${payload.colors.hull}), ${t.deck} (${payload.colors.deck}), ${t.doors} (${payload.colors.hatches})
${t.antiskid}: ${antiskidLabel}
${I18N[currentLang]?.orderModal?.labels?.accessories || 'Accessori'}: ${accessoriesLabel}
${I18N[currentLang]?.orderModal?.labels?.price || 'Prezzo'}: ${payload.price}

${t.customer}:
${t.name}: ${payload.customer.nome}
${t.surname}: ${payload.customer.cognome}
Email: ${payload.customer.email}
${t.phone}: ${payload.customer.telefono}
${t.address}: ${payload.customer.indirizzo}
${t.city}: ${payload.customer.citta}
${t.zip}: ${payload.customer.cap}
${t.notes}: ${payload.customer.note}`;
        const mailto = `mailto:ningaskiffs@gmail.com?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
        window.location.href = mailto;
      });
    }
    renderFinishSelect();
    renderAntiskidSelect();
    resetAccessoryUI();
    const audioBtn = document.getElementById('audio-toggle');
    const screenshotBtn = document.getElementById('screenshot-btn');
    if(screenshotBtn){
      screenshotBtn.addEventListener('click', () => {
        downloadScreenshot();
      });
    }
    if(audioBtn){
      audioBtn.addEventListener('click', () => {
        setAudioEnabled(!audioEnabled, true);
      });
      setAudioEnabled(audioEnabled, false);
    }
    const langItBtn = document.getElementById('lang-it');
    const langEnBtn = document.getElementById('lang-en');
    const currencyEurBtn = document.getElementById('currency-eur');
    const currencyUsdBtn = document.getElementById('currency-usd');
    if(langItBtn){
      langItBtn.addEventListener('click', () => setLanguage('it'));
    }
    if(langEnBtn){
      langEnBtn.addEventListener('click', () => setLanguage('en'));
    }
    if(currencyEurBtn){
      currencyEurBtn.addEventListener('click', () => setCurrency('EUR'));
    }
    if(currencyUsdBtn){
      currencyUsdBtn.addEventListener('click', () => setCurrency('USD'));
    }
    applyLanguageUI();
    const rxBtn = document.getElementById('rx-btn');
    if(rxBtn){
      rxBtn.addEventListener('click', () => {
        if(currentStep !== 'accessori') return;
        toggleDeckTransparency();
      });
    }
    updateRxButtonState();

    const infoPanel = document.getElementById('info-panel');
    const infoTitle = document.getElementById('info-title');
    const infoBody = document.getElementById('info-body');
    const infoClose = document.getElementById('info-close');
    let currentInfoKey = '';
    let lastInfoTrigger = null;
    const closeInfoPanel = () => {
      if(!infoPanel) return;
      const focusedInsidePanel = document.activeElement && infoPanel.contains(document.activeElement)
        ? document.activeElement
        : null;
      if(focusedInsidePanel && typeof focusedInsidePanel.blur === 'function'){
        focusedInsidePanel.blur();
      }
      if(lastInfoTrigger && typeof lastInfoTrigger.focus === 'function' && document.contains(lastInfoTrigger)){
        lastInfoTrigger.focus({ preventScroll: true });
      }
      infoPanel.classList.remove('is-open');
      if('inert' in infoPanel){
        infoPanel.inert = true;
      }
      infoPanel.setAttribute('aria-hidden', 'true');
      currentInfoKey = '';
    };
    if(infoClose){
      infoClose.addEventListener('click', closeInfoPanel);
    }
    document.querySelectorAll('.info-pill[data-info-key]').forEach((el) => {
      el.addEventListener('click', () => {
        const fallbackKey = el.getAttribute('data-info-key') || '';
        const stepKey = String(currentStep || '').toLowerCase();
        const dynamicStep = el.getAttribute('data-info-dynamic') === 'step';
        const resolvedKey = dynamicStep ? (INFO_CONTENT[stepKey] ? stepKey : fallbackKey) : fallbackKey;
        const content = getInfoContentForLang(resolvedKey) || getInfoContentForLang(fallbackKey);
        if(!content || !infoPanel || !infoTitle || !infoBody) return;
        lastInfoTrigger = el;
        const isOpen = infoPanel.classList.contains('is-open') && infoPanel.getAttribute('aria-hidden') !== 'true';
        if(isOpen && currentInfoKey === resolvedKey){
          closeInfoPanel();
          return;
        }
        currentInfoKey = resolvedKey;
        infoTitle.textContent = (content.title || 'Informazioni');
        infoBody.textContent = (content.body || '');
        infoPanel.classList.add('is-open');
        if('inert' in infoPanel){
          infoPanel.inert = false;
        }
        infoPanel.setAttribute('aria-hidden', 'false');
      });
    });
    applyInteractionScheme();
    applyFramingForViewport(true);
    const viewer = document.getElementById('viewer');
    if(interactHint){
      interactHint.addEventListener('pointerdown', (e) => e.stopPropagation());
      interactHint.addEventListener('pointerup', (e) => {
        e.stopPropagation();
        const trollingChecked = Boolean(document.querySelector('#step-accessori input[data-accessory="trolling"]')?.checked);
        if(!trollingChecked) return;
        window.setTrollingDeployState(!trollingDeployed);
      });
    }
    if(viewer){
      let pointerDownPos = null;
      viewer.addEventListener('pointerdown', () => {
        pointerDownPos = null;
        unlockAudio();
        if(audioEnabled){
          sounds.bg.play().catch(() => {});
        }
      });
      viewer.addEventListener('pointerdown', (e) => {
        pointerDownPos = { x: e.clientX, y: e.clientY };
      });
      viewer.addEventListener('pointerup', (e) => {
        if(e.target?.closest?.('#viewer-ui')) return;
        if(!pointerDownPos) return;
        const dx = e.clientX - pointerDownPos.x;
        const dy = e.clientY - pointerDownPos.y;
        const moved = Math.hypot(dx, dy) > 8;
        pointerDownPos = null;
        if(moved) return;
        if(tryToggleTrollingDeployFromPointer(e)) return;
        tryToggleInteractiveActionFromPointer(e);
      });
    }
  
  });

  function animate(){
    requestAnimationFrame(animate);
    const delta = animationClock.getDelta();
    if(animationMixer) animationMixer.update(delta);
    controls.update();
    updateInteractHint();
    updateActionHints();
    updatePancaArrows();
    if(water){
      water.material.uniforms['time'].value += 1.0 / 600.0;
    }
    renderer.render(scene,camera);
  }
  animate();

  window.addEventListener('resize', () => {
    applyMobileRotate();
  });
  applyMobileRotate();
</script>

</body>
</html>




































































































































































































