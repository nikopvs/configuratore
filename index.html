<!DOCTYPE html>
<html lang="it">
<head>
    <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Configuratore Barca 3D</title>
  <style>
    html, body {
      height: 100%;
    }

    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background-color: #05070a;
      background:
        radial-gradient(circle at top, rgba(20, 80, 140, 0.45), rgba(2, 6, 12, 0.9) 60%),
        url('sfondo.jpg?v=2') center/cover no-repeat;
      color: #fff;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }

    #header {
      width: 60vw;
      margin-top: 16px;
      text-align: center;
    }

    #header h1 {
      margin: 0 0 6px 0;
      font-size: 28px;
      letter-spacing: 2px;
    }

    #header h2 {
      margin: 0 0 8px 0;
      font-size: 16px;
      font-weight: 600;
      text-transform: uppercase;
    }

    #viewer {
      width: 60vw;
      height: 80vh;
      border: 5px solid rgba(255,255,255,0.5);
      border-radius: 12px;
      background: rgba(0,0,0,0.35);
      box-shadow: 0 12px 30px rgba(0,0,0,0.35);
      overflow: visible;
      position: relative;
    }

    @media (max-width: 900px) {
      body {
        justify-content: flex-start;
        padding-top: 10px;
      }

      #header {
        width: min(92vw, 560px);
      }

      #header h1 {
        font-size: 22px;
      }

      #header h2 {
        font-size: 12px;
      }

      #viewer {
        width: 96vw;
        height: 92vh;
        border-width: 3px;
      }

      #viewer-ui h1 {
        font-size: 26px;
      }

      #viewer-ui h2 {
        font-size: 12px;
      }

      #price-tag {
  margin-top: 20px;
  font-size: 20px;
  letter-spacing: 0.5px;
  color: #7CFF00;;
  background: transparent;
  border: none;
  padding: 0;
}

      .step-header {
        top: 6px;
        height: 32px;
        gap: 10px;
      }

      #step-title {
        font-size: 12px;
        letter-spacing: 0.6px;
      }

      .nav-btn {
        width: 36px;
        height: 36px;
      }

      .nav-btn::after {
        border-top-width: 6px;
        border-bottom-width: 6px;
        border-left-width: 10px;
      }

      .reset-btn::after { content: none !important; }

      #step-finitura button,
      #step-colori button {
        min-width: 96px;
        padding: 10px 12px;
        font-size: 13px;
      }

      #step-colori select {
        min-width: 120px;
        font-size: 12px;
      }

      #step-accessori {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 6px 8px;
        text-align: left;
      }

          #step-accessori {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px 18px;
      text-align: left;
      padding-top: 0;
    }
#step-accessori label {
        margin-left: 0 !important;
        padding: 6px 6px;
        font-size: 11px;
      }

      #step-accessori input {
        transform: scale(1.15);
      }
    }

    #loading {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      background: rgba(0, 0, 0, 0.55);
      z-index: 8;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: 600;
      font-size: 12px;
      color: #7CFF00;
      pointer-events: none;
    }

    #loading-bar {
      width: min(320px, 70%);
      height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.15);
      overflow: hidden;
      box-shadow: inset 0 0 8px rgba(0,0,0,0.6);
    }

    #loading-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #7CFF00, #3DFF8C);
      transition: width 0.2s ease;
    }

    #viewer-ui {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      pointer-events: none;
    }

    #viewer-ui .top,
    #viewer-ui .bottom {
      pointer-events: auto;
      position: relative;
      z-index: 6;
      pointer-events: auto;
padding: 10px 14px;
      text-align: center;
      background: linear-gradient(
        to bottom,
        rgba(0,0,0,0.55),
        rgba(0,0,0,0)
      );
    }

    
    #viewer-ui .top *,
    #viewer-ui .bottom * {
      pointer-events: auto;
    }
#viewer-ui .bottom {
      background: linear-gradient(
        to top,
        rgba(0,0,0,0.55),
        rgba(0,0,0,0)
      );
      position: relative;
      padding-top: 42px;
    }

    
    #viewer-ui .top *,
    #viewer-ui .bottom * {
      pointer-events: auto;
    }
#viewer-ui h1 {
      margin: 0;
      font-size: 34px;
      letter-spacing: 2px;
      color: #7CFF00;
    }

    #viewer-ui h2 {
      margin: 0 0 6px 0;
      font-size: 14px;
      font-weight: 600;
      text-transform: uppercase;
      text-align: center;
      color: #7CFF00;
    }

    #price-tag {
  margin-top: 20px;
  font-size: 20px;
  letter-spacing: 0.5px;
  color: #7CFF00;;
  background: transparent;
  border: none;
  padding: 0;
}

    .color-row {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
    }

    .color-group {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .color-label {
      font-weight: 600;
      font-size: 12px;
      text-transform: uppercase;
      opacity: 0.85;
      margin-right: 4px;
    }

    .nav-btn {
      position: relative;
      width: 28px;
      height: 28px;
      padding: 0;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.35);
      background: rgba(0,0,0,0.55);
      display: flex;
      align-items: center;
      justify-content: center;
transition: background 0.2s ease, transform 0.2s ease;
    }

    .nav-btn::after {
      content: '';
      width: 0;
      height: 0;
      border-top: 5px solid transparent;
      border-bottom: 5px solid transparent;
      border-left: 8px solid #7CFF00;
    }

    .nav-btn:hover {
      background: rgba(0,0,0,0.7);
    }

    .nav-btn:focus-visible {
      outline: 2px solid #7CFF00;
      outline-offset: 3px;
    }

    .back-btn {
      transform: none;
      transform-origin: center;
    }

    .reset-btn::after { content: none !important; }

    .nav-btn.is-disabled {
      opacity: 0.35;
      pointer-events: none;
    }

    .nav-btn.is-hidden {
      visibility: hidden;
      pointer-events: none;
    }

    .ghost-btn {
      visibility: hidden;
      pointer-events: none;
    }

    .step-header {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      padding: 0 6px;
      height: 26px;
    }

    #step-title {
      font-size: 14px;
      font-weight: 600;
      text-transform: uppercase;
      color: #7CFF00;
      letter-spacing: 1px;
      text-align: center;
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .step { margin: 0 0 6px 0; }
    .hidden { display: none; }
    .is-hidden { display: none; }

    button {
      margin: 4px;
      padding: 8px 14px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      background: #333;
      color: #fff;
}

    #step-colori button {
      padding: 6px 10px;
      font-size: 12px;
      margin: 3px;
    }

    #step-finitura select,
    #step-colori select {
      min-width: 140px;
      padding: 6px 8px;
      font-size: 12px;
      min-height: 34px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.35);
      background: rgba(0,0,0,0.6);
      color: #fff;
    }

    #step-colori option {
      background: #111;
      color: #fff;
    }

        #step-finitura button {
      padding: 6px 8px;
      font-size: 12px;
      min-width: 140px;
    }

    #step-accessori {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px 18px;
      text-align: left;
      padding-top: 0;
    }

    #step-accessori label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 7px 8px;
      font-size: 12px;
      line-height: 14px;
      position: relative;
    }

    #step-accessori input {
      transform: scale(1.1);
    }

    #step-colori {
      padding-top: 0;
    }

    #step-accessori {
      padding-top: 0;
    }

      button:hover { background:#555; }
      button.active { background:#1e90ff; }
    .choice-row {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  align-items: center;
  justify-content: center;
}

.choice-btn,
.choice-option {
  margin: 0;
  padding: 8px 12px;
  border-radius: 6px;
  border: 1px solid rgba(255,255,255,0.35);
  background: rgba(0,0,0,0.55);
  color: #fff;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.4px;
}


.choice-btn.trigger { text-transform: none; }
.choice-dropdown {
  position: relative;
  display: inline-flex;
}

.choice-menu {
  position: absolute;
  top: 100%;
  left: 0;
  margin-top: 6px;
  padding: 6px 8px;
  display: none;
  flex-direction: column;
  gap: 0;
  min-width: 180px;
  background: rgba(0,0,0,0.75);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 8px;
  z-index: 8;
}

.choice-dropdown:hover .choice-menu,
.choice-dropdown:focus-within .choice-menu {
  display: flex;
}

.choice-sub {
  position: relative;
  display: inline-flex;
}

.choice-submenu {
  position: absolute;
  left: 100%;
  bottom: 0;
  margin-left: 6px;
  padding: 6px 8px;
  display: none;
  flex-direction: column;
  gap: 0;
  min-width: 180px;
  background: rgba(0,0,0,0.75);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 8px;
  z-index: 9;
}

.choice-sub:hover .choice-submenu,
.choice-sub:focus-within .choice-submenu {
  display: flex;
}

.choice-option {
  width: 100%;
  text-align: left;
  padding: 6px 6px;
  font-size: 11px;
  text-transform: none;
  background: transparent;
  border: none;
  color: #fff;
}

.choice-option:hover {
  background: rgba(255,255,255,0.08);
}

.choice-option.is-selected {
  color: #7CFF00;
}

#viewer-ui label,
      #viewer-ui input,
      #viewer-ui select,
      #viewer-ui button {
cursor: pointer;
      }
  
    /* Extra UI */
    .controls-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      text-align: center;
      padding: calc(18% + 20px) 18px 0;
      font-size: 22px;
      line-height: 1.5;
      letter-spacing: 0.3px;
      font-weight: 700;
      color: #7CFF00;
      background: rgba(0,0,0,0.25);
      z-index: 4;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .controls-overlay.is-hidden {
      opacity: 0;
    }
#screenshot-btn {
      position: absolute;
      top: 12px;
      left: 12px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.35);
      padding: 8px 12px;
      font-size: 12px;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      color: #7CFF00;
    }

    #order-btn {
      position: absolute;
      top: 12px;
      right: 12px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.35);
      padding: 8px 12px;
      font-size: 12px;
      letter-spacing: 0.6px;
      text-transform: uppercase;
      color: #7CFF00;
    }

    #order-modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.7);
      z-index: 20;
    }
    #order-modal.is-open { display: flex; }
    .order-dialog {
      width: min(92vw, 720px);
      max-height: 88vh;
      overflow: auto;
      background: rgba(8,12,18,0.95);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 12px;
      padding: 16px 18px;
      color: #fff;
      box-shadow: 0 20px 40px rgba(0,0,0,0.45);
    }
    .order-header { display:flex; align-items:center; justify-content:space-between; margin-bottom:10px; }
    .order-header h3 { margin:0; font-size:18px; letter-spacing:1px; text-transform:uppercase; color:#7CFF00; }
    .order-close { background:transparent; border:1px solid rgba(255,255,255,0.35); color:#fff; padding:4px 8px; font-size:12px; }
    .order-grid { display:grid; grid-template-columns:1fr 1fr; gap:10px 12px; margin-bottom:12px; }
    .order-grid label { display:flex; flex-direction:column; gap:4px; font-size:12px; color: rgba(255,255,255,0.8); }
    .order-grid input,
    .order-grid textarea { background: rgba(0,0,0,0.45); border:1px solid rgba(255,255,255,0.2); color:#fff; border-radius:6px; padding:8px 10px; font-size:12px; }
    .order-grid textarea { min-height:70px; resize:vertical; grid-column:1 / -1; }
    .order-summary { display:grid; grid-template-columns:1fr auto; gap:8px 14px; align-items:start; margin-bottom:12px; font-size:12px; }
    .order-summary .label { color: rgba(255,255,255,0.6); }
    .order-qr { justify-self:end; background:#fff; padding:6px; border-radius:6px; }
    .order-actions { display:flex; gap:8px; justify-content:space-between; }
    .order-confirm { color:#ff3b3b !important; border-color:#ff3b3b !important; }
    .order-actions button { background: rgba(0,0,0,0.55); border:1px solid rgba(255,255,255,0.35); color:#7CFF00; padding:8px 12px; font-size:12px; letter-spacing:0.6px; text-transform:uppercase; }

    @media (max-width: 900px) {
      .controls-overlay { font-size: 17px; }
#order-btn { top: 8px; right: 8px; padding: 6px 8px; font-size: 11px; }
      #screenshot-btn { top: 8px; left: 8px; padding: 6px 8px; font-size: 11px; }
      
    }
  
    .home-link {
      width: 60vw;
      max-width: 980px;
      margin: 10px auto 0;
      text-align: center;
    }
    .home-link a {
      display: inline-block;
      color: #00FFFF;
      text-decoration: none;
      font-weight: 700;
      font-size: 12px;
      letter-spacing: 0.4px;
      text-transform: uppercase;
    }
    .home-link a:hover { text-decoration: underline; }

    @media (max-width: 900px) {
      .home-link { width: 96vw; }
      .home-link a { font-size: 11px; }
    }
    @media (max-width: 900px) {
      #step-accessori { flex-wrap: wrap; gap: 8px 12px; }
    }
  
    /* Accessori layout overrides */
    .hidden { display: none !important; }
#step-accessori label.is-locked {
  color: #ff3b3b;
}
#viewer-ui .reset-btn {
  background: rgba(0,0,0,0.55) !important;
  border: 1px solid rgba(255,255,255,0.35) !important;
  padding: 8px 12px !important;
  font-size: 12px !important;
  letter-spacing: 0.6px !important;
  text-transform: uppercase !important;
  color: #7CFF00 !important;
  border-radius: 6px !important;
  height: auto !important;
  width: auto !important;
}
#viewer-ui .reset-btn .reset-label {
  color: #ff3b3b;
  font-size: 12px;
  letter-spacing: 0.6px;
  text-transform: uppercase;
}
    #step-accessori:not(.hidden) {
      display: flex !important;
      flex-wrap: nowrap;
      gap: 12px;
      justify-content: center;
      text-align: left;
    }
    @media (max-width: 900px) {
      #step-accessori:not(.hidden) { flex-wrap: wrap; gap: 8px 12px; }
    }

    /* Step header alignment */
    #viewer-ui .bottom { position: relative !important; }
    .step-header {
      position: absolute !important;
      top: 8px !important;
      left: 50% !important;
      transform: translateX(-50%) !important;
      width: auto !important;
      justify-content: center !important;
      gap: 10px !important;
    }
    #step-title { text-align: center !important; min-width: 120px !important; display: inline-block !important; }
    #step-title-wrap { position: relative !important; display: inline-block !important; }
    #step-title-wrap .reset-btn { position: absolute !important; left: calc(100% + 10px) !important; top: calc(50% - 5px) !important; transform: translateY(-50%) !important; }
    .step-header .ghost-btn { display: none !important; }

    #viewer-ui .back-btn,
    #viewer-ui .next-btn {
      position: absolute !important;
      top: calc(50% - 300px) !important;
      width: 86px !important;
      height: 42px !important;
      border-radius: 999px !important;
      font-size: 12px !important;
      text-transform: uppercase !important;
      letter-spacing: 0.5px !important;
      background: rgba(0,0,0,0.45) !important;
    }
    #viewer-ui .back-btn::after,
    #viewer-ui .next-btn::after { display: none !important; content: none !important; }
    #viewer-ui .back-btn {
      left: -480px !important;
      color: #ff3b3b !important;
      border: 2px solid #ff3b3b !important;
      transform: translateY(-50%) !important;
    }
    #viewer-ui .next-btn {
      right: -480px !important;
      color: #7CFF00 !important;
      border: 2px solid #7CFF00 !important;
      transform: translateY(-50%) !important;
    }
    #viewer-ui .nav-label { font-weight: 700; }
    #viewer-ui .bottom { position: relative !important; }
    .step-header {
      position: absolute !important;
      top: 8px !important;
      left: 50% !important;
      transform: translateX(-50%) !important;
      width: auto !important;
      justify-content: center !important;
      gap: 10px !important;
    }
    #step-title { text-align: center !important; min-width: 120px !important; display: inline-block !important; }
    #step-title-wrap { position: relative !important; display: inline-block !important; }
    #step-title-wrap .reset-btn { position: absolute !important; left: calc(100% + 10px) !important; top: calc(50% - 5px) !important; transform: translateY(-50%) !important; }
    .step-header .ghost-btn { display: none !important; }

    
    
    
    
    #viewer-ui .nav-label { font-weight: 700; }
    
    
    #viewer-ui .nav-label { font-weight: 700; }
    
    
    
    /* Mobile optimization overrides */
    @media (max-width: 900px) {
      #viewer { height: 92vh; }

      #viewer-ui .bottom {
        max-height: calc(38vh - 10px);
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        padding-bottom: 10px;
      }

      .color-row {
        flex-direction: column;
        align-items: stretch;
        gap: 6px;
      }

      .color-group {
        width: 100%;
        justify-content: space-between;
      }

      .color-label {
        min-width: 70px;
      }

      #step-finitura select,
      #step-colori select {
        width: 100%;
        min-width: 0;
      }

      #step-accessori { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }

    @media (max-width: 640px) {
      #viewer { height: 92vh; }

      #viewer-ui .back-btn,
      #viewer-ui .next-btn {
        top: auto !important;
        bottom: 8px !important;
        width: 72px !important;
        height: 34px !important;
      }

      #viewer-ui .back-btn { left: 8px !important; }
      #viewer-ui .next-btn { right: 8px !important; }

      #step-accessori { grid-template-columns: 1fr; }
    }
    /* Mobile nav button placement fixes */
    @media (max-width: 900px) {
      #viewer-ui .bottom { padding-bottom: 58px !important; }
      #viewer-ui .back-btn,
      #viewer-ui .next-btn {
        top: auto !important;
        bottom: 10px !important;
        width: 72px !important;
        height: 34px !important;
      }
      #viewer-ui .back-btn { left: 10px !important; }
      #viewer-ui .next-btn { right: 10px !important; }
    }
    /* Mobile: move Back/Go above menus inside bottom panel */
    @media (max-width: 900px) {
      .step-header { position: static !important; transform: none !important; }
      #viewer-ui .bottom { padding-top: 64px !important; }
      #viewer-ui .back-btn,
      #viewer-ui .next-btn {
        top: 12px !important;
        bottom: auto !important;
        width: 72px !important;
        height: 34px !important;
      }
      #viewer-ui .back-btn { left: 12px !important; }
      #viewer-ui .next-btn { right: 12px !important; }
    }
</style>
</head>
<body>

<div id="viewer">
  <div id="loading">
    <div id="loading-text">Caricamento modello 0%</div>
    <div id="loading-bar">
      <div id="loading-fill"></div>
    </div>
  </div>
  <div id="viewer-ui">
    <div class="top">
      <h1>FISHER 40</h1>
      <div id="price-tag">€ 6.000</div>
      <button id="order-btn" type="button" class="is-hidden" style="display:none;">Ordina</button>
      <button id="screenshot-btn" type="button" title="Salva screenshot">TAKE A PHOTO</button>
    </div>
    <div id="controls-overlay" class="controls-overlay">
      Mouse: trascina per ruotare, tasto destro per pan, rotella per zoom.<br>
      Touch: 1 dito ruota, 2 dita pan, pinch per zoom.
    </div>
<div class="bottom">
      <div class="step-header">

        <button class="nav-btn back-btn is-hidden" onclick="goBack()" aria-label="Back">
          <span class="sr-only">Back</span>            <span class="nav-label">Back</span>
        </button>
        <div id="step-title-wrap">
          <div id="step-title">Finitura</div>
          <button class="nav-btn reset-btn is-hidden" onclick="resetAllAccessories()" aria-label="Reset accessori">
            <span class="sr-only">Reset accessori</span>
              <span class="reset-label">RESET</span>
          </button>
        </div>
        <button class="nav-btn next-btn is-hidden" onclick="goNext()" aria-label="Go">
          <span class="sr-only">Go</span>            <span class="nav-label">Go</span>
        </button>
        <button class="nav-btn ghost-btn" aria-hidden="true" tabindex="-1"></button>
      </div>
      <div id="step-finitura" class="step">
        <div id="finish-select"></div>
      </div>
      <div id="step-colori" class="step hidden">
        <div class="color-row">
          <div class="color-group" id="group-hull">
            <span class="color-label">Hull</span>
            <div id="hull-colors"></div>
          </div>
          <div class="color-group" id="group-deck">
            <span class="color-label">Deck</span>
            <div id="deck-colors"></div>
          </div>
          <div class="color-group" id="group-hatches">
            <span class="color-label">Doors</span>
            <div id="hatches-colors"></div>
          </div>
          <div class="color-group" id="group-antiskid">
            <span class="color-label">Antiskid</span>
            <div id="antiskid-select"></div>
          </div>
        </div>
      </div>
            <div id="step-accessori" class="step hidden">
        <label><input type="checkbox" data-accessory="tientibene" onchange="toggleAccessory('tientibene', this.checked)"> Tientibene</label>
        <label><input type="checkbox" data-accessory="panca" onchange="toggleAccessory('panca', this.checked)"> Panca</label>
        <label><input type="checkbox" data-accessory="schienale" onchange="toggleAccessory('schienale', this.checked)"> Schienale</label>
        <label><input type="checkbox" data-accessory="supporto" onchange="toggleAccessory('supporto', this.checked)"> Supporto motore</label>
        <label><input type="checkbox" data-accessory="motore" onchange="toggleAccessory('motore', this.checked)"> Motore</label>
        <label><input type="checkbox" data-accessory="impianto" onchange="toggleAccessory('impianto', this.checked)"> Impianto elettrico</label>
        <label><input type="checkbox" data-accessory="batteria" onchange="toggleAccessory('batteria', this.checked)"> Batteria al Litio</label>
        <label><input type="checkbox" data-accessory="fishfinder" onchange="toggleAccessory('fishfinder', this.checked)"> Fishfinder</label>
        <label><input type="checkbox" data-accessory="trolling" onchange="toggleAccessory('trolling', this.checked)"> Trolling motor</label>
      </div>
    </div>
  </div>
</div>

<div class="home-link"><a href="https://ninga-skiffs.jimdosite.com/" target="_blank" rel="noopener">www.ningaskiffs.com</a></div>

<div id="order-modal" aria-hidden="true">
  <div class="order-dialog" role="dialog" aria-modal="true" aria-labelledby="order-title">
    <div class="order-header">
      <h3 id="order-title">Ordine Configurazione</h3>
      <button class="order-close" type="button">Chiudi</button>
    </div>
    <div class="order-summary">
      <div>
        <div><span class="label">ID</span> <span id="order-id"></span></div>
        <div><span class="label">Finitura</span> <span id="order-finish"></span></div>
        <div><span class="label">Colori</span> <span id="order-colors"></span></div>
        <div><span class="label">Antiskid</span> <span id="order-antiskid"></span></div>
        <div><span class="label">Accessori</span> <span id="order-accessories"></span></div>
        <div><span class="label">Prezzo</span> <span id="order-price"></span></div>
      </div>
      <div class="order-qr" id="order-qr"></div>
    </div>
    <div class="order-grid">
      <label>Nome<input id="order-nome" type="text"></label>
      <label>Cognome<input id="order-cognome" type="text"></label>
      <label>Email<input id="order-email" type="email"></label>
      <label>Telefono<input id="order-telefono" type="tel"></label>
      <label>Indirizzo<input id="order-indirizzo" type="text"></label>
      <label>Città<input id="order-citta" type="text"></label>
      <label>CAP<input id="order-cap" type="text"></label>
      <label>Note<textarea id="order-note"></textarea></label>
    </div>
    <div class="order-actions">
      <button id="order-confirm" class="order-confirm" type="button">Conferma Ordine</button>
      <button id="order-download" type="button">Scarica PDF</button>
    </div>
  </div>
</div>

<div id="ui">
</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js"
    }
  }
</script>


<script src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js';
  import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/controls/OrbitControls.js';
  import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/loaders/GLTFLoader.js';
  import { DRACOLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/loaders/DRACOLoader.js';
  import { MeshoptDecoder } from 'https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/libs/meshopt_decoder.module.js';
  import { RGBELoader } from 'https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/loaders/RGBELoader.js';

  const EMAILJS_SERVICE_ID = 'service_pgrsf1t';
  const EMAILJS_TEMPLATE_ID_CLIENT = 'template_pcbac3j';
  const EMAILJS_TEMPLATE_ID_ADMIN = 'template_sq2cwmp';
  const EMAILJS_PUBLIC_KEY = 'Ds3gpi437iatxxEg1';
  const UPLOAD_ENDPOINT = 'https://ninga-upload-api.vercel.app/api/upload';
  let emailJsReady = false;

  import { Sky } from 'https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/objects/Sky.js';
  import { Water } from 'https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/objects/Water.js';

  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(60, 1.6, 0.1, 100);
  camera.position.set(0, 1.5, 5);

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha:true, preserveDrawingBuffer: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.25));
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.15;
  const viewer = document.getElementById('viewer');
  renderer.setSize(viewer.clientWidth, viewer.clientHeight);
  viewer.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  window.camera = camera;
  window.controls = controls;
  window.camera = camera;
  window.controls = controls;
  controls.enablePan = true;
  controls.enableDamping = true;
  controls.autoRotate = false;
    controls.enableZoom = true;
    renderer.domElement.style.touchAction = 'none';
    controls.touches.ONE = THREE.TOUCH.ROTATE;
    controls.touches.TWO = THREE.TOUCH.DOLLY_PAN;
  let controlsHintHidden = false;
  const controlsOverlay = document.getElementById('controls-overlay');
  function hideControlsOverlay(){
    if(controlsHintHidden) return;
    controlsHintHidden = true;
    if(controlsOverlay) controlsOverlay.classList.add('is-hidden');
  }
  controls.addEventListener('start', hideControlsOverlay);

  const ambient = new THREE.AmbientLight(0xffffff, 0.25);
  scene.add(ambient);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
  dirLight.position.set(4, 6, 3);
  scene.add(dirLight);


  const sky = new Sky();
  sky.scale.setScalar(10000);
  scene.add(sky);
  sky.visible = false;

  const skyUniforms = sky.material.uniforms;
  skyUniforms['turbidity'].value = 1.6;
  skyUniforms['rayleigh'].value = 3.5;
  skyUniforms['mieCoefficient'].value = 0.0025;
  skyUniforms['mieDirectionalG'].value = 0.85;

  const sun = new THREE.Vector3();
  const phi = THREE.MathUtils.degToRad(35);
  const theta = THREE.MathUtils.degToRad(180);
  sun.setFromSphericalCoords(1, phi, theta);
  sky.material.uniforms['sunPosition'].value.copy(sun);

  const pmremGenerator = new THREE.PMREMGenerator(renderer);
  let environmentLoaded = false;
  let water;
  let waterTargetY = -0.49;

  function loadEnvironment(){
    if(environmentLoaded) return;
    environmentLoaded = true;

    new RGBELoader()
      .setPath('hdr/')
      .load('puresky.hdr', (hdrTexture) => {
        const envMap = pmremGenerator.fromEquirectangular(hdrTexture).texture;
        scene.background = envMap;
        scene.environment = envMap;
        hdrTexture.dispose();
        pmremGenerator.dispose();
      });

    const waterGeometry = new THREE.PlaneGeometry(10000, 10000);
    water = new Water(
      waterGeometry,
      {
        textureWidth: 512,
        textureHeight: 512,
        waterNormals: new THREE.TextureLoader().load(
          'https://threejs.org/examples/textures/waternormals.jpg',
          (texture) => {
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
          }
        ),
        sunDirection: new THREE.Vector3(),
        sunColor: 0xffffff,
        waterColor: 0x0f7a4a,
        alpha: 0.65,
        distortionScale: 0.05,
        fog: scene.fog !== undefined
      }
    );
    water.material.transparent = true;
    water.rotation.x = -Math.PI / 2;
    water.position.y = waterTargetY;
    scene.add(water);
  }

  let hullMat, deckMat, hatchesMat;
  let bottazzoMat, scrittaMat;
  let chirpTexture = null;
  const accessories = {};
  const antiskidEvaMeshes = [];
  const schienaleMeshes = [];
  const chirpMeshes = [];
  const trollingMeshes = [];
  const accessoryMeshMap = {
    schienale: ['mesh_0_2'],
    antiskid_eva: ['mesh_0_1'],
    fishfinder: ['mesh_0']
  };
  const accessoryMeshNames = new Set(Object.values(accessoryMeshMap).flat());
  const sounds = {
    bg: new Audio('audio/gabbiani.mp3'),
    on: new Audio('audio/click.mp3'),
    off: new Audio('audio/blip.mp3')
  };
  sounds.bg.loop = true;
  sounds.bg.volume = 0.35;
  sounds.on.volume = 0.8;
  sounds.off.volume = 0.8;
  let audioUnlocked = false;
  let audioEnabled = true;

  function unlockAudio(){
    if(!audioEnabled) return;
    if(audioUnlocked) return;
    audioUnlocked = true;
    sounds.bg.play().catch(() => {});
  }

  function setAudioEnabled(enabled, fromUser = false){
    audioEnabled = enabled;
    sounds.bg.muted = !enabled;
    sounds.on.muted = !enabled;
    sounds.off.muted = !enabled;
    const btn = document.getElementById('audio-toggle');
    if(btn){
      btn.textContent = enabled ? 'Audio On' : 'Audio Off';
      btn.setAttribute('aria-pressed', String(!enabled));
    }
    if(!enabled){
      sounds.bg.pause();
      return;
    }
    if(fromUser){
      audioUnlocked = true;
      sounds.bg.play().catch(() => {});
    }else{
      unlockAudio();
    }
  }

  document.addEventListener('pointerdown', unlockAudio, { once: true });
  document.addEventListener('keydown', unlockAudio, { once: true });
  document.addEventListener('pointerdown', hideControlsOverlay, { once: true });
  document.addEventListener('keydown', hideControlsOverlay, { once: true });
  const accessoryKeys = [
    'tientibene',
    'panca',
    'schienale',
    'motore',
    'supporto',
    'trolling',
    'fishfinder',
    'impianto',
    'batteria'
  ];
  const accessoryGroups = {
    panca: [],
    tientibene: [],
    schienale: [],
    motore: [],
    supporto: [],
    trolling: [],
    fishfinder: [],
    impianto: [],
    batteria: []
  };
  function getAccessoryKey(objName, matName){
    const name = (objName || '').toLowerCase();
    const mat = (matName || '').toLowerCase();
    if(name.includes('tientibene')) return 'tientibene';
    if(name.includes('panca')) return 'panca';
    if(name.includes('schienale')) return 'schienale';
    if(name.includes('supporto')) return 'supporto';
    if(name.includes('trolling')) return 'trolling';
    if(name.includes('fuoribordo')) return 'motore';
    if(name.includes('motore')) return 'motore';
    if(name.includes('fishfinder')) return 'fishfinder';
    if(name.includes('impianto')) return 'impianto';
    if(name.includes('batteria')) return 'batteria';
    if(mat.includes('trolling')) return 'trolling';
    if(mat.includes('fuoribordo')) return 'motore';
    return '';
  }

  const loader = new GLTFLoader();
  const dracoLoader = new DRACOLoader();
  dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/libs/draco/');
  dracoLoader.setDecoderConfig({ type: 'js' });
  dracoLoader.preload();
  loader.setCrossOrigin('anonymous');
  loader.setDRACOLoader(dracoLoader);
  loader.setMeshoptDecoder(MeshoptDecoder);
  const loadingOverlay = document.getElementById('loading');
  const loadingText = document.getElementById('loading-text');
  const loadingFill = document.getElementById('loading-fill');
  const mobileRotateQuery = window.matchMedia('(max-width: 900px) and (orientation: portrait)');
  let loadToken = 0;
const accessoryInputs = document.querySelectorAll('#step-accessori input[type="checkbox"]');
  accessoryInputs.forEach((cb) => {
    cb.addEventListener('change', () => {
      updatePrice();
    });
  });
const accessoryDeps = {
    schienale: ['tientibene'],
    motore: ['supporto'],
    batteria: ['impianto'],
    fishfinder: ['impianto', 'tientibene', 'batteria'],
    trolling: ['batteria']
  };
  const accessoryLabels = {
    tientibene: 'Tientibene',
    panca: 'Panca',
    schienale: 'Schienale',
    motore: 'Motore',
    supporto: 'Supporto motore',
    trolling: 'Trolling motor',
    fishfinder: 'Fishfinder',
    impianto: 'Impianto elettrico',
    batteria: 'Batteria al Litio'
  };

  function setAccessoryChecked(key, checked, silent = false){
    const cb = document.querySelector(`#step-accessori input[data-accessory="${key}"]`);
    if(cb) cb.checked = checked;
    toggleAccessory(key, checked, silent);
  }

    function updateAccessoryRules(){
      accessoryInputs.forEach((cb) => {
        const key = cb.dataset.accessory;
        const deps = accessoryDeps[key];
        const allowed = !deps || deps.every(dep => {
          const depCb = document.querySelector(`#step-accessori input[data-accessory="${dep}"]`);
          return depCb?.checked;
        });
        cb.disabled = !allowed;
        const label = cb.closest('label');
        if(label){
          label.classList.toggle('is-locked', !allowed);
        }
        if(!allowed && cb.checked){
          setAccessoryChecked(key, false, true);
        }
      });
    }


      function updateNavLabels(step){      const nextBtn = document.querySelector('#viewer-ui .next-btn .nav-label');      if(nextBtn){        nextBtn.textContent = step === 'accessori' ? 'END' : 'GO';      }    }      function syncAccessoryUI(){
    accessoryInputs.forEach((cb) => {
      const key = cb.dataset.accessory;
      if(key) toggleAccessory(key, cb.checked, true);
    });
    updateAccessoryRules();
    updatePrice();
  }

    function resetAccessoryUI(){
    accessoryInputs.forEach((cb) => {
      cb.checked = false;
    });
    syncAccessoryUI();
  }
  const glbUrls = [
    'models/fisher40_base_free_softsafe.glb?v=6',
    'models/fisher40_base_nodraco.glb?v=6'
  ];
  let glbIndex = 0;

  function loadGlb(){
    const url = glbUrls[glbIndex];
    const token = ++loadToken;
    let progressSeen = false;
    let loadTimeout;
    if(loadingOverlay){
      loadingOverlay.style.display = 'flex';
    }
    if(loadingText){
      loadingText.textContent = 'Caricamento modello 0%';
    }
    if(loadingFill){
      loadingFill.style.width = '0%';
    }
    loadTimeout = setTimeout(() => {
      if(token !== loadToken) return;
      if(loadingText){
        loadingText.textContent = 'Caricamento lento...';
      }
      if(!progressSeen && glbIndex < glbUrls.length - 1){
        glbIndex += 1;
        loadGlb();
      }
    }, 6000);
    loader.load(url, (gltf) => {
    if(token !== loadToken) return;
    if(loadTimeout) clearTimeout(loadTimeout);
    gltf.scene.scale.set(0.3,0.3,0.3);
    gltf.scene.position.set(0,-1,0);
    scene.add(gltf.scene);

    // Removed axes helper for clean view

    gltf.scene.traverse(obj => {
      if(obj.isMesh){
        const matName = obj.material?.name || '';
        const matNameLower = matName.toLowerCase();
        if(matName === 'Hull') hullMat=obj.material;
        if(matName === 'Deck') deckMat=obj.material;
        if(matName === 'Hatches' || matName === 'hatches' || matName === 'Portelli') hatchesMat=obj.material;
        if(matName === 'Gomma') bottazzoMat=obj.material;
        if(matName === 'Scritta' || matNameLower.includes('scritta')) scrittaMat=obj.material;
        if(!scrittaMat && obj.name==='Scritta') scrittaMat=obj.material;
        if(!scrittaMat && typeof obj.material?.name === 'string' && obj.material.name.toLowerCase().includes('scritta')) {
          scrittaMat = obj.material;
        }
        if(matNameLower.includes('chirp') || obj.name?.toLowerCase().includes('chirp')) chirpMeshes.push(obj);
        if(obj.name==='Tientibene') accessories.tientibene=obj;
        if(obj.name==='Panca') accessories.panca=obj;
        if(obj.name==='Schienale' || obj.name?.toLowerCase()==='schienale') accessories.schienale=obj;
        if(obj.name==='Motore') accessories.motore=obj;
        if(obj.name==='Fuoribordo') accessories.motore=obj;
        if(obj.name?.toLowerCase()==='supporto') accessories.supporto = obj;
        if(obj.name==='trolling' || obj.name?.toLowerCase()==='trolling') accessories.trolling = obj;
        if(obj.name==='Fishfinder' || obj.name?.toLowerCase()==='fishfinder') accessories.fishfinder = obj;
        if(obj.name==='Impianto' || obj.name?.toLowerCase()==='impianto' || obj.name==='ImpiantoElettrico' || obj.name?.toLowerCase()==='impiantoelettrico') accessories.impianto = obj;
        if(obj.name==='Batteria' || obj.name?.toLowerCase()==='batteria' || obj.name==='BatteriaLitio' || obj.name?.toLowerCase()==='batterialitio') accessories.batteria = obj;

        const objNameLower = (obj.name || '').toLowerCase();
        const parentNameLower = (obj.parent?.name || '').toLowerCase();
        const grandParentNameLower = (obj.parent?.parent?.name || '').toLowerCase();
        const nameCandidates = [objNameLower, parentNameLower, grandParentNameLower];
        const isAccessoryName = (n) => (
          n.includes('tientibene') ||
          n.includes('panca') ||
          n.includes('schienale') ||
          n.includes('supporto') ||
          n.includes('trolling') ||
          n.includes('fuoribordo') ||
          n.includes('motore') ||
          n.includes('fishfinder') ||
          n.includes('impianto') ||
          n.includes('batteria') ||
          n.includes('antiskid_eva') ||
          n.includes('chirp')
        );
        const isAccessoryMaterial = (m) => (
          m.includes('clean silver') ||
          m.includes('procedural skin') ||
          m.includes('manopola') ||
          m.includes('fuoribordo') ||
          m.includes('trolling') ||
          m.includes('chirp')
        );
        const isMappedAccessoryMesh = accessoryMeshNames.has(obj.name);
        const shouldHideByPrefix =
          nameCandidates.some((n) => isAccessoryName(n)) ||
          isAccessoryMaterial(matNameLower) ||
          isMappedAccessoryMesh;
        if(shouldHideByPrefix){
          obj.visible = false;
        }
        if(nameCandidates.some(n => n === 'antiskid_eva' || n.includes('antiskid') || n.includes('eva')) || obj.name === 'mesh_0_1' || obj.name === 'EVA' || obj.name?.toLowerCase().includes('eva') || matNameLower.includes('sponge')){          antiskidEvaMeshes.push(obj);          obj.material = obj.material?.clone?.() || obj.material;          obj.visible = false;        }
        if(obj.name?.toLowerCase()==='fishfinder'){
          // Clone to avoid changing shared materials (e.g. Doors).
          obj.material = obj.material?.clone?.() || obj.material;
          if(obj.material){
            if('metalness' in obj.material) obj.material.metalness = 0;
            if('roughness' in obj.material) obj.material.roughness = 0.9;
            obj.material.needsUpdate = true;
          }
        }
        if(obj.name?.toLowerCase()==='schienale' || obj.name === 'mesh_0_2'){
          schienaleMeshes.push(obj);
        }
        if(obj.name?.toLowerCase().includes('trolling')){
          trollingMeshes.push(obj);
        }

        const groupKey =
          getAccessoryKey(obj.name, '') ||
          getAccessoryKey(obj.parent?.name, '') ||
          getAccessoryKey(obj.parent?.parent?.name, '') ||
          (obj.name?.toLowerCase().includes('chirp') ? 'fishfinder' : '') ||
          (matNameLower.includes('chirp') ? 'fishfinder' : '') ||
          (accessoryMeshMap.schienale?.includes(obj.name) ? 'schienale' : '') ||
          (accessoryMeshMap.tientibene?.includes(obj.name) ? 'tientibene' : '') ||
          (accessoryMeshMap.panca?.includes(obj.name) ? 'panca' : '') ||
          (accessoryMeshMap.supporto?.includes(obj.name) ? 'supporto' : '') ||
          (accessoryMeshMap.motore?.includes(obj.name) ? 'motore' : '') ||
          (accessoryMeshMap.trolling?.includes(obj.name) ? 'trolling' : '');
        if(groupKey && accessoryGroups[groupKey]) accessoryGroups[groupKey].push(obj);
      }
    });

    // Preload scritta textures once
    if(!scrittaTextures.black){
      scrittaTextures.black = textureLoader.load('images/Scritta_black.png', (t) => {
        t.wrapS = t.wrapT = THREE.MirroredRepeatWrapping;
        t.repeat.x = -1;
        t.repeat.y = -1;
        t.flipY = false;
      });
    }
    if(!scrittaTextures.white){
      scrittaTextures.white = textureLoader.load('images/Scritta_white.png', (t) => {
        t.wrapS = t.wrapT = THREE.MirroredRepeatWrapping;
        t.repeat.x = -1;
        t.repeat.y = -1;
        t.flipY = false;
      });
    }
    if(!chirpTexture){
      chirpTexture = textureLoader.load('images/Chirp.png', (t) => {
        t.wrapS = t.wrapT = THREE.RepeatWrapping;
        t.colorSpace = THREE.SRGBColorSpace;
        t.flipY = false;
        t.needsUpdate = true;
        applyChirpTextureToMeshes();
      });
    }
    if(!antiskidTexture){
      antiskidTexture = textureLoader.load('images/antiskid.jpg', (t) => {
        t.wrapS = t.wrapT = THREE.RepeatWrapping;
        t.repeat.set(0.8, 0.8);
      });
    }

    if(hullMat) hullMat.color.set('#ffffff');
    if(deckMat) deckMat.color.set('#ffffff');
    if(hatchesMat) hatchesMat.color.set('#ffffff');
    if(bottazzoMat) bottazzoMat.color.set('#000000');
    if(scrittaMat){
      scrittaMat.map = scrittaTextures.black;
      scrittaMat.color.set('#ffffff');
      scrittaMat.transparent = true;
      scrittaMat.alphaTest = 0.5;
      scrittaMat.needsUpdate = true;
    }
    applyChirpTextureToMeshes();
    Object.values(accessories).forEach(a=>a.visible=false);
    Object.values(accessoryGroups).forEach(list => list.forEach(a => a.visible = false));
    antiskidEvaMeshes.forEach(mesh => mesh.visible = false);
    applyEvaTextureToMeshes(antiskidEvaMeshes);
    syncSchienaleMaterial();
    syncTrollingMaterial();
    applyMaterialOverrides(gltf.scene);

    // Auto-center and frame model in the camera view
    const box = new THREE.Box3().setFromObject(gltf.scene);
    const size = new THREE.Vector3();
    const center = new THREE.Vector3();
    box.getSize(size);
    box.getCenter(center);
    gltf.scene.position.sub(center);
    gltf.scene.position.add(new THREE.Vector3(-0.05, 0, 0));

    const maxDim = Math.max(size.x, size.y, size.z);
    const fov = camera.fov * (Math.PI / 180);
    let cameraZ = Math.abs(maxDim / (2 * Math.tan(fov / 2)));
    cameraZ *= 1;
    camera.position.set(0.2, maxDim * 0.2, cameraZ * 0.9);
    camera.lookAt(0, 0, 0);
    controls.target.set(0, 0, 0);
    controls.update();

    controls.minDistance = cameraZ * 0.4;
      controls.maxDistance = cameraZ * 1.4;

      waterTargetY = -maxDim * 0.12 + 0.045;
      if(water){
        water.position.y = waterTargetY;
      }
      syncAccessoryUI();
      if(loadingOverlay){
        loadingOverlay.style.display = 'none';
      }
      loadEnvironment();
    }, (xhr) => {
      if(token !== loadToken) return;
      progressSeen = true;
      if(!xhr || !loadingFill || !loadingText) return;
      if(xhr.total){
        const pct = Math.min(100, Math.round((xhr.loaded / xhr.total) * 100));
        loadingFill.style.width = `${pct}%`;
        loadingText.textContent = `Caricamento modello ${pct}%`;
      }else{
        loadingText.textContent = 'Caricamento modello...';
      }
    }, err => {
      if(token !== loadToken) return;
      if(loadTimeout) clearTimeout(loadTimeout);
      if(glbIndex < glbUrls.length - 1){
        glbIndex += 1;
        loadGlb();
        return;
      }
      console.error('Errore caricamento GLB:', err);
      if(loadingText){
        const details = err?.message ? ` (${err.message})` : '';
        loadingText.textContent = `Errore caricamento modello${details}`;
      }
    });
    }

  function applyMobileRotate(){
    renderer.setSize(viewer.clientWidth, viewer.clientHeight);
    camera.aspect = viewer.clientWidth / viewer.clientHeight;
    camera.updateProjectionMatrix();
  }

  loadGlb();

  let finishSelected = false;
  let hullSelected = false;
  let deckSelected = false;
  let hatchesSelected = false;
  let currentStep = 'finitura';
  let accessoriUnlocked = false;
  let selectedFinish = null;
  let selectedHull = null;
  let selectedDeck = null;
  let selectedHatches = null;
  let selectedHullLabel = '';
  let selectedDeckLabel = '';
    let selectedDeckMode = null;
    let selectedHullMode = null;
    let selectedHatchesMode = null;
  let selectedHatchesLabel = '';
    let presetLocked = false;
    let presetName = '';
  let hullDark = false;
  let deckDark = false;
  let wrappingWhite = false;
  let hatchesAuto = true;
  const colorSelects = { hull: null, deck: null, hatches: null };
  function setColorLabel(group, label){
    if(!label) return;
    if(group === 'hull') selectedHullLabel = label;
    else if(group === 'deck') selectedDeckLabel = label;
    else if(group === 'hatches') selectedHatchesLabel = label;
  }
  const gelcoatTriggers = { hull: null, deck: null, hatches: null };
  const textureLoader = new THREE.TextureLoader();
  let antiskidTexture = null;
  let antiskidPrintTexture = null;
  let antiskidEvaTexture = null;
  let ruggedTexture = null;
  function applyMaterialOverrides(root){
    if(!root) return;
    let yamahaMat = null;
    let plasticMat = null;
    root.traverse((obj) => {
      if(!obj.isMesh || !obj.material) return;
      const list = Array.isArray(obj.material) ? obj.material : [obj.material];
      list.forEach((m) => {
        if(!m?.name) return;
        const name = m.name.toLowerCase();
        if(name === 'yamaha') yamahaMat = m;
        if(name === 'plastic') plasticMat = m;
      });
    });
    if(!yamahaMat && !plasticMat) return;
    if(yamahaMat && yamahaMat.color) yamahaMat.color.set('#696969');
    if(plasticMat && plasticMat.color) plasticMat.color.set('#000000');

    const toKey = (name) => (name || '').toLowerCase().replace(/\./g, '');
    const yamahaTargets = new Set(['fuoribordostl001','fuoribordostl002','fuoribordostl004']);
    const plasticTargets = new Set(['fuoribordostl','fuoribordostl003','fishfinder','trolling002','trolling003','trolling004','trolling005']);

    root.traverse((obj) => {
      if(!obj.isMesh) return;
      const key = toKey(obj.name);
      if(yamahaMat && yamahaTargets.has(key)){
        obj.material = yamahaMat;
      }
      if(plasticMat && plasticTargets.has(key)){
        obj.material = plasticMat;
      }
    });
  }
  let selectedAntiskid = '';
  const scrittaTextures = {
    black: null,
    white: null
  };

    const priceTable = {
      base: 6000,
      finishPct: {
        gelcoat: 0.0,
        paint: 0.0
      },
      colorUpcharges: {
        hull: { white: 0, color: 150, wrapping: 500, rugged: 250 },
        deck: { white: 0, color: 150, wrapping: 500, rugged: 250 },
        hatches: { white: 0, color: 50, wrapping: 150, rugged: 100 }
      },
      accessories: {
        tientibene: 500,
        panca: 1000,
        schienale: 250,
        motore: 3000,
        supporto: 150,
        trolling: 2000,
        fishfinder: 800,
        impianto: 500,
        batteria: 300,
        antiskid: {
          none: 0,
          paint: 150,
          print: 500,
          eva: 300
        }
      }
    };
function updatePrice(){
    let total = priceTable.base;
    if(selectedFinish){
      total += priceTable.base * (priceTable.finishPct[selectedFinish] || 0);
    }
    const isChecked = (name) =>
      document.querySelector(`#step-accessori input[data-accessory="${name}"]`)?.checked;
    const isVisible = (name) =>
      accessories[name]?.visible ||
      (accessoryGroups[name] && accessoryGroups[name].some(obj => obj.visible));
    const isSelected = (name) => Boolean(isChecked(name) || isVisible(name));
    total += isSelected('tientibene') ? priceTable.accessories.tientibene : 0;
    total += isSelected('panca') ? priceTable.accessories.panca : 0;
    total += isSelected('schienale') ? priceTable.accessories.schienale : 0;
    total += isSelected('motore') ? priceTable.accessories.motore : 0;
    total += isSelected('supporto') ? priceTable.accessories.supporto : 0;
    total += isSelected('trolling') ? priceTable.accessories.trolling : 0;
    total += isSelected('fishfinder') ? priceTable.accessories.fishfinder : 0;
    total += isSelected('impianto') ? priceTable.accessories.impianto : 0;
    total += isSelected('batteria') ? priceTable.accessories.batteria : 0;      total += getAntiskidPrice();
      const modePrice = (group, mode) => {
        const table = priceTable?.colorUpcharges?.[group];
        if(!table) return 0;
        return table[mode || 'white'] || 0;
      };
      total += modePrice('hull', selectedHullMode);
      total += modePrice('deck', selectedDeckMode);
      total += modePrice('hatches', selectedHatchesMode);
    const el = document.getElementById('price-tag');
    if(el) el.textContent = `${"\u20AC"} ${total.toLocaleString('it-IT')}`;
  }

  function showStep(step){      updateNavLabels(step);
    if(step === 'accessori' && !accessoriUnlocked){
      step = 'colori';
    }
    if(step !== 'accessori'){
      accessoriUnlocked = false;
    }
    document.getElementById('step-finitura').classList.add('hidden');
    document.getElementById('step-colori').classList.add('hidden');
    document.getElementById('step-accessori').classList.add('hidden');
    document.getElementById(`step-${step}`).classList.remove('hidden');

    const backBtn = document.querySelector('#viewer-ui .back-btn');
    const resetBtn = document.querySelector('#viewer-ui .reset-btn');
    const nextBtn = document.querySelector('#viewer-ui .next-btn');
    if(backBtn){
      const isFirst = step === 'finitura';
      backBtn.classList.toggle('is-disabled', isFirst);
      backBtn.setAttribute('aria-disabled', isFirst ? 'true' : 'false');
      backBtn.classList.toggle('is-hidden', isFirst);
    }
    if(resetBtn){
      resetBtn.classList.toggle('is-hidden', step !== 'accessori');
    }
    const orderBtn = document.getElementById('order-btn');
    if(orderBtn){
      orderBtn.classList.toggle('is-hidden', step !== 'accessori');
      orderBtn.style.display = step === 'accessori' ? 'block' : 'none';
    }
    if(nextBtn){
      const showNext = step !== 'finitura' ? true : finishSelected;
      nextBtn.classList.toggle('is-hidden', !showNext);
    }
        const title = document.getElementById('step-title');
    if(title){
      if(step === 'finitura') title.textContent = 'Finitura';
      else if(step === 'colori') title.textContent = 'Colori';
      else if(step === 'accessori') title.textContent = 'Accessori';
    }
    const viewerEl = document.getElementById('viewer');
    if(viewerEl){
      viewerEl.classList.toggle('step-finitura', step === 'finitura');
      viewerEl.classList.toggle('step-colori', step === 'colori');
      viewerEl.classList.toggle('step-accessori', step === 'accessori');
    }
    currentStep = step;
  }

  const colorPalettes = {
    gelcoat: {
      hull: [
        { label: 'White', color: '#ffffff' },
        { label: 'Grey', color: '#a9a9a9' },
        { label: 'Aquamarina', color: '#7fffd4' },
        { label: 'Blue', color: '#000080' },
        { label: 'Orange', color: '#FF8C00' },
        { label: 'Pink', color: '#FF69B4' }
      ],
      deck: [
        { label: 'White', color: '#ffffff' },
        { label: 'Grey', color: '#a9a9a9' },
        { label: 'Acquamarina', color: '#7fffd4' },
        { label: 'Blue', color: '#000080' },
        { label: 'Orange', color: '#FF8C00' },
        { label: 'Pink', color: '#FF69B4' }
      ],
      hatches: [
        { label: 'White', color: '#ffffff' },
        { label: 'Grey', color: '#a9a9a9' },
        { label: 'Acquamarina', color: '#7fffd4' },
        { label: 'Blue', color: '#000080' },
        { label: 'Orange', color: '#FF8C00' },
        { label: 'Pink', color: '#FF69B4' }
      ]
    },
    wrapping: {
      hull: [
        { label: 'Honey', color: '#ffffff', texture: 'images/wrapping/Honey.jpg', scale: 0.5 },
        { label: 'Wave', color: '#234a63', texture: 'images/wrapping/Wave.jpg', scale: 0.7 },
        { label: 'Carbon', color: '#333333', texture: 'images/wrapping/Carbon.jpg', scale: 1 },
        { label: 'Camu', color: '#3b4a3a', texture: 'images/wrapping/Camu.jpg', scale: 0.2 },
        { label: 'Green wave', color: '#ffffff', texture: 'images/wrapping/Greenwave.jpg', scale: 0.7 },
        { label: 'Abstract', color: '#ffffff', texture: 'images/wrapping/Abstract.jpg', scale: 0.5 }
      ],
      deck: [
        { label: 'Honey', color: '#ffffff', texture: 'images/wrapping/Honey.jpg', scale: 0.5 },
        { label: 'Wave', color: '#234a63', texture: 'images/wrapping/Wave.jpg', scale: 0.7 },
        { label: 'Carbon', color: '#333333', texture: 'images/wrapping/Carbon.jpg', scale: 1 },
        { label: 'Camu', color: '#3b4a3a', texture: 'images/wrapping/Camu.jpg', scale: 0.2 },
        { label: 'Green wave', color: '#ffffff', texture: 'images/wrapping/Greenwave.jpg', scale: 0.7 },
        { label: 'Abstract', color: '#ffffff', texture: 'images/wrapping/Abstract.jpg', scale: 0.5 }
      ],
      hatches: [
        { label: 'Honey', color: '#ffffff', texture: 'images/wrapping/Honey.jpg', scale: 0.5 },
        { label: 'Wave', color: '#234a63', texture: 'images/wrapping/Wave.jpg', scale: 0.7 },
        { label: 'Carbon', color: '#333333', texture: 'images/wrapping/Carbon.jpg', scale: 1 },
        { label: 'Camu', color: '#3b4a3a', texture: 'images/wrapping/Camu.jpg', scale: 0.2 },
        { label: 'Green wave', color: '#ffffff', texture: 'images/wrapping/Greenwave.jpg', scale: 0.7 },
        { label: 'Abstract', color: '#ffffff', texture: 'images/wrapping/Abstract.jpg', scale: 0.5 }
      ]
    },
    paint: {
      hull: [
        { label: 'White', color: '#FFFFFF' },
        { label: 'Dark', color: '#808080' },
        { label: 'Green', color: '#ADFF2F' },
        { label: 'Blue', color: '#0000CD' },
        { label: 'Yellow', color: '#FFFF00' },
        { label: 'Black', color: '#000000' }
      ],
      deck: [
        { label: 'White', color: '#FFFFFF' },
        { label: 'Dark', color: '#808080' },
        { label: 'Green', color: '#ADFF2F' },
        { label: 'Blue', color: '#0000CD' },
        { label: 'Yellow', color: '#FFFF00' },
        { label: 'Black', color: '#000000' }
      ],
      hatches: [
        { label: 'White', color: '#FFFFFF' },
        { label: 'Dark', color: '#808080' },
        { label: 'Green', color: '#ADFF2F' },
        { label: 'Blue', color: '#0000CD' },
        { label: 'Yellow', color: '#FFFF00' },
        { label: 'Black', color: '#000000' }
      ]
    },
    rugged: {
      all: [
        { label: 'Lagoon', color: '#556B2F' },
        { label: 'Seals', color: '#2F4F4F' },
        { label: 'Acid', color: '#7FFF00' }
      ]
    }
  };

  function renderColorSelect(group, containerId, colors){
    const container = document.getElementById(containerId);
    if(!container) return;
    container.innerHTML = '';
    const select = document.createElement('select');
    const placeholder = document.createElement('option');
    placeholder.textContent = 'Select';
    placeholder.value = '';
    placeholder.disabled = true;
    placeholder.selected = true;
    select.appendChild(placeholder);
    select.dataset.group = group;
    colorSelects[group] = select;
    let isInit = true;
    colors.forEach(({ label, color, texture, scale }) => {
      const opt = document.createElement('option');
      opt.textContent = label;
      opt.value = color || '';
      if(texture) opt.dataset.texture = texture;
      if(scale) opt.dataset.scale = scale;
      select.appendChild(opt);
    });
    select.addEventListener('change', () => {
      const opt = select.selectedOptions[0];
      if(!opt || !opt.value) return;
      const proxyBtn = {
          textContent: opt.textContent,
          dataset: {
          texture: opt.dataset.texture,
          scale: opt.dataset.scale
        }
      };
      setColorLabel(group, opt.textContent);
      if(group === 'hull') setHull(opt.value, proxyBtn);
      else if(group === 'deck') setDeck(opt.value, proxyBtn);
      else setHatches(opt.value, proxyBtn, !isInit);
      isInit = false;
    });
    container.appendChild(select);
  }
    function renderGelcoatMenu(group, containerId, colors, wrappingOptions, ruggedOptions){
    const container = document.getElementById(containerId);
    if(!container) return;
    container.innerHTML = '';

    const select = document.createElement('select');
    const placeholder = document.createElement('option');
    placeholder.textContent = 'Select';
    placeholder.value = '';
    placeholder.disabled = true;
    placeholder.selected = true;
    select.appendChild(placeholder);

    const whiteEntry = colors.find(c => c.label.toLowerCase() === 'white') || colors[0];
    if(whiteEntry){
      const opt = document.createElement('option');
      opt.textContent = 'White';
      opt.value = whiteEntry.color || '#ffffff';
      select.appendChild(opt);
    }

    const colorEntries = colors.filter(c => c.label.toLowerCase() !== 'white');
    if(colorEntries.length){
      const groupEl = document.createElement('optgroup');
      groupEl.label = 'Color';
      colorEntries.forEach((entry) => {
        const opt = document.createElement('option');
        opt.textContent = entry.label;
        opt.value = entry.color || '';
        groupEl.appendChild(opt);
      });
      select.appendChild(groupEl);
    }

    if(wrappingOptions && wrappingOptions.length){
      const groupEl = document.createElement('optgroup');
      groupEl.label = 'Wrapping';
      wrappingOptions.forEach((entry) => {
        const opt = document.createElement('option');
        opt.textContent = entry.label;
        opt.value = entry.color || '#ffffff';
        if(entry.texture) opt.dataset.texture = entry.texture;
        if(entry.scale) opt.dataset.scale = entry.scale;
        groupEl.appendChild(opt);
      });
      select.appendChild(groupEl);
    }

    if(ruggedOptions && ruggedOptions.length){
      const groupEl = document.createElement('optgroup');
      groupEl.label = 'Rugged';
      ruggedOptions.forEach((entry) => {
        const opt = document.createElement('option');
        opt.textContent = entry.label;
        opt.value = entry.color || '';
        opt.dataset.rugged = '1';
        groupEl.appendChild(opt);
      });
      select.appendChild(groupEl);
    }

          let isInit = true;

      select.addEventListener('change', () => {
      const opt = select.selectedOptions[0];
      if(!opt || !opt.value) return;
      const isRugged = opt.dataset.rugged || (opt.parentElement && opt.parentElement.label === 'Rugged') ? '1' : '';
      const proxyBtn = {
        textContent: opt.textContent,
        dataset: {
          texture: opt.dataset.texture,
          scale: opt.dataset.scale,
          rugged: isRugged
        }
      };
      setColorLabel(group, opt.textContent);
      if(group === 'hull') setHull(opt.value, proxyBtn);
      else if(group === 'deck') setDeck(opt.value, proxyBtn);
      else setHatches(opt.value, proxyBtn, group === 'hatches' && !isInit);
      isInit = false;
    });

    colorSelects[group] = select;
    container.appendChild(select);

    if(whiteEntry){
      select.value = whiteEntry.color || '#ffffff';
      select.dispatchEvent(new Event('change'));
    }
  }

  function renderAntiskidSelect(){
    const container = document.getElementById('antiskid-select');
    if(!container) return;
    container.innerHTML = '';
    const select = document.createElement('select');
    const placeholder = document.createElement('option');
    placeholder.textContent = 'Select';
    placeholder.value = '';
    placeholder.disabled = true;
    placeholder.selected = true;
    select.appendChild(placeholder);
    select.addEventListener('change', () => {
      if(!select.value) return;
      selectedAntiskid = select.value;
        updateAntiskidFinish();
        updatePrice();
    });
    container.appendChild(select);
    updateAntiskidOptions(selectedFinish);
  }

      function resolveFinishMode(btn){
      if(btn?.dataset?.rugged) return 'rugged';
      if(btn?.dataset?.texture) return 'wrapping';
      const label = (btn?.textContent || '').trim().toLowerCase();
      if(label === 'white') return 'white';
      return 'color';
    }

function updateAntiskidOptions(finish){
      const select = document.querySelector('#antiskid-select select');
      if(!select) return;
      const baseOptions = [
        { label: 'None', value: 'none' },
        { label: 'Eva', value: 'eva' },
        { label: 'Paint', value: 'paint' },
        { label: 'Print', value: 'print' }
      ];
      let allowed = baseOptions;
      if(finish === 'gelcoat' || finish === 'paint'){
        const mode = selectedDeckMode || 'color';
        if(mode === 'wrapping'){
          allowed = baseOptions.filter(o => o.value === 'none' || o.value === 'eva' || o.value === 'print');
        }else if(mode === 'rugged'){
          allowed = baseOptions.filter(o => o.value === 'none' || o.value === 'eva' || o.value === 'paint');
        }else{
          allowed = baseOptions;
        }
      }
      select.innerHTML = '';
      const placeholder = document.createElement('option');
      placeholder.textContent = 'Select';
      placeholder.value = '';
      placeholder.disabled = true;
      placeholder.selected = true;
      select.appendChild(placeholder);
      allowed.forEach(({ label, value }) => {
        const opt = document.createElement('option');
        opt.textContent = label;
        opt.value = value;
        select.appendChild(opt);
      });
      if(!allowed.some(opt => opt.value === selectedAntiskid)){
        selectedAntiskid = '';
      }
      select.value = selectedAntiskid || '';
      updateAntiskidFinish();
    }

    function updateColorOptions(finish){
    const palette = colorPalettes[finish] || colorPalettes.gelcoat;
    hullSelected = false;
    deckSelected = false;
    hatchesSelected = false;
    hatchesAuto = true;
    const groupHull = document.getElementById('group-hull');
    const groupDeck = document.getElementById('group-deck');
    const groupHatches = document.getElementById('group-hatches');
    if(finish === 'rugged'){
      if(groupDeck) groupDeck.classList.add('hidden');
      if(groupHatches) groupHatches.classList.add('hidden');
      if(groupHull) groupHull.classList.remove('hidden');
      renderColorSelect('hull', 'hull-colors', palette.all);
      renderColorSelect('deck', 'deck-colors', []);
      renderColorSelect('hatches', 'hatches-colors', []);
    }else if(finish === 'gelcoat' || finish === 'paint'){
      if(groupDeck) groupDeck.classList.remove('hidden');
      if(groupHatches) groupHatches.classList.remove('hidden');
      if(groupHull) groupHull.classList.remove('hidden');
      const wrapPalette = colorPalettes.wrapping || {};
      renderGelcoatMenu('hull', 'hull-colors', palette.hull, wrapPalette.hull || [], colorPalettes.rugged?.all || []);
      renderGelcoatMenu('deck', 'deck-colors', palette.deck, wrapPalette.deck || [], colorPalettes.rugged?.all || []);
      renderGelcoatMenu('hatches', 'hatches-colors', palette.hatches, wrapPalette.hatches || [], colorPalettes.rugged?.all || []);
    }else{
      if(groupDeck) groupDeck.classList.remove('hidden');
      if(groupHatches) groupHatches.classList.remove('hidden');
      if(groupHull) groupHull.classList.remove('hidden');
      renderColorSelect('hull', 'hull-colors', palette.hull);
      renderColorSelect('deck', 'deck-colors', palette.deck);
      renderColorSelect('hatches', 'hatches-colors', palette.hatches);
    }
    updateAntiskidOptions(finish);
  }

  function applyAntiskid(mat, color){
    if(!mat) return;
    if(!antiskidTexture){
      mat.color.set(color);
      mat.needsUpdate = true;
      antiskidTexture = textureLoader.load('images/antiskid.jpg', (t) => {
        t.wrapS = t.wrapT = THREE.RepeatWrapping;
        t.repeat.set(0.8, 0.8);
        t.colorSpace = THREE.SRGBColorSpace;
        t.flipY = false;
        mat.map = t;
        mat.color.set(color);
        mat.needsUpdate = true;
      });
      return;
    }
    mat.map = antiskidTexture;
    mat.color.set(color);
    mat.needsUpdate = true;
  }
  function applyRuggedTexture(mat, color){
    if(!mat) return;
    if(!ruggedTexture){
      ruggedTexture = textureLoader.load('images/rugged.jpg', (t) => {
        t.wrapS = t.wrapT = THREE.RepeatWrapping;
        t.repeat.set(0.5, 0.5);
        t.colorSpace = THREE.SRGBColorSpace;
        t.flipY = false;
        t.needsUpdate = true;
        applyRuggedTexture(mat, color);
      });
      return;
    }
    mat.map = ruggedTexture;
    mat.userData.baseMap = ruggedTexture;
    mat.color.set(color);
    if('metalness' in mat) mat.metalness = 0;
    if('roughness' in mat) mat.roughness = 1;
    if('vertexColors' in mat) mat.vertexColors = false;
    mat.needsUpdate = true;
  }

  function applyAntiskidVariant(mat, color, mode){
    if(!mat) return;
    if(mode === 'paint'){
      applyAntiskid(mat, color);
      return;
    }
    applyAntiskid(mat, color);
  }

    function applyEvaTextureToMeshes(meshes){
    if(!meshes?.length) return;
    const applyTexture = (tex) => {
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(0.4, 0.4);
        tex.center.set(0.5, 0.5);
        tex.rotation = Math.PI / 2;
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.flipY = false;
      tex.needsUpdate = true;
      meshes.forEach((mesh) => {
        if(!mesh) return;
        ensurePlanarUv(mesh);
        const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
        materials.forEach((mat) => {
          if(!mat) return;
          mat.map = tex;
          if(mat.color) mat.color.set('#ffffff');
          if('metalness' in mat) mat.metalness = 0;
          if('roughness' in mat) mat.roughness = 1;
          mat.needsUpdate = true;
        });
      });
    };
    if(antiskidEvaTexture){
      applyTexture(antiskidEvaTexture);
      return;
    }
    antiskidEvaTexture = textureLoader.load('images/teak.jpg', (t) => {
      applyTexture(t);
    });
  }

  
    function applyPaintTextureToMeshes(meshes, color){
      if(!meshes?.length) return;
      const applyTexture = (tex) => {
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(1, 1);
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.flipY = false;
        tex.needsUpdate = true;
        meshes.forEach((mesh) => {
          if(!mesh) return;
          ensurePlanarUv(mesh);
          const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
          materials.forEach((mat) => {
            if(!mat) return;
            mat.map = tex;
            if(mat.color) mat.color.set(color || '#ffffff');
            if('metalness' in mat) mat.metalness = 0;
            if('roughness' in mat) mat.roughness = 1;
            mat.needsUpdate = true;
          });
        });
      };
      if(antiskidTexture){
        applyTexture(antiskidTexture);
        return;
      }
      antiskidTexture = textureLoader.load('images/antiskid.jpg', (t) => {
        applyTexture(t);
      });
    }

function applyChirpTextureToMeshes(){
    if(!chirpMeshes.length || !chirpTexture) return;
    chirpMeshes.forEach((mesh) => {
      if(!mesh?.material) return;
      const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
      materials.forEach((mat) => {
        if(!mat) return;
        mat.map = chirpTexture;
        if(mat.color) mat.color.set('#ffffff');
        mat.transparent = true;
        mat.alphaTest = 0.5;
        mat.polygonOffset = true;
        mat.polygonOffsetFactor = -1;
        mat.polygonOffsetUnits = -1;
        mat.needsUpdate = true;
      });
      mesh.renderOrder = 2;
    });
  }

  function ensurePlanarUv(mesh, axis = 'xz', uniform = true){
    const geom = mesh?.geometry;
    if(!geom || geom.attributes?.uv) return;
    geom.computeBoundingBox();
    const box = geom.boundingBox;
    if(!box) return;
    const size = new THREE.Vector3();
    box.getSize(size);
    const pos = geom.attributes.position;
    const uvs = new Float32Array(pos.count * 2);
    const sizeX = size.x || 1;
    const sizeY = size.y || 1;
    const sizeZ = size.z || 1;
    const denomU = uniform ? Math.max(sizeX, axis === 'xy' ? sizeY : sizeZ) : (axis === 'xy' ? sizeX : sizeX);
    const denomV = uniform ? Math.max(sizeX, axis === 'xy' ? sizeY : sizeZ) : (axis === 'xy' ? sizeY : sizeZ);
    for(let i = 0; i < pos.count; i++){
      const x = pos.getX(i);
      const y = pos.getY(i);
      const z = pos.getZ(i);
      let u = 0;
      let v = 0;
      if(axis === 'xy'){
        u = denomU ? (x - box.min.x) / denomU : 0;
        v = denomV ? (y - box.min.y) / denomV : 0;
      }else{
        u = denomU ? (x - box.min.x) / denomU : 0;
        v = denomV ? (z - box.min.z) / denomV : 0;
      }
      uvs[i * 2] = u;
      uvs[i * 2 + 1] = v;
    }
    geom.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
    geom.attributes.uv.needsUpdate = true;
  }

  function applyPrintTextureToMeshes(meshes, color){
    if(!meshes?.length) return;
    const applyTexture = (tex) => {
      tex.repeat.set(5, 5);
      tex.needsUpdate = true;
      meshes.forEach((mesh) => {
        if(!mesh) return;
        ensurePlanarUv(mesh);
        const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
        materials.forEach((mat) => {
          if(!mat) return;
          mat.map = tex;
          if(mat.color) mat.color.set(color || '#ffffff');
          if('metalness' in mat) mat.metalness = 0;
          if('roughness' in mat) mat.roughness = 1;
          mat.needsUpdate = true;
        });
      });
    };
    if(antiskidPrintTexture){
      antiskidPrintTexture.repeat.set(5, 5);
      antiskidPrintTexture.needsUpdate = true;
      applyTexture(antiskidPrintTexture);
      return;
    }
    antiskidPrintTexture = textureLoader.load('images/millepunte2.jpg', (t) => {
      t.wrapS = t.wrapT = THREE.RepeatWrapping;
      t.repeat.set(5, 5);
      t.colorSpace = THREE.SRGBColorSpace;
      t.flipY = false;
      t.needsUpdate = true;
      applyTexture(t);
    });
  }

  function updateAntiskidEvaMeshes(){
      const isEva = selectedAntiskid === 'eva';
      const isPrint = selectedAntiskid === 'print';
      const isPaint = selectedAntiskid === 'paint';
      const shouldShow = isEva || isPrint || isPaint;
      antiskidEvaMeshes.forEach(mesh => {
        mesh.visible = shouldShow;
      });
      if(isEva){
        applyEvaTextureToMeshes(antiskidEvaMeshes);
      }
      if(isPrint){
        applyPrintTextureToMeshes(antiskidEvaMeshes, selectedDeck || '#ffffff');
      }
      if(isPaint){
        applyPaintTextureToMeshes(antiskidEvaMeshes, selectedDeck || '#ffffff');
      }
    }

    function syncSchienaleMaterial(){
    if(!schienaleMeshes.length || !hatchesMat) return;
    schienaleMeshes.forEach((mesh) => {
      if(!mesh) return;
      if(mesh.material === hatchesMat || !mesh.material){
        mesh.material = hatchesMat?.clone?.() || mesh.material;
      }
      const mat = mesh.material;
      if(!mat) return;
      mat.color.copy(hatchesMat.color);
      mat.map = hatchesMat.map || null;
      mat.userData.baseMap = hatchesMat.userData?.baseMap || null;
      mat.normalMap = null;
      mat.roughnessMap = null;
      mat.metalnessMap = null;
      if('metalness' in mat) mat.metalness = 0;
      if('roughness' in mat) mat.roughness = 1;
      mat.needsUpdate = true;
    });
  }

  function syncTrollingMaterial(){
    if(!trollingMeshes.length) return;
    trollingMeshes.forEach((mesh) => {
      if(!mesh) return;
      if(!mesh.userData?.trollingFixed){
        mesh.material = mesh.material?.clone?.() || mesh.material;
        mesh.userData.trollingFixed = true;
      }
      const mat = mesh.material;
      if(!mat) return;
      mat.normalMap = null;
      mat.roughnessMap = null;
      mat.metalnessMap = null;
      if('metalness' in mat) mat.metalness = 0;
      if('roughness' in mat) mat.roughness = 1;
      mat.needsUpdate = true;
    });
  }

  function updateAntiskidFinish(){
      updateAntiskidEvaMeshes();
      if(selectedFinish === 'wrapping') return;
      if(!selectedAntiskid || selectedAntiskid === 'none') return;
      if(selectedAntiskid === 'eva' || selectedAntiskid === 'print' || selectedAntiskid === 'paint') return;
      if(selectedDeck) applyAntiskidVariant(deckMat, selectedDeck, selectedAntiskid);
      if(selectedHatches) applyAntiskidVariant(hatchesMat, selectedHatches, selectedAntiskid);
      syncSchienaleMaterial();
    }

    function applyWrappingTextureFor(mat, texturePath, scale){
    if(!mat) return;
    if(texturePath){
      mat.color.set('#ffffff');
      textureLoader.load(texturePath, (t) => {
        t.wrapS = t.wrapT = THREE.RepeatWrapping;
        const s = Number.isFinite(scale) ? scale : 2;
        t.repeat.set(s, s);
        mat.map = t;
        mat.needsUpdate = true;
      });
    }else{
      mat.map = null;
      mat.needsUpdate = true;
    }
  }

  function isDarkColor(hex){
    if(!hex || typeof hex !== 'string') return false;
    const cleaned = hex.replace('#', '');
    if(cleaned.length !== 6) return false;
    const r = parseInt(cleaned.slice(0, 2), 16);
    const g = parseInt(cleaned.slice(2, 4), 16);
    const b = parseInt(cleaned.slice(4, 6), 16);
    const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b);
    return luminance < 80;
  }

  function isWrappingWhiteTrigger(texturePath){
    if(!texturePath) return false;
    const name = texturePath.toLowerCase();
    return name.includes('carbon') || name.includes('greenwave') || name.includes('abstract');
  }

  function updateLogoAndBottazzo(){
    const makeWhite = wrappingWhite || hullDark;
    const color = makeWhite ? '#FFFFFF' : '#000000';
    if(bottazzoMat){
      if(bottazzoMat.map){
        bottazzoMat.map = null;
      }
      bottazzoMat.color.set(color);
      bottazzoMat.needsUpdate = true;
    }
    if(scrittaMat){
      const tex = makeWhite ? scrittaTextures.white : scrittaTextures.black;
      if(tex){
        scrittaMat.map = tex;
        scrittaMat.color.set('#ffffff');
        scrittaMat.transparent = true;
        scrittaMat.alphaTest = 0.5;
        scrittaMat.needsUpdate = true;
      }else{
        const texPath = makeWhite ? 'images/Scritta_white.png' : 'images/Scritta_black.png';
        textureLoader.load(texPath, (t) => {
          scrittaMat.map = t;
          scrittaMat.color.set('#ffffff');
          scrittaMat.transparent = true;
          scrittaMat.alphaTest = 0.5;
          scrittaMat.needsUpdate = true;
        });
      }
    }
  }

  window.selectFinitura = function(f, btn, autoNext = true) {
    setActiveColor('finish', btn);
    finishSelected = true;
    selectedFinish = f;
    resetColorsToBase();
    updateColorOptions(f);
    updateAntiskidFinish();
    updatePrice();
    if(autoNext && currentStep === 'finitura') showStep('colori');
  };

  function resetColorsToBase(){
    hullSelected = false;
    deckSelected = false;
    hatchesSelected = false;
    hatchesAuto = true;
    selectedHull = null;
    selectedDeck = null;
    selectedHatches = null;
    if(hullMat){
      hullMat.map = null;
      hullMat.color.set('#ffffff');
      hullMat.needsUpdate = true;
    }


    
    if(deckMat){
      deckMat.map = null;
      deckMat.color.set('#ffffff');
      deckMat.needsUpdate = true;
    }
    if(hatchesMat){
      hatchesMat.map = null;
      hatchesMat.color.set('#ffffff');
      hatchesMat.needsUpdate = true;
    }
    wrappingWhite = false;
    hullDark = false;
    deckDark = false;
    selectedAntiskid = 'none';
    const antiskidSelect = document.querySelector('#antiskid-select select');
    if(antiskidSelect){
      antiskidSelect.value = 'none';
    }
    updateAntiskidFinish();
    updateLogoAndBottazzo();
  }

  function resetAllConfig(){
        finishSelected = false;
        selectedFinish = null;
        accessoriUnlocked = false;
        selectedHullMode = null;
        selectedDeckMode = null;
        selectedHatchesMode = null;
        unlockConfigurator();
        resetColorsToBase();
        resetAccessoryUI();
        updateAccessoryRules();
        const finishSelect = document.querySelector('#finish-select select');
        if(finishSelect) finishSelect.value = '';
        const antiskidSelect = document.querySelector('#antiskid-select select');
        if(antiskidSelect) antiskidSelect.value = '';
        updatePrice();
      }


    


  function setActiveColor(group, btn){
    if(!btn) return;
    document.querySelectorAll(`button[data-group="${group}"]`).forEach(b => {
      b.classList.toggle('active', b === btn);
    });
  }

  
    function selectOptionByLabel(select, label){
      if(!select) return;
      const opts = Array.from(select.options || []);
      const target = opts.find(o => (o.textContent || '').trim().toLowerCase() === label.toLowerCase());
      if(target){
        select.value = target.value;
        select.dispatchEvent(new Event('change'));
      }
    }

    function lockConfigurator(){
      presetLocked = true;
      const finishSelect = document.querySelector('#finish-select select');
      if(finishSelect) finishSelect.disabled = true;
      document.querySelectorAll('#step-colori select').forEach(sel => sel.disabled = true);
      const antiskidSel = document.querySelector('#antiskid-select select');
      if(antiskidSel) antiskidSel.disabled = true;
    }

    function unlockConfigurator(){
      presetLocked = false;
      presetName = '';
      const finishSelect = document.querySelector('#finish-select select');
      if(finishSelect) finishSelect.disabled = false;
      document.querySelectorAll('#step-colori select').forEach(sel => sel.disabled = false);
      const antiskidSel = document.querySelector('#antiskid-select select');
      if(antiskidSel) antiskidSel.disabled = false;
    }


    function applyPresetConfig(name){
      presetName = name;
      accessoriUnlocked = true;
      resetAccessoryUI();
      if(name === 'nico'){
        selectFinitura('paint', null, false);
      }else if(name === 'gabry'){
        selectFinitura('gelcoat', null, false);
      }

      const applyChoices = () => {
        if(name === 'nico'){
          // Hull/Deck/Doors -> Rugged Acid
          selectOptionByLabel(colorSelects.hull, 'Acid');
          selectOptionByLabel(colorSelects.deck, 'Acid');
          selectOptionByLabel(colorSelects.hatches, 'Acid');
          selectedAntiskid = 'eva';
        }else if(name === 'gabry'){
          // Hull -> Color Acquamarina, Deck/Doors -> White
          selectOptionByLabel(colorSelects.hull, 'Acquamarina');
          selectOptionByLabel(colorSelects.hull, 'Aquamarina');
          selectOptionByLabel(colorSelects.deck, 'White');
          selectOptionByLabel(colorSelects.hatches, 'White');
          selectedAntiskid = 'print';
        }
        const antiskidSel = document.querySelector('#antiskid-select select');
        if(antiskidSel){
          antiskidSel.value = selectedAntiskid || '';
        }
        updateAntiskidFinish();
        updatePrice();

        const presetAccessories = {
          nico: ['tientibene', 'panca', 'schienale', 'supporto'],
          gabry: ['tientibene', 'panca', 'schienale', 'supporto', 'impianto', 'batteria', 'trolling']
        };
        (presetAccessories[name] || []).forEach(key => setAccessoryChecked(key, true, true));
        updateAccessoryRules();
        updatePrice();
        lockConfigurator();
        accessoriUnlocked = true;
        setTimeout(() => showStep('accessori'), 0);
      };

      setTimeout(applyChoices, 0);
    }

function renderFinishSelect(){
    const container = document.getElementById('finish-select');
    if(!container) return;
    container.innerHTML = '';
    const select = document.createElement('select');
    const placeholder = document.createElement('option');
    placeholder.textContent = 'Select';
    placeholder.value = '';
    placeholder.disabled = true;
    placeholder.selected = true;
    select.appendChild(placeholder);
    const options = [
        { label: 'Gelcoat', value: 'gelcoat' },
        { label: 'Acrylic', value: 'paint' },
        { label: 'Nico', value: 'nico' },
        { label: 'Gabry', value: 'gabry' }
      ];
    options.forEach(({ label, value }) => {
        const opt = document.createElement('option');
        opt.textContent = label;
        opt.value = value;
        if(value === 'nico') opt.style.color = '#00ff00';
        if(value === 'gabry') opt.style.color = '#3aa7ff';
        select.appendChild(opt);
      });
    select.addEventListener('change', () => {
        if(!select.value) return;
        if(select.value === 'nico' || select.value === 'gabry'){
          applyPresetConfig(select.value);
          setTimeout(() => {
            if(currentStep !== 'accessori') showStep('accessori');
          }, 0);
          return;
        }
        selectFinitura(select.value, null, true);
      });
    container.appendChild(select);
  }

  window.setHull = function(color, btn){
      selectedHullMode = resolveFinishMode(btn);
    if(btn?.dataset?.texture){
      applyWrappingTextureFor(hullMat, btn.dataset.texture, Number(btn.dataset.scale));
      wrappingWhite = isWrappingWhiteTrigger(btn.dataset.texture);
      hullDark = false;
    }else if(btn?.dataset?.rugged){
      applyRuggedTexture(hullMat, color);
      hullDark = isDarkColor(color);
      wrappingWhite = false;
    }else if(selectedFinish === 'rugged'){
      applyAntiskid(hullMat, color);
      applyAntiskid(deckMat, color);
      applyAntiskid(hatchesMat, color);
      hullDark = isDarkColor(color);
      deckDark = hullDark;
      wrappingWhite = false;
      deckSelected = true;
      hatchesSelected = true;
      selectedDeck = color;
      selectedHatches = color;
    }else if(hullMat){
      hullMat.map = null;
      hullMat.color.set(color);
      hullMat.needsUpdate = true;
      hullDark = isDarkColor(color);
      wrappingWhite = false;
    }
    hullSelected = true;
    selectedHull = color;
    checkStep();
    updateLogoAndBottazzo();
      updatePrice();
  }
  window.setDeck = function(color, btn){
      selectedDeckMode = resolveFinishMode(btn);
    if(btn?.dataset?.texture){
      applyWrappingTextureFor(deckMat, btn.dataset.texture, Number(btn.dataset.scale));
      wrappingWhite = isWrappingWhiteTrigger(btn.dataset.texture);
      deckDark = false;
    }else if(btn?.dataset?.rugged){
      applyRuggedTexture(deckMat, color);
      deckDark = isDarkColor(color);
      wrappingWhite = false;
    }else if(deckMat){
      if(deckMat.userData?.compositeMap){
        deckMat.userData.compositeMap.dispose();
        deckMat.userData.compositeMap = null;
      }
      deckMat.userData.baseMap = null;
      deckMat.map = null;
      deckMat.color.set(color);
      deckMat.needsUpdate = true;
      deckDark = isDarkColor(color);
      wrappingWhite = false;
    }
    deckSelected = true;
    selectedDeck = color;
      updateAntiskidOptions(selectedFinish);
    checkStep();
    updateLogoAndBottazzo();
      updatePrice();
    if(hatchesAuto){
      setHatches(color, btn, false);
      if(btn?.textContent) setColorLabel('hatches', btn.textContent);
      if(selectedFinish === 'gelcoat' && btn?.textContent && gelcoatTriggers?.hatches){
        gelcoatTriggers.hatches.textContent = btn.textContent;
      }
      const hSelect = colorSelects.hatches;
      if(hSelect){
        if(btn?.dataset.texture){
          const match = Array.from(hSelect.options).find(opt => opt.dataset.texture === btn.dataset.texture);
          if(match){
            hSelect.value = match.value;
          }
        }else{
          hSelect.value = color;
        }
      }
    }
  };

  window.setHatches = function(color, btn, manual = true){
      selectedHatchesMode = resolveFinishMode(btn);
    if(btn?.textContent) setColorLabel('hatches', btn.textContent);
    if(btn?.dataset?.texture){
      applyWrappingTextureFor(hatchesMat, btn.dataset.texture, Number(btn.dataset.scale));
    }else if(btn?.dataset?.rugged){
      applyRuggedTexture(hatchesMat, color);
    }else if(hatchesMat){
      if(hatchesMat.userData?.compositeMap){
        hatchesMat.userData.compositeMap.dispose();
        hatchesMat.userData.compositeMap = null;
      }
      hatchesMat.userData.baseMap = null;
      hatchesMat.map = null;
      hatchesMat.color.set(color);
      hatchesMat.needsUpdate = true;
    }
    hatchesSelected = true;
    selectedHatches = color;
    updateAntiskidFinish();
      updatePrice();
    checkStep();
    if(manual) hatchesAuto = false;
  };;;;

  window.setBottazzoColor = function(color){
    if(bottazzoMat){
      bottazzoMat.color.set(color);
      bottazzoMat.needsUpdate = true;
    }
  };

  window.setScrittaColor = function(color){
    if(scrittaMat){
      scrittaMat.color.set(color);
      scrittaMat.needsUpdate = true;
    }
  };
  function checkStep(){
    if(hullSelected && deckSelected && hatchesSelected){
      // waiting for "Avanti"
    }
  }

  window.goBack = function(){
      if(currentStep === 'accessori' && (presetLocked || presetName)){
        unlockConfigurator();
        accessoriUnlocked = false;
        resetAllConfig();
        showStep('finitura');
        return;
      }
      if(currentStep === 'colori'){
        resetAllConfig();
        showStep('finitura');
      }else if(currentStep === 'accessori'){
        showStep('colori');
      }
    };

  window.goNext = function(){
    if(currentStep === 'finitura'){
      if(!finishSelected) return;
      showStep('colori');
      return;
    }
    if(currentStep === 'colori'){
      if(!(hullSelected && deckSelected && hatchesSelected)) return;
      accessoriUnlocked = true;
      showStep('accessori');
    }
  };
  window.toggleAccessory = function(name,state, silent = false){
    if(accessories[name]) accessories[name].visible=state;
    if(accessoryGroups[name]) accessoryGroups[name].forEach(obj => obj.visible = state);
    if(name === 'schienale' && state){
      syncSchienaleMaterial();
    }
    if(name === 'trolling' && state){
      syncTrollingMaterial();
    applyMaterialOverrides(gltf.scene);
    }
    if(!silent){
      const sfx = state ? sounds.on : sounds.off;
      if(sfx){
        if(audioEnabled && !audioUnlocked){
          audioUnlocked = true;
        }
        sfx.currentTime = 0;
        sfx.play().catch(() => {});
      }
      unlockAudio();
    }
    updatePrice();
    updateAccessoryRules();
    updatePrice();
  };

  window.resetAllAccessories = function(){
    resetAccessoryUI();
  };

    let currentOrderId = null;
  let lastScreenshotDataUrl = null;
  let lastPresetScreenshots = [];
  

  function generateOrderId(){
    const rand = Math.floor(Math.random() * 1e6).toString().padStart(6, '0');
    return `NS-${Date.now()}-${rand}`;
  }

    function getAccessoriesSummary(){
    const items = [];
    document.querySelectorAll('#step-accessori input[type="checkbox"]')?.forEach((cb) => {
      if(cb.checked){
        const label = cb.closest('label')?.textContent?.trim() || cb.dataset.accessory;
        if(label) items.push(label);
      }
    });
    return items.length ? items.join(', ') : 'Nessuno';
  }
    function getSelectedAccessoriesDetailed(){
    const isChecked = (name) =>
      document.querySelector(`#step-accessori input[data-accessory="${name}"]`)?.checked;
    const isVisible = (name) =>
      accessories[name]?.visible ||
      (accessoryGroups[name] && accessoryGroups[name].some(obj => obj.visible));
    const isSelected = (name) => Boolean(isChecked(name) || isVisible(name));
    const order = [
      { key: 'antiskid', label: 'Antiskid' },
      { key: 'tientibene', label: 'Tientibene' },
      { key: 'panca', label: 'Panca' },
      { key: 'schienale', label: 'Schienale' },
      { key: 'supporto', label: 'Supporto motore' },
      { key: 'motore', label: 'Motore' },
      { key: 'trolling', label: 'Trolling motor' },
      { key: 'fishfinder', label: 'Fishfinder' },
      { key: 'impianto', label: 'Impianto elettrico' },
      { key: 'batteria', label: 'Batteria al Litio' }
    ];
    const items = [];
    order.forEach((item) => {
      if(item.key === 'antiskid'){
        if((selectedAntiskid || 'none') !== 'none'){
          const price = getAntiskidPrice();
          const label = `Antiskid (${getAntiskidLabel()})`;
          items.push({ label, price });
        }
        return;
      }
      if(isSelected(item.key)){
        const price = priceTable?.accessories?.[item.key] ?? 0;
        items.push({ label: item.label, price });
      }
    });
    return items;
  }
      function formatEuro(value){
    const num = Number(value) || 0;
    const euro = "\u20AC";
    return `${euro} ${num.toLocaleString('it-IT')}`;
  }
      function getFinishLabel(){
    const map = { gelcoat: 'Gelcoat', paint: 'Acrylic', rugged: 'Rugged', wrapping: 'Wrapping' };
    return map[selectedFinish] || selectedFinish || '-';
  }
  function getSelectLabel(sel, fallback){
    if(!sel) return fallback || '-';
    const opt = sel.options?.[sel.selectedIndex];
    return opt?.textContent?.trim() || fallback || '-';
  }
  function getAntiskidLabel(){
    const sel = document.querySelector('#antiskid-select select');
    return getSelectLabel(sel, selectedAntiskid || 'none');
  }
  function getColorLabel(group, fallback){
    if(group === 'hull' && selectedHullLabel) return selectedHullLabel;
    if(group === 'deck' && selectedDeckLabel) return selectedDeckLabel;
    if(group === 'hatches' && selectedHatchesLabel) return selectedHatchesLabel;
    return getSelectLabel(colorSelects[group], fallback || '-');
  }
function getColorsSummary(){
    const hull = getColorLabel('hull', selectedHull || '-');
    const deck = getColorLabel('deck', selectedDeck || '-');
    const doors = getColorLabel('hatches', selectedHatches || '-');
    return `Hull (${hull}), Deck (${deck}), Doors (${doors})`;
  }

    function getAntiskidPrice(){
    const key = (selectedAntiskid || 'none').toLowerCase();
    if(key === 'none') return 0;
    const table = priceTable?.accessories?.antiskid;
    if(typeof table === 'number') return table || 0;
    return (table && typeof table === 'object') ? (table[key] ?? 0) : 0;
  }
  function getPriceSummary(){
    const el = document.getElementById('price-tag');
    return el ? el.textContent.trim() : '';
  }

        function getEmailPayloadForTemplate(payload, assets = {}){
    const colori = getColorsSummary();
    const finitura = typeof getFinishLabel === 'function' ? getFinishLabel() : payload.finish;
    const antiskid = typeof getAntiskidLabel === 'function' ? getAntiskidLabel() : payload.antiskid;
    const now = new Date();
    const date = now.toLocaleDateString('it-IT') + ' ' + now.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' });
    return {
      id: payload.id,
      finitura,
      colori,
      antiskid,
      accessori: payload.accessories,
      prezzo: payload.price,
      nome: payload.customer.nome,
      cognome: payload.customer.cognome,
      email: payload.customer.email,
      telefono: payload.customer.telefono,
      indirizzo: payload.customer.indirizzo,
      citta: payload.customer.citta,
      cap: payload.customer.cap,
      note: payload.customer.note,
      date,
      img_main: assets.img_main || '',
      img_top_right: assets.img_top_right || '',
      img_bottom_right: assets.img_bottom_right || '',
      qr: assets.qr || '',
      configurazione_json: JSON.stringify(payload)
    };
  }
  function canSendEmail(){
    return Boolean(window.emailjs && EMAILJS_SERVICE_ID && EMAILJS_TEMPLATE_ID_CLIENT && EMAILJS_TEMPLATE_ID_ADMIN && EMAILJS_PUBLIC_KEY);
  }

  function initEmailJs(){
    if(emailJsReady) return;
    if(window.emailjs && EMAILJS_PUBLIC_KEY){
      window.emailjs.init(EMAILJS_PUBLIC_KEY);
      emailJsReady = true;
    }
  }

    function sendOrderEmails(payload, assets){
    if(!canSendEmail()){
      return Promise.reject(new Error('EmailJS non configurato'));
    }
    initEmailJs();
    const data = getEmailPayloadForTemplate(payload, assets);
    console.log('EmailJS admin template:', EMAILJS_TEMPLATE_ID_ADMIN);
    console.log('EmailJS client template:', EMAILJS_TEMPLATE_ID_CLIENT, 'to', payload.customer.email);
    const sendAdmin = window.emailjs.send(EMAILJS_SERVICE_ID, EMAILJS_TEMPLATE_ID_ADMIN, data);
    const sendClient = window.emailjs.send(EMAILJS_SERVICE_ID, EMAILJS_TEMPLATE_ID_CLIENT, {
      ...data,
      to_email: payload.customer.email
    });
    return Promise.all([sendAdmin, sendClient]).then((results) => {
      console.log('EmailJS risultati:', results);
      return results;
    });
  }
  function prepareOrderPayload(){
    const getVal = (id) => document.getElementById(id)?.value || '';
    return {
      id: currentOrderId || generateOrderId(),
      finish: selectedFinish || '',
      colors: {
        hull: getColorLabel('hull', selectedHull || ''),
        deck: getColorLabel('deck', selectedDeck || ''),
        hatches: getColorLabel('hatches', selectedHatches || '')
      },
      antiskid: selectedAntiskid || 'none',
      accessories: getAccessoriesSummary(),
      price: getPriceSummary(),
      customer: {
        nome: getVal('order-nome'),
        cognome: getVal('order-cognome'),
        email: getVal('order-email'),
        telefono: getVal('order-telefono'),
        indirizzo: getVal('order-indirizzo'),
        citta: getVal('order-citta'),
        cap: getVal('order-cap'),
        note: getVal('order-note')
      }
    };
  }
function openOrderModal(){
    if(!currentOrderId){
      currentOrderId = generateOrderId();
    }
    const modal = document.getElementById('order-modal');
    if(!modal) return;
    modal.classList.add('is-open');
    modal.setAttribute('aria-hidden', 'false');
    const setText = (id, value) => {
      const el = document.getElementById(id);
      if(el) el.textContent = value || '';
    };
    setText('order-id', currentOrderId);
    setText('order-finish', selectedFinish || '-');
    setText('order-colors', getColorsSummary());
    setText('order-antiskid', selectedAntiskid || 'none');
    setText('order-accessories', getAccessoriesSummary());
    setText('order-price', getPriceSummary());
    const qrEl = document.getElementById('order-qr');
    if(qrEl){
      qrEl.innerHTML = '';
      if(typeof QRCode !== 'undefined'){
        new QRCode(qrEl, { text: currentOrderId, width: 128, height: 128 });
      }
    }
  }

  function closeOrderModal(){
    const modal = document.getElementById('order-modal');
    if(!modal) return;
    modal.classList.remove('is-open');
    modal.setAttribute('aria-hidden', 'true');
  }
  function captureScreenshot(){
    if(!renderer || !renderer.domElement) return null;
    try{
      const dataUrl = renderer.domElement.toDataURL('image/png');
      lastScreenshotDataUrl = dataUrl;
      return dataUrl;
    }catch(err){
      console.warn('Screenshot fallito', err);
      return null;
    }
  }

    function setCameraView(pos, target){
    if(!camera || !controls) return;
    camera.position.set(pos[0], pos[1], pos[2]);
    controls.target.set(target[0], target[1], target[2]);
    controls.update();
    renderer.render(scene, camera);
  }

      async function uploadDataUrl(dataUrl){
    if(!dataUrl || !UPLOAD_ENDPOINT || UPLOAD_ENDPOINT.includes('YOUR-VERCEL-APP')){
      return '';
    }
    const res = await fetch(UPLOAD_ENDPOINT, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ dataUrl })
    });
    if(!res.ok){
      throw new Error(`Upload failed: ${res.status}`);
    }
    const json = await res.json();
    return json.url || '';
  }
  async function downscaleDataUrl(dataUrl, maxWidth){
    return new Promise((resolve) => {
      if(!dataUrl){
        resolve('');
        return;
      }
      const img = new Image();
      img.onload = () => {
        try{
          const scale = Math.min(1, maxWidth / (img.naturalWidth || maxWidth));
          if(scale >= 1){
            resolve(dataUrl);
            return;
          }
          const canvas = document.createElement('canvas');
          canvas.width = Math.max(1, Math.round((img.naturalWidth || maxWidth) * scale));
          canvas.height = Math.max(1, Math.round((img.naturalHeight || maxWidth) * scale));
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          resolve(canvas.toDataURL('image/jpeg', 0.82));
        }catch(err){
          resolve(dataUrl);
        }
      };
      img.onerror = () => resolve(dataUrl);
      img.src = dataUrl;
    });
  }

          async function prepareEmailAssets(){
    let shots = Array.isArray(lastPresetScreenshots) ? lastPresetScreenshots : [];
    if(!shots.length){
      try{
        shots = await capturePresetScreenshots();
      }catch(err){
        shots = [];
      }
    }
    const side = shots.find(s => s.label === 'Side') || shots[0] || null;
    const rear = shots.find(s => s.label === 'Rear') || shots[1] || null;
    const top = shots.find(s => s.label === 'Top') || shots[2] || null;
    const qrData = await makeQrDataUrl(currentOrderId || generateOrderId());
    const [img_main, img_top_right, img_bottom_right, qr] = await Promise.all([
      uploadDataUrl(side?.dataUrl || ''),
      uploadDataUrl(rear?.dataUrl || ''),
      uploadDataUrl(top?.dataUrl || ''),
      uploadDataUrl(qrData)
    ]);
    return { img_main, img_top_right, img_bottom_right, qr };
  }

  async function capturePresetScreenshots(){
    if(!renderer || !camera || !controls) return [];
    const originalPos = camera.position.clone();
    const originalTarget = controls.target.clone();
            const target = [-0.10810611905192113, -0.167470325414858, -0.13144927171760207];
    const views = [
      { label: 'Side', pos: [0.0516653740024167, 0.1820664977829592, 0.8294428750065087], target: [-0.05, -0.167470325414858, -0.13144927171760207] },
      { label: 'Rear', pos: [-0.8191399443716609, 0.1300141316619867, 0.3925348763178731] },
      { label: 'Top', pos: [0.4912714944470407, 0.4747723290977302, -0.4437419989992951], target: [0.05, -0.08190660770733932, 0.07343899384140155] }
    ];
    const results = [];
    for(const view of views){
      setCameraView(view.pos, view.target || target);
      await new Promise((resolve) => requestAnimationFrame(() => resolve()));
      const shot = captureScreenshot();
      if(shot){
        results.push({ label: view.label, dataUrl: shot });
      }
    }
    camera.position.copy(originalPos);
    controls.target.copy(originalTarget);
    controls.update();
    renderer.render(scene, camera);
    return results;
  }

function downloadScreenshot(){
    const dataUrl = captureScreenshot();
    if(!dataUrl) return;
    const link = document.createElement('a');
    const id = currentOrderId || 'config';
    link.href = dataUrl;
    link.download = `screenshot-${id}.png`;
    document.body.appendChild(link);
    link.click();
    link.remove();
  }

  async function loadImageAsDataUrl(src){
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => {
        try{
          const canvas = document.createElement('canvas');
          canvas.width = img.naturalWidth;
          canvas.height = img.naturalHeight;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0);
          resolve({
            dataUrl: canvas.toDataURL('image/png'),
            width: img.naturalWidth,
            height: img.naturalHeight
          });
        }catch(err){
          reject(err);
        }
      };
      img.onerror = reject;
      img.src = src;
    });
  }

  async function makeQrDataUrl(text){
    return new Promise((resolve) => {
      if(typeof QRCode === 'undefined'){
        resolve(null);
        return;
      }
      const holder = document.createElement('div');
      holder.style.position = 'absolute';
      holder.style.left = '-9999px';
      holder.style.top = '-9999px';
      document.body.appendChild(holder);
      new QRCode(holder, { text, width: 160, height: 160 });
      const img = holder.querySelector('img');
      if(img && img.src){
        resolve(img.src);
      }else{
        const canvas = holder.querySelector('canvas');
        resolve(canvas ? canvas.toDataURL('image/png') : null);
      }
      holder.remove();
    });
  }

  async function downloadOrderPdf(){
    if(!window.jspdf?.jsPDF) return;
    const doc = new window.jspdf.jsPDF({ unit: 'mm', format: 'a4' });
    const pageW = doc.internal.pageSize.getWidth();
    const pageH = doc.internal.pageSize.getHeight();
    const margin = 12;

    if(!currentOrderId){
      currentOrderId = generateOrderId();
    }

    let logoData = null;
    try{
      logoData = await loadImageAsDataUrl('images/Scritta_black.png');
    }catch(err){
      console.warn('Logo non caricato', err);
    }

    const now = new Date();
    const dateStr = now.toLocaleDateString('it-IT') + ' ' + now.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' });

    // Header
    if(logoData && logoData.dataUrl){
      const maxW = 57;
      const maxH = 15;
      const ratio = logoData.width && logoData.height ? (logoData.width / logoData.height) : 4;
      let w = maxW;
      let h = w / ratio;
      if(h > maxH){
        h = maxH;
        w = h * ratio;
      }
      doc.addImage(logoData.dataUrl, 'PNG', margin, 10, w, h, undefined, 'FAST');
    }
    doc.setFontSize(9);
    doc.setTextColor(60);
    doc.text(`Ninga ID: ${currentOrderId}`, pageW - margin, 12, { align: 'right' });
    doc.text(`Salvato: ${dateStr}`, pageW - margin, 17, { align: 'right' });

    const qrData = await makeQrDataUrl(currentOrderId);
    if(qrData){
      const qrSize = 22;
      doc.addImage(qrData, 'PNG', pageW - margin - qrSize, 25, qrSize, qrSize, undefined, 'FAST');
    }

    doc.setDrawColor(210);
    doc.line(margin, 22, pageW - margin, 22);

    // Title
    doc.setTextColor(20);
    doc.setFontSize(24);
    doc.text('FISHER 40', margin, 34);
    doc.setFontSize(12);
    doc.text('Configurazione personalizzata', margin, 41);

    // Images layout
    let shots = Array.isArray(lastPresetScreenshots) ? lastPresetScreenshots : [];
    if(!shots.length){
      const single = lastScreenshotDataUrl || captureScreenshot();
      if(single){
        shots = [{ label: 'Vista', dataUrl: single }];
      }
    }
    if(shots.length === 1){
      shots = [shots[0], shots[0], shots[0]];
    }else if(shots.length === 2){
      shots = [shots[0], shots[1], shots[1]];
    }

    const imgTop = 50;
    const imgGap = 4;
    const leftW = 118;
    const leftH = 78;
    const rightW = pageW - margin - (margin + leftW) - imgGap;
    const rightH = (leftH - imgGap) / 2;
    const leftX = margin;
    const rightX = margin + leftW + imgGap;

    if(shots[0]){
      doc.addImage(shots[0].dataUrl, 'PNG', leftX, imgTop, leftW, leftH, undefined, 'FAST');
    }
    if(shots[1]){
      doc.addImage(shots[1].dataUrl, 'PNG', rightX, imgTop, rightW, rightH, undefined, 'FAST');
    }
    if(shots[2]){
      doc.addImage(shots[2].dataUrl, 'PNG', rightX, imgTop + rightH + imgGap, rightW, rightH, undefined, 'FAST');
    }

            // Configurazione + Accessori
    const listTop = imgTop + leftH + 10;
    doc.setDrawColor(210);
    doc.line(margin, listTop, pageW - margin, listTop);

    doc.setFontSize(10);
    doc.setTextColor(20);
    doc.setFont('helvetica', 'bold');
    doc.text('Configurazione', margin, listTop + 6);
    doc.setFont('helvetica', 'normal');

    doc.setFontSize(9);
    const cfgStartY = listTop + 12;
        doc.text(`- Finitura: ${getFinishLabel()}`, margin + 2, cfgStartY);
    const finishPct = priceTable?.finishPct?.[selectedFinish] || 0;
    const finishPrice = priceTable.base + (priceTable.base * finishPct);
    doc.text(formatEuro(finishPrice), pageW - margin, cfgStartY, { align: 'right' });
    const hullLabel = getColorLabel('hull', selectedHull || '-');
    const deckLabel = getColorLabel('deck', selectedDeck || '-');
    const doorsLabel = getColorLabel('hatches', selectedHatches || '-');
    const colorsY = cfgStartY + 5;
    const colorsLine = `- Colori: Hull (${hullLabel}), Deck (${deckLabel}), Doors (${doorsLabel})`;
    doc.setFont('helvetica', 'normal');
    doc.text(colorsLine, margin + 2, colorsY);
    doc.text(`- Antiskid: ${getAntiskidLabel()}`, margin + 2, cfgStartY + 10);

    const items = getSelectedAccessoriesDetailed();
    const rowH = 5;
    const listStartY = cfgStartY + 20;

    doc.setFontSize(10);
    doc.setFont('helvetica', 'bold');
    doc.text('Accessori selezionati', margin, listStartY);
    doc.setFont('helvetica', 'normal');

    const accessoriesY = listStartY + 6;
    if(items.length){
      items.forEach((item, idx) => {
        const y = accessoriesY + idx * rowH;
        doc.text(`- ${item.label}`, margin + 2, y);
        doc.text(formatEuro(item.price), pageW - margin, y, { align: 'right' });
      });
    }else{
      doc.setTextColor(90);
      doc.text('Nessuno', margin + 2, accessoriesY);
      doc.setTextColor(20);
    }

    const totalLineY = accessoriesY + Math.max(items.length, 1) * rowH + 2;
    doc.setDrawColor(210);
    doc.line(margin, totalLineY, pageW - margin, totalLineY);
    const totalTextY = totalLineY + 7;
    doc.setFontSize(11);
    doc.setFont('helvetica', 'bold');
    doc.text('Totale configurazione', margin, totalTextY);
    doc.text(getPriceSummary() || '-', pageW - margin, totalTextY, { align: 'right' });
    doc.setFont('helvetica', 'normal');

    // Footer notes
    doc.setFontSize(8);
    doc.setTextColor(120);
    const noteY = totalTextY + 8;
    doc.text('Immagini e specifiche sono indicative. Prezzi soggetti a variazione.', margin, noteY);

    doc.save(`ordine-${currentOrderId || 'config'}.pdf`);
  }
window.addEventListener('DOMContentLoaded', () => {
    const orderBtn = document.getElementById('order-btn');
    const orderModal = document.getElementById('order-modal');
    const orderClose = document.querySelector('#order-modal .order-close');
    const orderDownload = document.getElementById('order-download');
    const orderConfirm = document.getElementById('order-confirm');
    initEmailJs();
    if(orderBtn){
      orderBtn.addEventListener('click', async () => {
        const prev = orderBtn.textContent;
        orderBtn.disabled = true;
        orderBtn.textContent = 'Caricamento...';
        try{
          lastPresetScreenshots = await capturePresetScreenshots();
        }catch(err){
          console.warn('Preset screenshot fallito', err);
          lastPresetScreenshots = [];
        }finally{
          orderBtn.disabled = false;
          orderBtn.textContent = prev;
        }
        openOrderModal();
      });
    }
    if(orderClose){
      orderClose.addEventListener('click', () => {
        closeOrderModal();
      });
    }
    if(orderModal){
      orderModal.addEventListener('click', (e) => {
        if(e.target === orderModal){
          closeOrderModal();
        }
      });
    }
    if(orderDownload){
      orderDownload.addEventListener('click', () => {
        downloadOrderPdf();
      });
    }
    if(orderConfirm){
      orderConfirm.addEventListener('click', async () => {
        const payload = prepareOrderPayload();
        if(!payload.customer.email || !payload.customer.email.includes('@')){
          alert('Inserisci un indirizzo email valido.');
          return;
        }
        if(canSendEmail()){
          const originalLabel = orderConfirm.textContent;
          orderConfirm.disabled = true;
          orderConfirm.textContent = 'Invio...';
          try{
            const assets = await prepareEmailAssets();
            await sendOrderEmails(payload, assets);
            alert('Ordine inviato correttamente. Ti contatteremo a breve.');
          }catch(err){
            console.error(err);
            alert('Errore invio ordine. Puoi scaricare il PDF e riprovare.');
          }finally{
            orderConfirm.disabled = false;
            orderConfirm.textContent = originalLabel;
          }
          return;
        }
        const subject = `Ordine configurazione ${payload.id}`;
        const body = `ID: ${payload.id}
Finitura: ${payload.finish}
Colori: Hull (${payload.colors.hull}), Deck (${payload.colors.deck}), Doors (${payload.colors.hatches})
Antiskid: ${payload.antiskid}
Accessori: ${payload.accessories}
Prezzo: ${payload.price}

Cliente:
Nome: ${payload.customer.nome}
Cognome: ${payload.customer.cognome}
Email: ${payload.customer.email}
Telefono: ${payload.customer.telefono}
Indirizzo: ${payload.customer.indirizzo}
Citta: ${payload.customer.citta}
CAP: ${payload.customer.cap}
Note: ${payload.customer.note}`;
        const mailto = `mailto:ningaskiffs@gmail.com?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
        window.location.href = mailto;
      });
    }
    renderFinishSelect();
    renderAntiskidSelect();
    resetAccessoryUI();
    const audioBtn = document.getElementById('audio-toggle');
    const screenshotBtn = document.getElementById('screenshot-btn');
    if(screenshotBtn){
      screenshotBtn.addEventListener('click', () => {
        downloadScreenshot();
      });
    }
    if(audioBtn){
      audioBtn.addEventListener('click', () => {
        setAudioEnabled(!audioEnabled, true);
      });
      setAudioEnabled(audioEnabled, false);
    }
    const viewer = document.getElementById('viewer');
    if(viewer){
      viewer.addEventListener('pointerdown', () => {
        unlockAudio();
        if(audioEnabled){
          sounds.bg.play().catch(() => {});
        }
      });
    }
  
  });

  function animate(){
    requestAnimationFrame(animate);
    controls.update();
    if(water){
      water.material.uniforms['time'].value += 1.0 / 600.0;
    }
    renderer.render(scene,camera);
  }
  animate();

  window.addEventListener('resize', () => {
    applyMobileRotate();
  });
  applyMobileRotate();
</script>

</body>
</html>
























































































































































